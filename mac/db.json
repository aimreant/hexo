{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/yijie.jpg","path":"images/yijie.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"c535694871d259969769326dc962014a195385fc","modified":1492955318000},{"_id":"source/404.html","hash":"f449aeec378bcb2f70db01406218a885d98a1c39","modified":1494308547000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1492938515000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1492938515000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1492938515000},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1492938515000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1492938515000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1492938515000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1492938515000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1492938515000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1492938515000},{"_id":"themes/next/_config.yml","hash":"6dd305d145e3e3141d588175587bb8cbc2a8cfd7","modified":1494162999000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1492938515000},{"_id":"themes/next/bower.json","hash":"be0a430362cb73a7e3cf9ecf51a67edf8214b637","modified":1492938515000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1492938515000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1492938515000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1492938515000},{"_id":"themes/next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1492938515000},{"_id":"source/_posts/compile-tensorflow-on-raspberry2or3.md","hash":"dad708ad37d7ab8a6493680bc8ac441b77205b28","modified":1492954948000},{"_id":"source/_posts/http-server-implement-using-niosocket.md","hash":"1f775f82f6830e8af4142433f3767ede2ec7cfff","modified":1492954962000},{"_id":"source/_posts/learing-svm.md","hash":"88978069f67dbb91b5ac89119d5e83086c7e63ec","modified":1492954969000},{"_id":"source/_posts/talking-about-nlp-problems.md","hash":"31de9cd412ab9af86b24616f711678de929cefaa","modified":1492954980000},{"_id":"source/_posts/thinking-about-cnn.md","hash":"1a858af42e3a3c6fb49db36a1d9cee9f3bc706f9","modified":1492954988000},{"_id":"source/_posts/thinking-about-mybatis-from-jdbc.md","hash":"e2631173689610c4e902be66b0971d2116cafd80","modified":1492955019000},{"_id":"source/_posts/ubuntu14.04-cuda8-caffe-cudnn5.0-GTX1080-GTX750Ti.md","hash":"82c5d3dbfb849fb7648a1ea7de4f4b22c2023b2b","modified":1494126407000},{"_id":"source/_posts/writing-web-using-go.md","hash":"0416c340a65a906759feb97255f48497d28c2594","modified":1492955024000},{"_id":"source/_posts/chinese-unicode-in-python2.x.md","hash":"c82e4c4fcdf1c8cebfd0df693d00b78668933f58","modified":1492954935000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1492953340000},{"_id":"source/_posts/10k-parallel-on-raspberry2.md","hash":"f0ce21aefff4daa372aa40a934acd79bc380dd78","modified":1492954926000},{"_id":"source/links/index.md","hash":"b2382904610152e6f3be6a6d91fc82e015dd9d90","modified":1492959031000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1492955318000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1492938515000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1492938515000},{"_id":"themes/next/.git/index","hash":"24f272f69a1b0336bb429b67600aadf1d4359802","modified":1492953067000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1492938484000},{"_id":"themes/next/.git/packed-refs","hash":"9edbbea1442602078a0e7f15e4948612a5b35449","modified":1492938515000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1492938515000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1492938515000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1492938515000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1492938515000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1492938515000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1492938515000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1492938515000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1492938515000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1492938515000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1492938515000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1492938515000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1492938515000},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1492938515000},{"_id":"themes/next/layout/_layout.swig","hash":"9d1a23a6add6f3d0f88c2d17979956f14aaa37a4","modified":1492938515000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1492938515000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1492938515000},{"_id":"themes/next/layout/page.swig","hash":"4ddaeedf1599d167c4ee166d391e616a7660a4ef","modified":1492938515000},{"_id":"themes/next/layout/archive.swig","hash":"5de4dca06b05d99e4f6bad617a4b8f4f3592fb01","modified":1492938515000},{"_id":"themes/next/layout/category.swig","hash":"fb55a48fe92621578ab2db0c983c609371b3ed0e","modified":1492938515000},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1492938515000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1492938515000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1492938515000},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1492938515000},{"_id":"themes/next/layout/tag.swig","hash":"52c506fa2b46a28ae2df10831c61c51a45b2f6c1","modified":1492938515000},{"_id":"themes/next/layout/schedule.swig","hash":"f93c53f6fd5c712584f6efba6f770c30fa8a3e80","modified":1492938515000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1492938515000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1492938515000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1492938515000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"source/images/yijie.jpg","hash":"62497e73f7cc792fcc6309519579dccc5ddb3761","modified":1489469422000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1492938484000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1492938484000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1492938484000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1492938484000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1492938484000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1492938484000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1492938484000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1492938484000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1492938484000},{"_id":"themes/next/.git/logs/HEAD","hash":"5b4980278d82a5bc6e9697ac7d71e7db48191969","modified":1492938515000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1492938484000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1492938515000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1492938515000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1492938515000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1492938515000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1492938515000},{"_id":"themes/next/layout/_macro/post.swig","hash":"7b2683963693516b21095010911091414f112c03","modified":1492938515000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"1c7d3c975e499b9aa3119d6724b030b7b00fc87e","modified":1492938515000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1492938515000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1492938515000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1492938515000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1492938515000},{"_id":"themes/next/layout/_partials/head.swig","hash":"e080bc593946ae93d967bcc07094abed036877e2","modified":1494161874000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1492938515000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1492938515000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1492938515000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1492938515000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1492938515000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1492938515000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1492938515000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1492938515000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1492938515000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1492938515000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1492938515000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1492938515000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1492938515000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1492938515000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1492938515000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1492938515000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1492938515000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1492938515000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1492938515000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1492938515000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1492938515000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1492938515000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1492938515000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1492938515000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1492938515000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1492938515000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1492938515000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1492938515000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1492938515000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1492938515000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1492938515000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1492938515000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1492938515000},{"_id":"themes/next/.git/refs/heads/master","hash":"a002d09c60941ad6b48bf89aea2ce9ab03c336a1","modified":1492938515000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1492938515000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1492938515000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1492938515000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1492938515000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1492938515000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1492938515000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"2d1075f4cabcb3956b7b84a8e210f5a66f0a5562","modified":1492938515000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1492938515000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"abb92620197a16ed2c0775edf18a0f044a82256e","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"1d0d01aaeb7bcde3671263d736718f8837c20182","modified":1492938515000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1492938515000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1492938515000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"7d2a97c8ad8d63770ab88c173044e2ecccda1b5a","modified":1492938515000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1492938515000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1492938515000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1492938515000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1492938515000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1492938515000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1492938515000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1492938515000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1492938515000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d6a793bcada68d4b6c58392546bc48a482e4a7d3","modified":1492938515000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1492938515000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1492938515000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1492938515000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1492938515000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1492938515000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1492938515000},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1492938515000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1492938515000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1492938515000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1492938515000},{"_id":"themes/next/source/js/src/utils.js","hash":"2041eae5ac81c392067bfbd1bba4399cb37beea1","modified":1492938515000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1492938515000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1492938515000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1492938515000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b614b73ba49ca9136fed7c387ee8df72fe65118f","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1492938515000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1492938515000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1492938515000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1492938515000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1492938515000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1492938515000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1492938515000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1492938515000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1492938515000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1492938515000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1492938515000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1492938515000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1492938515000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1492938515000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1492938515000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1492938515000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1492938515000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1492938515000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1492938515000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1492938515000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1492938515000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1492938515000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1492938515000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"5b4980278d82a5bc6e9697ac7d71e7db48191969","modified":1492938515000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1492938515000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1492938515000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1492938515000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1492938515000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1492938515000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1492938515000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1492938515000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1492938515000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1492938515000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1492938515000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1492938515000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1492938515000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1492938515000},{"_id":"themes/next/.git/objects/pack/pack-984c57d21e53e235e6c251b1ea023f7fa04608b4.idx","hash":"3073690eeed63891750ecd6cc85cc3a344266a80","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1492938515000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1492938515000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"5b4980278d82a5bc6e9697ac7d71e7db48191969","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"c089419916988d0f51d89b225460fe11b631e0a3","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8c0276883398651336853d5ec0e9da267a00dd86","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"bb3be8374c31c372ed0995bd8030d2b920d581de","modified":1492938515000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1492938515000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1492938515000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1492938515000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1492938515000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1492938515000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1492938515000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1492938515000},{"_id":"themes/next/.git/objects/pack/pack-984c57d21e53e235e6c251b1ea023f7fa04608b4.pack","hash":"21888768676dfeacf6999e614c8e7ffa4a659dc5","modified":1492938515000},{"_id":"source/favicon.ico","hash":"e16282b87458f676971b64019c2da9e69f1722ce","modified":1492959645000},{"_id":"public/categories/人工智能/index.html","hash":"eece03377f196ff118628621c20db9eb4eb38cc1","modified":1494307974980},{"_id":"public/categories/Java/index.html","hash":"1354ef38295b2bb13c09f80ef481e31ebd630358","modified":1494307974980},{"_id":"public/categories/科学计算/index.html","hash":"a67e90aa15c9c5dd7ad30714cf3c226d0181301b","modified":1494307974980},{"_id":"public/categories/图像处理/index.html","hash":"f4da15b78128427a41ab152901d2b555ab7d8e58","modified":1494307974980},{"_id":"public/categories/caffe/index.html","hash":"02ff75d107bbd85b21718cb040afb27e20ed3be0","modified":1494307974980},{"_id":"public/categories/Golang/index.html","hash":"4f92b467c20c2586fe6a6de7522be1c18da24fcf","modified":1494307974980},{"_id":"public/categories/Raspberry/index.html","hash":"ce651d8d27755fb1c774530232ff6f276eb06987","modified":1494307974980},{"_id":"public/categories/python/index.html","hash":"d5d71961e25dcb60dbc105884adf290cf00b00b9","modified":1494307974980},{"_id":"public/archives/2016/index.html","hash":"2010d8d464207993546c0261a8233d22dcb6aac6","modified":1494307974979},{"_id":"public/archives/2016/05/index.html","hash":"0bf2e6c321a063731515cf561794118cb30cb1a6","modified":1494307974979},{"_id":"public/archives/2016/06/index.html","hash":"869814bece8c41272282f63179904584ef24d25f","modified":1494307974979},{"_id":"public/archives/2016/08/index.html","hash":"a4ed62dce3c8282a7fef2074f8b64cb876e87a0b","modified":1494307974979},{"_id":"public/archives/2016/09/index.html","hash":"5663880bfb849d1cff12e72fb012bc1b3001620f","modified":1494307974979},{"_id":"public/archives/2016/10/index.html","hash":"46b68e922a381a4a0797ededb9377dc749696649","modified":1494307974979},{"_id":"public/archives/2017/index.html","hash":"cf68f3efdf690b5f5200c291340e15d25cbd621b","modified":1494307974980},{"_id":"public/archives/2017/01/index.html","hash":"6593c98266c715fcaca01e2f18ceb93f55119351","modified":1494307974980},{"_id":"public/archives/2017/03/index.html","hash":"6e84390bb70d953b10253b89328f31df00224611","modified":1494307974980},{"_id":"public/tags/RPi/index.html","hash":"c2697179729e2fafd000789ad5c9add0b9b67fe3","modified":1494307974980},{"_id":"public/tags/TF/index.html","hash":"38818616f60bc2e3d55545e9dd5ab032630950a3","modified":1494307974980},{"_id":"public/tags/java/index.html","hash":"9c35c6ee2bc3e24fe9e3a2b2ae28f0a253100239","modified":1494307974980},{"_id":"public/tags/niosocket/index.html","hash":"f7e7587507bdf4eabdc33478ef0420bf6f5cf503","modified":1494307974980},{"_id":"public/tags/机器学习/index.html","hash":"0d99fa3b48bea264f7299fb5d59abdddd0b326a3","modified":1494307974980},{"_id":"public/tags/NLP/index.html","hash":"40bbef5477f1c095e1a88e1edd572c978bb53f42","modified":1494307974980},{"_id":"public/tags/AI/index.html","hash":"5b51b49b59d8229458c6e267d9058ec59a0ab411","modified":1494307974980},{"_id":"public/tags/CNN/index.html","hash":"6650de79f35e4a7779760bcbea1d17f0db3b639e","modified":1494307974981},{"_id":"public/tags/卷积神经网络/index.html","hash":"8a42a3cb6cac0d381eb38fbfbcb7dea33dcbc6bf","modified":1494307974981},{"_id":"public/tags/caffe/index.html","hash":"a61e13e684008dfc3fc4e047b8d13b8124d6743e","modified":1494307974981},{"_id":"public/tags/jdbc/index.html","hash":"68a359c415a2e68371298d141e7ffe9282a73165","modified":1494307974981},{"_id":"public/tags/mybatis/index.html","hash":"3e8fccd3baf76017e987c3ffc8a322a2b01c99a4","modified":1494307974983},{"_id":"public/tags/go/index.html","hash":"2ca821db2b06e9b4406ee3856cc4a732c85a36d6","modified":1494307974983},{"_id":"public/tags/web/index.html","hash":"2fe15e49865be340f6cdcba52a5e780fed880183","modified":1494307974983},{"_id":"public/tags/后台/index.html","hash":"c9cfc49016b3267d821ab259c441f38fcc1b5acd","modified":1494307974983},{"_id":"public/tags/Raspberry/index.html","hash":"eb9a89214fdf98771743cf9321d693927b262e23","modified":1494307974983},{"_id":"public/tags/闲聊/index.html","hash":"a64a102483033b19677d18499e01ba01b42ff804","modified":1494307974983},{"_id":"public/tags/python/index.html","hash":"1cdc453e22a4e2e9b2c874d1a3383e0b0b14216a","modified":1494307974983},{"_id":"public/tags/unicode/index.html","hash":"10ded4da99f089a92cfcaba9d2b94767e29ba557","modified":1494307974983},{"_id":"public/404.html","hash":"c3e17484995c58f2c03248ba84a17d210a1db6ab","modified":1494394669606},{"_id":"public/archives/index.html","hash":"5503973b7c3eb1296480622b83ebe5cecfccd250","modified":1494307974983},{"_id":"public/index.html","hash":"ae8a970d8ada95c65add90ca18ac9b4972f6c0c4","modified":1494307974983},{"_id":"public/links/index.html","hash":"25b0408a747a730721da22f7f887f1573d0ae4e2","modified":1494307974979},{"_id":"public/10k-parallel-on-raspberry2/index.html","hash":"055c7d490dad64de24f7467e908bce0f850c4980","modified":1494161945142},{"_id":"public/learing-svm/index.html","hash":"cfb555ad08cebe547988e9c764c1188824fa11f6","modified":1494161945142},{"_id":"public/talking-about-nlp-problems/index.html","hash":"38921f64d060ad2cf4c77019eb9945a4226c5393","modified":1494161945142},{"_id":"public/writing-web-using-go/index.html","hash":"3c6ff802474d27f2d4fe9458c6d560e7d3d4d336","modified":1494161945143},{"_id":"public/thinking-about-cnn/index.html","hash":"225d1cca57508923b3c06c2dd2a4cdcd7239c712","modified":1494161945143},{"_id":"public/compile-tensorflow-on-raspberry2or3/index.html","hash":"56c64806b6b629c4674c5bf088ca10483b4ae32c","modified":1494161945143},{"_id":"public/http-server-implement-using-niosocket/index.html","hash":"47c8e68fbf319411b7ac17cf3499d97a97fa3980","modified":1494161945143},{"_id":"public/thinking-about-mybatis-from-jdbc/index.html","hash":"928656e68288e23fb8f79d78989842078bd0cdc4","modified":1494161945143},{"_id":"public/chinese-unicode-in-python2.x/index.html","hash":"e0975ccebec70355bb91f563b7eeca89a926e9aa","modified":1494161945143},{"_id":"public/ubuntu14.04-cuda8-caffe-cudnn5.0-GTX1080-GTX750Ti/index.html","hash":"06b0b5311bf16d407c09e25cb95bc7f940168bf6","modified":1494161945143},{"_id":"public/favicon.ico","hash":"e16282b87458f676971b64019c2da9e69f1722ce","modified":1492959808830},{"_id":"public/images/yijie.jpg","hash":"62497e73f7cc792fcc6309519579dccc5ddb3761","modified":1492959808836},{"_id":"source/_posts/using-github-and-jenkins-deploy-hexo.md","hash":"9a5c9d911dad4ee0dd3d07a16b299f9771b096a4","modified":1494394659000},{"_id":"public/archives/page/2/index.html","hash":"9dcb0b96e28146aeee68d1564fc5eaf0c89d3ba4","modified":1494307974979},{"_id":"public/archives/2017/04/index.html","hash":"5edd846d2514d9f53fe7ef641095d5304e2093b1","modified":1494307974980},{"_id":"public/categories/CI/index.html","hash":"d1adf2ef52a112024d951c126a7ded740b69d018","modified":1494307974980},{"_id":"public/page/2/index.html","hash":"b92f709d26ef038f9c1069e86f9fbee1aa6fedb8","modified":1494307974983},{"_id":"public/tags/jenkins/index.html","hash":"69a6d4db0aba25909b31bf624b796b13a4379187","modified":1494307974983},{"_id":"public/tags/hexo/index.html","hash":"e0befc231b186d4b42ac042c130c1ca935e8498b","modified":1494307974983},{"_id":"public/tags/blog/index.html","hash":"dcf7406029158b75b6919ac9c91c9bd84d2ef466","modified":1494307974983},{"_id":"public/using-github-and-jenkins-deploy-hexo/index.html","hash":"1ea50ad43be17ccea5839817c7ee7db47ac22cd2","modified":1494394669644},{"_id":"source/_posts/ubuntu16.04-hadoop2.8.0.md","hash":"a1e4a0e487c3c1858f2aaf7de6b2851b606b3552","modified":1493910976000},{"_id":"public/baidusitemap.xml","hash":"f010e3066973cd260fa0a6dce2fa116d922b83c5","modified":1494394669626},{"_id":"public/sitemap.xml","hash":"e614d548365fa51fa11b5dd29acbd128540c5d68","modified":1494394669626},{"_id":"public/archives/2017/05/index.html","hash":"a1d607fdecd8b6edb2f0143902e0beefa943f52a","modified":1494307974980},{"_id":"public/tags/hadoop/index.html","hash":"b138539ddbe6b5cd3a0f339496179f949ba0c726","modified":1494307974983},{"_id":"public/categories/distributed/index.html","hash":"f9c6ecf0a7cf400666d41f23ece749f605509bc9","modified":1494307974980},{"_id":"public/tags/distributed/index.html","hash":"b866a2848edd9df6b6f3755f35fb49af8d6cb42f","modified":1494307974983},{"_id":"public/ubuntu16.04-hadoop2.8.0/index.html","hash":"39e993e375efe420b8ec9f6373516ad454e9e191","modified":1494161945143},{"_id":"source/robots.txt","hash":"97c2be5691c986811c48218350953e23954a89ef","modified":1494162094000},{"_id":"public/robots.txt","hash":"97c2be5691c986811c48218350953e23954a89ef","modified":1494162102931},{"_id":"themes/next/_config.yml.bak","hash":"6dd305d145e3e3141d588175587bb8cbc2a8cfd7","modified":1494163008000}],"Category":[{"name":"人工智能","_id":"cj1utjtrc0004uoev6isa8gnz"},{"name":"Java","_id":"cj1utjtrk0009uoevjgslhywj"},{"name":"科学计算","_id":"cj1utjtro000euoevxjnax8g0"},{"name":"图像处理","_id":"cj1utjtru000muoevsmz80yxy"},{"name":"caffe","_id":"cj1utjtrz000ruoev9shareb3"},{"name":"Golang","_id":"cj1utjts1000wuoev8z9tj5q3"},{"name":"Raspberry","_id":"cj1utjts20010uoevglq7fflr"},{"name":"python","_id":"cj1utjts20013uoevujy1db84"},{"name":"CI","_id":"cj22nsvtz000139ev3yub9wa2"},{"name":"distributed","_id":"cj2eoxsio00012cevjng66scq"}],"Data":[],"Page":[{"layout":"false","title":"404","date":"2017-04-21T16:00:00.000Z","_content":"<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>404</title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"找不到网页，找不到家\" homePageUrl=\"https://www.jianyujianyu.com\"></script>\n</body>\n</html>\n","source":"404.html","raw":"layout: false\ntitle: \"404\"\ndate: 2017-04-22 00:00:00\n---\n<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>404</title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"找不到网页，找不到家\" homePageUrl=\"https://www.jianyujianyu.com\"></script>\n</body>\n</html>\n","updated":"2017-05-09T05:42:27.000Z","path":"404.html","_id":"cj1utjtpf0000uoev1tvok0v8","comments":1,"content":"<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n<meta charset=\"UTF-8\">\n<title>404</title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homepagename=\"找不到网页，找不到家\" homepageurl=\"https://www.jianyujianyu.com\"></script>\n</body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"zh-cn\">\n<head>\n<meta charset=\"UTF-8\" />\n<title>404</title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" homePageName=\"找不到网页，找不到家\" homePageUrl=\"https://www.jianyujianyu.com\"></script>\n</body>\n</html>\n"},{"title":"友情链接","date":"2017-04-23T14:44:46.000Z","_content":"\n## 以下是各位大佬：\n\n[我老婆 | 自拍狗](http://yijieyjie.com/)\n\n[集智俱乐部](http://swarma.net)\n\n[智能硬件与互联网创业协会](http://www.ima-vida.com/)\n\n[蜀山客 | 今古渔樵话里，江山水墨图中](http://www.zeakhold.com/)\n\n[alberthao.cc | 撕逼的博客](http://alberthao.cc/)\n\n[StanOz-IO | 主席大大的博客](http://stanoz-io.top/)\n\n[ZhouCD Blog | 世界这么大 我想去看看](http://xn--xhq56mu2c.cn/)\n\n[JackFrost | 一只不断前行的蜗牛](http://www.fuzhufuzhu.com/)\n\n[ChenZiping -> blog | 屌屌的陈子平](http://blog.chenziping.cf/)\n\n[Nicho米糖](http://blog.nichoeit.com/)","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2017-04-23 22:44:46\n---\n\n## 以下是各位大佬：\n\n[我老婆 | 自拍狗](http://yijieyjie.com/)\n\n[集智俱乐部](http://swarma.net)\n\n[智能硬件与互联网创业协会](http://www.ima-vida.com/)\n\n[蜀山客 | 今古渔樵话里，江山水墨图中](http://www.zeakhold.com/)\n\n[alberthao.cc | 撕逼的博客](http://alberthao.cc/)\n\n[StanOz-IO | 主席大大的博客](http://stanoz-io.top/)\n\n[ZhouCD Blog | 世界这么大 我想去看看](http://xn--xhq56mu2c.cn/)\n\n[JackFrost | 一只不断前行的蜗牛](http://www.fuzhufuzhu.com/)\n\n[ChenZiping -> blog | 屌屌的陈子平](http://blog.chenziping.cf/)\n\n[Nicho米糖](http://blog.nichoeit.com/)","updated":"2017-04-23T14:50:31.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"cj1utjtr60002uoeve3b4td51","content":"<h2 id=\"以下是各位大佬：\"><a href=\"#以下是各位大佬：\" class=\"headerlink\" title=\"以下是各位大佬：\"></a>以下是各位大佬：</h2><p><a href=\"http://yijieyjie.com/\" target=\"_blank\" rel=\"external\">我老婆 | 自拍狗</a></p>\n<p><a href=\"http://swarma.net\" target=\"_blank\" rel=\"external\">集智俱乐部</a></p>\n<p><a href=\"http://www.ima-vida.com/\" target=\"_blank\" rel=\"external\">智能硬件与互联网创业协会</a></p>\n<p><a href=\"http://www.zeakhold.com/\" target=\"_blank\" rel=\"external\">蜀山客 | 今古渔樵话里，江山水墨图中</a></p>\n<p><a href=\"http://alberthao.cc/\" target=\"_blank\" rel=\"external\">alberthao.cc | 撕逼的博客</a></p>\n<p><a href=\"http://stanoz-io.top/\" target=\"_blank\" rel=\"external\">StanOz-IO | 主席大大的博客</a></p>\n<p><a href=\"http://xn--xhq56mu2c.cn/\" target=\"_blank\" rel=\"external\">ZhouCD Blog | 世界这么大 我想去看看</a></p>\n<p><a href=\"http://www.fuzhufuzhu.com/\" target=\"_blank\" rel=\"external\">JackFrost | 一只不断前行的蜗牛</a></p>\n<p><a href=\"http://blog.chenziping.cf/\" target=\"_blank\" rel=\"external\">ChenZiping -&gt; blog | 屌屌的陈子平</a></p>\n<p><a href=\"http://blog.nichoeit.com/\" target=\"_blank\" rel=\"external\">Nicho米糖</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"以下是各位大佬：\"><a href=\"#以下是各位大佬：\" class=\"headerlink\" title=\"以下是各位大佬：\"></a>以下是各位大佬：</h2><p><a href=\"http://yijieyjie.com/\">我老婆 | 自拍狗</a></p>\n<p><a href=\"http://swarma.net\">集智俱乐部</a></p>\n<p><a href=\"http://www.ima-vida.com/\">智能硬件与互联网创业协会</a></p>\n<p><a href=\"http://www.zeakhold.com/\">蜀山客 | 今古渔樵话里，江山水墨图中</a></p>\n<p><a href=\"http://alberthao.cc/\">alberthao.cc | 撕逼的博客</a></p>\n<p><a href=\"http://stanoz-io.top/\">StanOz-IO | 主席大大的博客</a></p>\n<p><a href=\"http://xn--xhq56mu2c.cn/\">ZhouCD Blog | 世界这么大 我想去看看</a></p>\n<p><a href=\"http://www.fuzhufuzhu.com/\">JackFrost | 一只不断前行的蜗牛</a></p>\n<p><a href=\"http://blog.chenziping.cf/\">ChenZiping -&gt; blog | 屌屌的陈子平</a></p>\n<p><a href=\"http://blog.nichoeit.com/\">Nicho米糖</a></p>\n"}],"Post":[{"title":"在树莓派2或3中编译谷歌深度学习框架TensorFlow","date":"2016-10-14T21:59:00.000Z","_content":"\n\n*积尘多年的树莓派2B一直都是用于WEB打洞（ngrok+Wetty），一天突发奇想的煎鱼我，想结合最近研究的DL给树莓派点任务跑跑。然而，首先我得有一个树莓派的TF环境。*\n\n## 需要做好的准备\n- 树莓派2或3B\n- 一张已经装好Raspbian的SD卡（推荐16G）\n- 树莓派能联网（有的可能需要FQ）\n- 一个外置U盘，用作SWAP（要无驱，不然你就得想怎么装驱动）\n- 很多很多的折腾时间（心理准备哈哈）\n\n<!-- more -->\n\n## 梗概\n本篇文章专门针对运行着Raspbian 8.0 (jessie)的树莓派3B。在树莓派2上应该是可行的，但可能会有一些小问题。（所有操作默认是root用户，权限问题请自行注意。）\n\n按照计划，我们将会安装：\n\n1. 32位的Protobuf\n2. 对树莓派比较友好的Bazel\n3. 用Bazel编译TensorFlow\n\n## 编译\n\n### 安装基本依赖\n更新源：\n\n```\napt-get update\n```\n\nProtobuf的依赖：\n\n```\napt-get install autoconf automake libtool maven\n```\n\nBazel的依赖：\n\n```\napt-get install pkg-config zip g++ zlib1g-dev unzip\n```\n\nTensorFlow的依赖：\n\n```\n# 对于Python 2.7的\napt-get install python-pip python-numpy swig python-dev\npip install wheel\n\n# 对于Python 3.3+的\napt-get install python3-pip python3-numpy swig python3-dev\npip3 install wheel\n```\n\n最后，为了你的文件能整洁点，建议你建一个文件夹来管理这次所用到的所有文件：\n\n```\nmkdir tf\ncd tf\n```\n\n### 编译Protobuf\n克隆Protobuf库：\n\n```\ngit clone https://github.com/google/protobuf.git\n```\n\n然后进入文件夹，编译（这里需要花费一点时间）：\n\n```\ncd protobuf\ngit checkout d5fb408d\n./autogen.sh\n./configure --prefix=/usr\nmake -j 4\nmake install\n```\n\n注：autogen.sh脚本中有一段代码是为了下载google的gmock，若连不上或者网络太慢可以使用一下办法：\n\n```\ncd protobuf\ngit checkout d5fb408d\napt-get install google-gmock\nautoreconf -f -i -Wall,no-obsolete\nrm -rf autom4te.cache config.h.in~\n./configure --prefix=/usr\nmake -j 4\nmake install\n```\n\n编译完成了之后，进入java文件用maven来建立项目：\n\n```\ncd java\nmvn package\n```\n\n注：这次用maven慢也没啥办法了，国内的OSCHINA源好像是不做了\n新注：找到了阿里云的源，速度快多了，在/etc/maven/settings.xml中的mirrors标签中添加：\n\n```\n  <mirror>\n   <id>nexus-aliyun</id>\n   <mirrorOf>central</mirrorOf>\n   <name>Nexus aliyun</name>\n   <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n  </mirror>\n```\n\n当你做完以上这些，你就会发现多了两个新文件：\n\n- /usr/bin/protoc\n- protobuf/java/core/target/protobuf-java-3.0.0-beta2.jar\n\n### 编译Bazel\n首先退出上两级，然后克隆Bazel库：\n\n```\ncd ../..\ngit clone https://github.com/bazelbuild/bazel.git\n```\n\n然后进入bazel文件夹并切换版本：\n\n```\ncd bazel\ngit checkout 0.2.1\n```\n\n将之前提出的生成的两个文件复制进来，注意名字（至于为啥是这样的名字，估计是不想改某些文件）\n\n```\ncp /usr/bin/protoc third_party/protobuf/protoc-linux-arm32.exe\ncp ../protobuf/java/target/protobuf-java-3.0.0-beta-2.jar third_party/protobuf/protobuf-java-3.0.0-beta-1.jar\n```\n\n在编译Bazel之前，我们需要需要为这次编译设置javac的最大堆大小，否则我们会得到OutOfMemoryError错误。因此，我们需要修改一个小文件bazel/scripts/bootstrap/compile.sh：\n\n```\nvim scripts/bootstrap/compile.sh\n```\n\n去到128行，你会看见这样一段代码：\n\n```\nrun \"${JAVAC}\" -classpath \"${classpath}\" -sourcepath \"${sourcepath}\" \\\n      -d \"${output}/classes\" -source \"$JAVA_VERSION\" -target \"$JAVA_VERSION\" \\\n      -encoding UTF-8 \"@${paramfile}\"\n```\n\n在这段代码的最后加上一个参数`-J-Xmx500M`，意思就是设置了Java最大堆大小为500M，修改后如下：\n\n```\nrun \"${JAVAC}\" -classpath \"${classpath}\" -sourcepath \"${sourcepath}\" \\\n      -d \"${output}/classes\" -source \"$JAVA_VERSION\" -target \"$JAVA_VERSION\" \\\n      -encoding UTF-8 \"@${paramfile}\" -J-Xmx500M\n```\n\n然后让我们开始愉快地编译Bazel吧：\n\n```\n./compile.sh      \n```\n\n编译完成后移动可执行文件：\n\n```\nmkdir /usr/local/bin\ncp output/bazel /usr/local/bin/bazel\n```\n\n然后先确认一下Bazel是否已经成功安装了，我们是运行一下，它应该会出现帮助信息的：\n\n```\nbazel\n\nUsage: bazel <command> <options> ...\n\nAvailable commands:\n  analyze-profile     Analyzes build profile data.\n  build               Builds the specified targets.\n  canonicalize-flags  Canonicalizes a list of bazel options.\n  clean               Removes output files and optionally stops the server.\n  dump                Dumps the internal state of the bazel server process.\n  fetch               Fetches external repositories that are prerequisites to the targets.\n  help                Prints help for commands, or the index.\n  info                Displays runtime info about the bazel server.\n  mobile-install      Installs targets to mobile devices.\n  query               Executes a dependency graph query.\n  run                 Runs the specified target.\n  shutdown            Stops the bazel server.\n  test                Builds and runs the specified test targets.\n  version             Prints version information for bazel.\n\nGetting more help:\n  bazel help <command>\n                   Prints help and options for <command>.\n  bazel help startup_options\n                   Options for the JVM hosting bazel.\n  bazel help target-syntax\n                   Explains the syntax for specifying targets.\n  bazel help info-keys\n                   Displays a list of keys used by the info command.\n```    \n\n如果bazel命令没有问题，那我们就可以移动到上一级，继续下一步了：\n\n```\ncd ..\n```\n\n### 安装一个编译需要的SWAP\n              \n想要成功编译Tensorflow，树莓派需要更多的内存空间（原来就只有1G），因此我们需要建立一个SWAP空间来扩展一下运行内存，找一个1G以上的闲置U盘吧。\n\n先插入你的U盘，找一下设备的路径`/dev/XXX`：\n\n```\nblkid\n```\n\n举个例子，我的U盘设备的路径是`/dev/sda1`。找到你的设备的路径后，卸载（推出）它而后格式化它：\n\n```\numount /dev/XXX\nmkswap /dev/XXX\n```\n\n现在我们需要查询那个U盘的SWAP分区的UUID：\n\n```\nblkid\n```\n\n用查询到的UUID修改/etc/fstab文件，这样做才可以加载U盘中的SWAP分区：\n\n```\nvim /etc/fstab\n# 加入下面这行，替换XX文本\nUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX none swap sw,pri=5 0 0\n```\n\n保存文件后，运行一下命令以激活SWAP分区：\n\n```\nswapon -a\n```\n\n注：如果出错了，就试一下修改/etc/fstab，用`/dev/XXX`替换`UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`：\n\n```\n/dev/XXX none swap sw,pri=5 0 0\n```\n\n好了，现在就已经加载了SWAP分区了，不过先别忘记你的`/dev/XXX`，迟点还要在卸载它的时候用上。\n\n### 编译Tensorflow\n终于到了这一步了，克隆tensorflow库然后进入，并执行替换：\n\n```\ngit clone --recurse-submodules https://github.com/tensorflow/tensorflow\ncd tensorflow\ngrep -Rl 'lib64'| xargs sed -i 's/lib64/lib/g'\n```\n\n而后我们需要删除`tensorflow/core/platform/platform.h`中特定的一行：\n\n```\nvim tensorflow/core/platform/platform.h\n```\n\n删除`#define IS_MOBILE_PLATFORM`：\n\n```\n#elif defined(__arm__)\n#define PLATFORM_POSIX\n...\n#define IS_MOBILE_PLATFORM   <----- 删除这一行\n```\n\n以上这样做就是为了让tensorflow认为我们的树莓派是一个手机（TF有手机版本）\n\n然后我们开始配置编译（终于用到之前的Bazel）：\n注：如果是Python3的用户，请填写`/usr/bin/python3`\n\n```\n./configure\n\nPlease specify the location of python. [Default is /usr/bin/python]: /usr/bin/python\nDo you wish to build TensorFlow with Google Cloud Platform support? [y/N] N\nDo you wish to build TensorFlow with GPU support? [y/N] N\n```\n\n然后我们就正式开始编译Tensorflow了，**注意了，这要用很长很长很长很长的时间编译！**（n小时吧）。\n\n```\nbazel build -c opt --copt=\"-mfpu=neon\" --local_resources 1024,1.0,1.0 --verbose_failures tensorflow/tools/pip_package:build_pip_package\n```\n\n注：以上这个编译语句只用了一个核，作者曾试过用4个核，但似乎会有锁。如果你想试试的话（你想怎么样都行，不关我事），可以修改一下参数（四核）：\n\n```\nbazel build -c opt --copt=\"-mfpu=neon\" --local_resources 1024,4.0,1.0 --verbose_failures tensorflow/tools/pip_package:build_pip_package\n```\n\n当你第二天起床醒来看到编译完成了，是时候该用上编译出来的二进制可执行文件来生成一个Python wheel了：\n\n```\nbazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg\n```\n\n然后用pip（3）来安装它：\n\n```\npip install /tmp/tensorflow_pkg/tensorflow-0.9-cp27-none-linux_armv7l.whl\n```\n\n### 清理残局\n是时候该关闭SWAP分区了，如果你已经不需要了：\n\n```\nswapoff /dev/XXX\n```\n\n然后在`/etc/fstab`中删除或注释掉之前你写出来的那一行，然后重启即可。\n\n**嗯，终于完成了。**\n\n\n[原文链接](https://github.com/samjabrahams/tensorflow-on-raspberry-pi/blob/master/GUIDE.md)\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n\n\n\n\n\n\n","source":"_posts/compile-tensorflow-on-raspberry2or3.md","raw":"title: 在树莓派2或3中编译谷歌深度学习框架TensorFlow\ncategories: 人工智能\ntags: [RPi,TF]\ndate: 2016-10-15 05:59:00\n---\n\n\n*积尘多年的树莓派2B一直都是用于WEB打洞（ngrok+Wetty），一天突发奇想的煎鱼我，想结合最近研究的DL给树莓派点任务跑跑。然而，首先我得有一个树莓派的TF环境。*\n\n## 需要做好的准备\n- 树莓派2或3B\n- 一张已经装好Raspbian的SD卡（推荐16G）\n- 树莓派能联网（有的可能需要FQ）\n- 一个外置U盘，用作SWAP（要无驱，不然你就得想怎么装驱动）\n- 很多很多的折腾时间（心理准备哈哈）\n\n<!-- more -->\n\n## 梗概\n本篇文章专门针对运行着Raspbian 8.0 (jessie)的树莓派3B。在树莓派2上应该是可行的，但可能会有一些小问题。（所有操作默认是root用户，权限问题请自行注意。）\n\n按照计划，我们将会安装：\n\n1. 32位的Protobuf\n2. 对树莓派比较友好的Bazel\n3. 用Bazel编译TensorFlow\n\n## 编译\n\n### 安装基本依赖\n更新源：\n\n```\napt-get update\n```\n\nProtobuf的依赖：\n\n```\napt-get install autoconf automake libtool maven\n```\n\nBazel的依赖：\n\n```\napt-get install pkg-config zip g++ zlib1g-dev unzip\n```\n\nTensorFlow的依赖：\n\n```\n# 对于Python 2.7的\napt-get install python-pip python-numpy swig python-dev\npip install wheel\n\n# 对于Python 3.3+的\napt-get install python3-pip python3-numpy swig python3-dev\npip3 install wheel\n```\n\n最后，为了你的文件能整洁点，建议你建一个文件夹来管理这次所用到的所有文件：\n\n```\nmkdir tf\ncd tf\n```\n\n### 编译Protobuf\n克隆Protobuf库：\n\n```\ngit clone https://github.com/google/protobuf.git\n```\n\n然后进入文件夹，编译（这里需要花费一点时间）：\n\n```\ncd protobuf\ngit checkout d5fb408d\n./autogen.sh\n./configure --prefix=/usr\nmake -j 4\nmake install\n```\n\n注：autogen.sh脚本中有一段代码是为了下载google的gmock，若连不上或者网络太慢可以使用一下办法：\n\n```\ncd protobuf\ngit checkout d5fb408d\napt-get install google-gmock\nautoreconf -f -i -Wall,no-obsolete\nrm -rf autom4te.cache config.h.in~\n./configure --prefix=/usr\nmake -j 4\nmake install\n```\n\n编译完成了之后，进入java文件用maven来建立项目：\n\n```\ncd java\nmvn package\n```\n\n注：这次用maven慢也没啥办法了，国内的OSCHINA源好像是不做了\n新注：找到了阿里云的源，速度快多了，在/etc/maven/settings.xml中的mirrors标签中添加：\n\n```\n  <mirror>\n   <id>nexus-aliyun</id>\n   <mirrorOf>central</mirrorOf>\n   <name>Nexus aliyun</name>\n   <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n  </mirror>\n```\n\n当你做完以上这些，你就会发现多了两个新文件：\n\n- /usr/bin/protoc\n- protobuf/java/core/target/protobuf-java-3.0.0-beta2.jar\n\n### 编译Bazel\n首先退出上两级，然后克隆Bazel库：\n\n```\ncd ../..\ngit clone https://github.com/bazelbuild/bazel.git\n```\n\n然后进入bazel文件夹并切换版本：\n\n```\ncd bazel\ngit checkout 0.2.1\n```\n\n将之前提出的生成的两个文件复制进来，注意名字（至于为啥是这样的名字，估计是不想改某些文件）\n\n```\ncp /usr/bin/protoc third_party/protobuf/protoc-linux-arm32.exe\ncp ../protobuf/java/target/protobuf-java-3.0.0-beta-2.jar third_party/protobuf/protobuf-java-3.0.0-beta-1.jar\n```\n\n在编译Bazel之前，我们需要需要为这次编译设置javac的最大堆大小，否则我们会得到OutOfMemoryError错误。因此，我们需要修改一个小文件bazel/scripts/bootstrap/compile.sh：\n\n```\nvim scripts/bootstrap/compile.sh\n```\n\n去到128行，你会看见这样一段代码：\n\n```\nrun \"${JAVAC}\" -classpath \"${classpath}\" -sourcepath \"${sourcepath}\" \\\n      -d \"${output}/classes\" -source \"$JAVA_VERSION\" -target \"$JAVA_VERSION\" \\\n      -encoding UTF-8 \"@${paramfile}\"\n```\n\n在这段代码的最后加上一个参数`-J-Xmx500M`，意思就是设置了Java最大堆大小为500M，修改后如下：\n\n```\nrun \"${JAVAC}\" -classpath \"${classpath}\" -sourcepath \"${sourcepath}\" \\\n      -d \"${output}/classes\" -source \"$JAVA_VERSION\" -target \"$JAVA_VERSION\" \\\n      -encoding UTF-8 \"@${paramfile}\" -J-Xmx500M\n```\n\n然后让我们开始愉快地编译Bazel吧：\n\n```\n./compile.sh      \n```\n\n编译完成后移动可执行文件：\n\n```\nmkdir /usr/local/bin\ncp output/bazel /usr/local/bin/bazel\n```\n\n然后先确认一下Bazel是否已经成功安装了，我们是运行一下，它应该会出现帮助信息的：\n\n```\nbazel\n\nUsage: bazel <command> <options> ...\n\nAvailable commands:\n  analyze-profile     Analyzes build profile data.\n  build               Builds the specified targets.\n  canonicalize-flags  Canonicalizes a list of bazel options.\n  clean               Removes output files and optionally stops the server.\n  dump                Dumps the internal state of the bazel server process.\n  fetch               Fetches external repositories that are prerequisites to the targets.\n  help                Prints help for commands, or the index.\n  info                Displays runtime info about the bazel server.\n  mobile-install      Installs targets to mobile devices.\n  query               Executes a dependency graph query.\n  run                 Runs the specified target.\n  shutdown            Stops the bazel server.\n  test                Builds and runs the specified test targets.\n  version             Prints version information for bazel.\n\nGetting more help:\n  bazel help <command>\n                   Prints help and options for <command>.\n  bazel help startup_options\n                   Options for the JVM hosting bazel.\n  bazel help target-syntax\n                   Explains the syntax for specifying targets.\n  bazel help info-keys\n                   Displays a list of keys used by the info command.\n```    \n\n如果bazel命令没有问题，那我们就可以移动到上一级，继续下一步了：\n\n```\ncd ..\n```\n\n### 安装一个编译需要的SWAP\n              \n想要成功编译Tensorflow，树莓派需要更多的内存空间（原来就只有1G），因此我们需要建立一个SWAP空间来扩展一下运行内存，找一个1G以上的闲置U盘吧。\n\n先插入你的U盘，找一下设备的路径`/dev/XXX`：\n\n```\nblkid\n```\n\n举个例子，我的U盘设备的路径是`/dev/sda1`。找到你的设备的路径后，卸载（推出）它而后格式化它：\n\n```\numount /dev/XXX\nmkswap /dev/XXX\n```\n\n现在我们需要查询那个U盘的SWAP分区的UUID：\n\n```\nblkid\n```\n\n用查询到的UUID修改/etc/fstab文件，这样做才可以加载U盘中的SWAP分区：\n\n```\nvim /etc/fstab\n# 加入下面这行，替换XX文本\nUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX none swap sw,pri=5 0 0\n```\n\n保存文件后，运行一下命令以激活SWAP分区：\n\n```\nswapon -a\n```\n\n注：如果出错了，就试一下修改/etc/fstab，用`/dev/XXX`替换`UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`：\n\n```\n/dev/XXX none swap sw,pri=5 0 0\n```\n\n好了，现在就已经加载了SWAP分区了，不过先别忘记你的`/dev/XXX`，迟点还要在卸载它的时候用上。\n\n### 编译Tensorflow\n终于到了这一步了，克隆tensorflow库然后进入，并执行替换：\n\n```\ngit clone --recurse-submodules https://github.com/tensorflow/tensorflow\ncd tensorflow\ngrep -Rl 'lib64'| xargs sed -i 's/lib64/lib/g'\n```\n\n而后我们需要删除`tensorflow/core/platform/platform.h`中特定的一行：\n\n```\nvim tensorflow/core/platform/platform.h\n```\n\n删除`#define IS_MOBILE_PLATFORM`：\n\n```\n#elif defined(__arm__)\n#define PLATFORM_POSIX\n...\n#define IS_MOBILE_PLATFORM   <----- 删除这一行\n```\n\n以上这样做就是为了让tensorflow认为我们的树莓派是一个手机（TF有手机版本）\n\n然后我们开始配置编译（终于用到之前的Bazel）：\n注：如果是Python3的用户，请填写`/usr/bin/python3`\n\n```\n./configure\n\nPlease specify the location of python. [Default is /usr/bin/python]: /usr/bin/python\nDo you wish to build TensorFlow with Google Cloud Platform support? [y/N] N\nDo you wish to build TensorFlow with GPU support? [y/N] N\n```\n\n然后我们就正式开始编译Tensorflow了，**注意了，这要用很长很长很长很长的时间编译！**（n小时吧）。\n\n```\nbazel build -c opt --copt=\"-mfpu=neon\" --local_resources 1024,1.0,1.0 --verbose_failures tensorflow/tools/pip_package:build_pip_package\n```\n\n注：以上这个编译语句只用了一个核，作者曾试过用4个核，但似乎会有锁。如果你想试试的话（你想怎么样都行，不关我事），可以修改一下参数（四核）：\n\n```\nbazel build -c opt --copt=\"-mfpu=neon\" --local_resources 1024,4.0,1.0 --verbose_failures tensorflow/tools/pip_package:build_pip_package\n```\n\n当你第二天起床醒来看到编译完成了，是时候该用上编译出来的二进制可执行文件来生成一个Python wheel了：\n\n```\nbazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg\n```\n\n然后用pip（3）来安装它：\n\n```\npip install /tmp/tensorflow_pkg/tensorflow-0.9-cp27-none-linux_armv7l.whl\n```\n\n### 清理残局\n是时候该关闭SWAP分区了，如果你已经不需要了：\n\n```\nswapoff /dev/XXX\n```\n\n然后在`/etc/fstab`中删除或注释掉之前你写出来的那一行，然后重启即可。\n\n**嗯，终于完成了。**\n\n\n[原文链接](https://github.com/samjabrahams/tensorflow-on-raspberry-pi/blob/master/GUIDE.md)\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n\n\n\n\n\n\n","slug":"compile-tensorflow-on-raspberry2or3","published":1,"updated":"2017-04-23T13:42:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtqz0001uoevjhelys3q","content":"<p><em>积尘多年的树莓派2B一直都是用于WEB打洞（ngrok+Wetty），一天突发奇想的煎鱼我，想结合最近研究的DL给树莓派点任务跑跑。然而，首先我得有一个树莓派的TF环境。</em></p>\n<h2 id=\"需要做好的准备\"><a href=\"#需要做好的准备\" class=\"headerlink\" title=\"需要做好的准备\"></a>需要做好的准备</h2><ul>\n<li>树莓派2或3B</li>\n<li>一张已经装好Raspbian的SD卡（推荐16G）</li>\n<li>树莓派能联网（有的可能需要FQ）</li>\n<li>一个外置U盘，用作SWAP（要无驱，不然你就得想怎么装驱动）</li>\n<li>很多很多的折腾时间（心理准备哈哈）</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"梗概\"><a href=\"#梗概\" class=\"headerlink\" title=\"梗概\"></a>梗概</h2><p>本篇文章专门针对运行着Raspbian 8.0 (jessie)的树莓派3B。在树莓派2上应该是可行的，但可能会有一些小问题。（所有操作默认是root用户，权限问题请自行注意。）</p>\n<p>按照计划，我们将会安装：</p>\n<ol>\n<li>32位的Protobuf</li>\n<li>对树莓派比较友好的Bazel</li>\n<li>用Bazel编译TensorFlow</li>\n</ol>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><h3 id=\"安装基本依赖\"><a href=\"#安装基本依赖\" class=\"headerlink\" title=\"安装基本依赖\"></a>安装基本依赖</h3><p>更新源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get update</div></pre></td></tr></table></figure>\n<p>Protobuf的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install autoconf automake libtool maven</div></pre></td></tr></table></figure>\n<p>Bazel的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install pkg-config zip g++ zlib1g-dev unzip</div></pre></td></tr></table></figure>\n<p>TensorFlow的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 对于Python 2.7的</div><div class=\"line\">apt-get install python-pip python-numpy swig python-dev</div><div class=\"line\">pip install wheel</div><div class=\"line\"></div><div class=\"line\"># 对于Python 3.3+的</div><div class=\"line\">apt-get install python3-pip python3-numpy swig python3-dev</div><div class=\"line\">pip3 install wheel</div></pre></td></tr></table></figure>\n<p>最后，为了你的文件能整洁点，建议你建一个文件夹来管理这次所用到的所有文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir tf</div><div class=\"line\">cd tf</div></pre></td></tr></table></figure>\n<h3 id=\"编译Protobuf\"><a href=\"#编译Protobuf\" class=\"headerlink\" title=\"编译Protobuf\"></a>编译Protobuf</h3><p>克隆Protobuf库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/google/protobuf.git</div></pre></td></tr></table></figure>\n<p>然后进入文件夹，编译（这里需要花费一点时间）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd protobuf</div><div class=\"line\">git checkout d5fb408d</div><div class=\"line\">./autogen.sh</div><div class=\"line\">./configure --prefix=/usr</div><div class=\"line\">make -j 4</div><div class=\"line\">make install</div></pre></td></tr></table></figure>\n<p>注：autogen.sh脚本中有一段代码是为了下载google的gmock，若连不上或者网络太慢可以使用一下办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd protobuf</div><div class=\"line\">git checkout d5fb408d</div><div class=\"line\">apt-get install google-gmock</div><div class=\"line\">autoreconf -f -i -Wall,no-obsolete</div><div class=\"line\">rm -rf autom4te.cache config.h.in~</div><div class=\"line\">./configure --prefix=/usr</div><div class=\"line\">make -j 4</div><div class=\"line\">make install</div></pre></td></tr></table></figure>\n<p>编译完成了之后，进入java文件用maven来建立项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd java</div><div class=\"line\">mvn package</div></pre></td></tr></table></figure>\n<p>注：这次用maven慢也没啥办法了，国内的OSCHINA源好像是不做了<br>新注：找到了阿里云的源，速度快多了，在/etc/maven/settings.xml中的mirrors标签中添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;mirror&gt;</div><div class=\"line\"> &lt;id&gt;nexus-aliyun&lt;/id&gt;</div><div class=\"line\"> &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</div><div class=\"line\"> &lt;name&gt;Nexus aliyun&lt;/name&gt;</div><div class=\"line\"> &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</div><div class=\"line\">&lt;/mirror&gt;</div></pre></td></tr></table></figure>\n<p>当你做完以上这些，你就会发现多了两个新文件：</p>\n<ul>\n<li>/usr/bin/protoc</li>\n<li>protobuf/java/core/target/protobuf-java-3.0.0-beta2.jar</li>\n</ul>\n<h3 id=\"编译Bazel\"><a href=\"#编译Bazel\" class=\"headerlink\" title=\"编译Bazel\"></a>编译Bazel</h3><p>首先退出上两级，然后克隆Bazel库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ../..</div><div class=\"line\">git clone https://github.com/bazelbuild/bazel.git</div></pre></td></tr></table></figure>\n<p>然后进入bazel文件夹并切换版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd bazel</div><div class=\"line\">git checkout 0.2.1</div></pre></td></tr></table></figure>\n<p>将之前提出的生成的两个文件复制进来，注意名字（至于为啥是这样的名字，估计是不想改某些文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp /usr/bin/protoc third_party/protobuf/protoc-linux-arm32.exe</div><div class=\"line\">cp ../protobuf/java/target/protobuf-java-3.0.0-beta-2.jar third_party/protobuf/protobuf-java-3.0.0-beta-1.jar</div></pre></td></tr></table></figure>\n<p>在编译Bazel之前，我们需要需要为这次编译设置javac的最大堆大小，否则我们会得到OutOfMemoryError错误。因此，我们需要修改一个小文件bazel/scripts/bootstrap/compile.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim scripts/bootstrap/compile.sh</div></pre></td></tr></table></figure>\n<p>去到128行，你会看见这样一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">run &quot;$&#123;JAVAC&#125;&quot; -classpath &quot;$&#123;classpath&#125;&quot; -sourcepath &quot;$&#123;sourcepath&#125;&quot; \\</div><div class=\"line\">      -d &quot;$&#123;output&#125;/classes&quot; -source &quot;$JAVA_VERSION&quot; -target &quot;$JAVA_VERSION&quot; \\</div><div class=\"line\">      -encoding UTF-8 &quot;@$&#123;paramfile&#125;&quot;</div></pre></td></tr></table></figure>\n<p>在这段代码的最后加上一个参数<code>-J-Xmx500M</code>，意思就是设置了Java最大堆大小为500M，修改后如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">run &quot;$&#123;JAVAC&#125;&quot; -classpath &quot;$&#123;classpath&#125;&quot; -sourcepath &quot;$&#123;sourcepath&#125;&quot; \\</div><div class=\"line\">      -d &quot;$&#123;output&#125;/classes&quot; -source &quot;$JAVA_VERSION&quot; -target &quot;$JAVA_VERSION&quot; \\</div><div class=\"line\">      -encoding UTF-8 &quot;@$&#123;paramfile&#125;&quot; -J-Xmx500M</div></pre></td></tr></table></figure>\n<p>然后让我们开始愉快地编译Bazel吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./compile.sh</div></pre></td></tr></table></figure>\n<p>编译完成后移动可执行文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/local/bin</div><div class=\"line\">cp output/bazel /usr/local/bin/bazel</div></pre></td></tr></table></figure>\n<p>然后先确认一下Bazel是否已经成功安装了，我们是运行一下，它应该会出现帮助信息的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">bazel</div><div class=\"line\"></div><div class=\"line\">Usage: bazel &lt;command&gt; &lt;options&gt; ...</div><div class=\"line\"></div><div class=\"line\">Available commands:</div><div class=\"line\">  analyze-profile     Analyzes build profile data.</div><div class=\"line\">  build               Builds the specified targets.</div><div class=\"line\">  canonicalize-flags  Canonicalizes a list of bazel options.</div><div class=\"line\">  clean               Removes output files and optionally stops the server.</div><div class=\"line\">  dump                Dumps the internal state of the bazel server process.</div><div class=\"line\">  fetch               Fetches external repositories that are prerequisites to the targets.</div><div class=\"line\">  help                Prints help for commands, or the index.</div><div class=\"line\">  info                Displays runtime info about the bazel server.</div><div class=\"line\">  mobile-install      Installs targets to mobile devices.</div><div class=\"line\">  query               Executes a dependency graph query.</div><div class=\"line\">  run                 Runs the specified target.</div><div class=\"line\">  shutdown            Stops the bazel server.</div><div class=\"line\">  test                Builds and runs the specified test targets.</div><div class=\"line\">  version             Prints version information for bazel.</div><div class=\"line\"></div><div class=\"line\">Getting more help:</div><div class=\"line\">  bazel help &lt;command&gt;</div><div class=\"line\">                   Prints help and options for &lt;command&gt;.</div><div class=\"line\">  bazel help startup_options</div><div class=\"line\">                   Options for the JVM hosting bazel.</div><div class=\"line\">  bazel help target-syntax</div><div class=\"line\">                   Explains the syntax for specifying targets.</div><div class=\"line\">  bazel help info-keys</div><div class=\"line\">                   Displays a list of keys used by the info command.</div><div class=\"line\">```    </div><div class=\"line\"></div><div class=\"line\">如果bazel命令没有问题，那我们就可以移动到上一级，继续下一步了：</div></pre></td></tr></table></figure>\n<p>cd ..<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 安装一个编译需要的SWAP</div><div class=\"line\">              </div><div class=\"line\">想要成功编译Tensorflow，树莓派需要更多的内存空间（原来就只有1G），因此我们需要建立一个SWAP空间来扩展一下运行内存，找一个1G以上的闲置U盘吧。</div><div class=\"line\"></div><div class=\"line\">先插入你的U盘，找一下设备的路径`/dev/XXX`：</div></pre></td></tr></table></figure></p>\n<p>blkid<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">举个例子，我的U盘设备的路径是`/dev/sda1`。找到你的设备的路径后，卸载（推出）它而后格式化它：</div></pre></td></tr></table></figure></p>\n<p>umount /dev/XXX<br>mkswap /dev/XXX<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">现在我们需要查询那个U盘的SWAP分区的UUID：</div></pre></td></tr></table></figure></p>\n<p>blkid<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">用查询到的UUID修改/etc/fstab文件，这样做才可以加载U盘中的SWAP分区：</div></pre></td></tr></table></figure></p>\n<p>vim /etc/fstab</p>\n<h1 id=\"加入下面这行，替换XX文本\"><a href=\"#加入下面这行，替换XX文本\" class=\"headerlink\" title=\"加入下面这行，替换XX文本\"></a>加入下面这行，替换XX文本</h1><p>UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX none swap sw,pri=5 0 0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">保存文件后，运行一下命令以激活SWAP分区：</div></pre></td></tr></table></figure></p>\n<p>swapon -a<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">注：如果出错了，就试一下修改/etc/fstab，用`/dev/XXX`替换`UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`：</div></pre></td></tr></table></figure></p>\n<p>/dev/XXX none swap sw,pri=5 0 0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">好了，现在就已经加载了SWAP分区了，不过先别忘记你的`/dev/XXX`，迟点还要在卸载它的时候用上。</div><div class=\"line\"></div><div class=\"line\">### 编译Tensorflow</div><div class=\"line\">终于到了这一步了，克隆tensorflow库然后进入，并执行替换：</div></pre></td></tr></table></figure></p>\n<p>git clone –recurse-submodules <a href=\"https://github.com/tensorflow/tensorflow\" target=\"_blank\" rel=\"external\">https://github.com/tensorflow/tensorflow</a><br>cd tensorflow<br>grep -Rl ‘lib64’| xargs sed -i ‘s/lib64/lib/g’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">而后我们需要删除`tensorflow/core/platform/platform.h`中特定的一行：</div></pre></td></tr></table></figure></p>\n<p>vim tensorflow/core/platform/platform.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">删除`#define IS_MOBILE_PLATFORM`：</div></pre></td></tr></table></figure></p>\n<p>#elif defined(<strong>arm</strong>)</p>\n<p>#define PLATFORM_POSIX<br>…</p>\n<p>#define IS_MOBILE_PLATFORM   &lt;—– 删除这一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">以上这样做就是为了让tensorflow认为我们的树莓派是一个手机（TF有手机版本）</div><div class=\"line\"></div><div class=\"line\">然后我们开始配置编译（终于用到之前的Bazel）：</div><div class=\"line\">注：如果是Python3的用户，请填写`/usr/bin/python3`</div></pre></td></tr></table></figure></p>\n<p>./configure</p>\n<p>Please specify the location of python. [Default is /usr/bin/python]: /usr/bin/python<br>Do you wish to build TensorFlow with Google Cloud Platform support? [y/N] N<br>Do you wish to build TensorFlow with GPU support? [y/N] N<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后我们就正式开始编译Tensorflow了，**注意了，这要用很长很长很长很长的时间编译！**（n小时吧）。</div></pre></td></tr></table></figure></p>\n<p>bazel build -c opt –copt=”-mfpu=neon” –local_resources 1024,1.0,1.0 –verbose_failures tensorflow/tools/pip_package:build_pip_package<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">注：以上这个编译语句只用了一个核，作者曾试过用4个核，但似乎会有锁。如果你想试试的话（你想怎么样都行，不关我事），可以修改一下参数（四核）：</div></pre></td></tr></table></figure></p>\n<p>bazel build -c opt –copt=”-mfpu=neon” –local_resources 1024,4.0,1.0 –verbose_failures tensorflow/tools/pip_package:build_pip_package<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">当你第二天起床醒来看到编译完成了，是时候该用上编译出来的二进制可执行文件来生成一个Python wheel了：</div></pre></td></tr></table></figure></p>\n<p>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后用pip（3）来安装它：</div></pre></td></tr></table></figure></p>\n<p>pip install /tmp/tensorflow_pkg/tensorflow-0.9-cp27-none-linux_armv7l.whl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 清理残局</div><div class=\"line\">是时候该关闭SWAP分区了，如果你已经不需要了：</div></pre></td></tr></table></figure></p>\n<p>swapoff /dev/XXX<br>```</p>\n<p>然后在<code>/etc/fstab</code>中删除或注释掉之前你写出来的那一行，然后重启即可。</p>\n<p><strong>嗯，终于完成了。</strong></p>\n<p><a href=\"https://github.com/samjabrahams/tensorflow-on-raspberry-pi/blob/master/GUIDE.md\" target=\"_blank\" rel=\"external\">原文链接</a><br>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><em>积尘多年的树莓派2B一直都是用于WEB打洞（ngrok+Wetty），一天突发奇想的煎鱼我，想结合最近研究的DL给树莓派点任务跑跑。然而，首先我得有一个树莓派的TF环境。</em></p>\n<h2 id=\"需要做好的准备\"><a href=\"#需要做好的准备\" class=\"headerlink\" title=\"需要做好的准备\"></a>需要做好的准备</h2><ul>\n<li>树莓派2或3B</li>\n<li>一张已经装好Raspbian的SD卡（推荐16G）</li>\n<li>树莓派能联网（有的可能需要FQ）</li>\n<li>一个外置U盘，用作SWAP（要无驱，不然你就得想怎么装驱动）</li>\n<li>很多很多的折腾时间（心理准备哈哈）</li>\n</ul>","more":"<h2 id=\"梗概\"><a href=\"#梗概\" class=\"headerlink\" title=\"梗概\"></a>梗概</h2><p>本篇文章专门针对运行着Raspbian 8.0 (jessie)的树莓派3B。在树莓派2上应该是可行的，但可能会有一些小问题。（所有操作默认是root用户，权限问题请自行注意。）</p>\n<p>按照计划，我们将会安装：</p>\n<ol>\n<li>32位的Protobuf</li>\n<li>对树莓派比较友好的Bazel</li>\n<li>用Bazel编译TensorFlow</li>\n</ol>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><h3 id=\"安装基本依赖\"><a href=\"#安装基本依赖\" class=\"headerlink\" title=\"安装基本依赖\"></a>安装基本依赖</h3><p>更新源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get update</div></pre></td></tr></table></figure>\n<p>Protobuf的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install autoconf automake libtool maven</div></pre></td></tr></table></figure>\n<p>Bazel的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install pkg-config zip g++ zlib1g-dev unzip</div></pre></td></tr></table></figure>\n<p>TensorFlow的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 对于Python 2.7的</div><div class=\"line\">apt-get install python-pip python-numpy swig python-dev</div><div class=\"line\">pip install wheel</div><div class=\"line\"></div><div class=\"line\"># 对于Python 3.3+的</div><div class=\"line\">apt-get install python3-pip python3-numpy swig python3-dev</div><div class=\"line\">pip3 install wheel</div></pre></td></tr></table></figure>\n<p>最后，为了你的文件能整洁点，建议你建一个文件夹来管理这次所用到的所有文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir tf</div><div class=\"line\">cd tf</div></pre></td></tr></table></figure>\n<h3 id=\"编译Protobuf\"><a href=\"#编译Protobuf\" class=\"headerlink\" title=\"编译Protobuf\"></a>编译Protobuf</h3><p>克隆Protobuf库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/google/protobuf.git</div></pre></td></tr></table></figure>\n<p>然后进入文件夹，编译（这里需要花费一点时间）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd protobuf</div><div class=\"line\">git checkout d5fb408d</div><div class=\"line\">./autogen.sh</div><div class=\"line\">./configure --prefix=/usr</div><div class=\"line\">make -j 4</div><div class=\"line\">make install</div></pre></td></tr></table></figure>\n<p>注：autogen.sh脚本中有一段代码是为了下载google的gmock，若连不上或者网络太慢可以使用一下办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd protobuf</div><div class=\"line\">git checkout d5fb408d</div><div class=\"line\">apt-get install google-gmock</div><div class=\"line\">autoreconf -f -i -Wall,no-obsolete</div><div class=\"line\">rm -rf autom4te.cache config.h.in~</div><div class=\"line\">./configure --prefix=/usr</div><div class=\"line\">make -j 4</div><div class=\"line\">make install</div></pre></td></tr></table></figure>\n<p>编译完成了之后，进入java文件用maven来建立项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd java</div><div class=\"line\">mvn package</div></pre></td></tr></table></figure>\n<p>注：这次用maven慢也没啥办法了，国内的OSCHINA源好像是不做了<br>新注：找到了阿里云的源，速度快多了，在/etc/maven/settings.xml中的mirrors标签中添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;mirror&gt;</div><div class=\"line\"> &lt;id&gt;nexus-aliyun&lt;/id&gt;</div><div class=\"line\"> &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</div><div class=\"line\"> &lt;name&gt;Nexus aliyun&lt;/name&gt;</div><div class=\"line\"> &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</div><div class=\"line\">&lt;/mirror&gt;</div></pre></td></tr></table></figure>\n<p>当你做完以上这些，你就会发现多了两个新文件：</p>\n<ul>\n<li>/usr/bin/protoc</li>\n<li>protobuf/java/core/target/protobuf-java-3.0.0-beta2.jar</li>\n</ul>\n<h3 id=\"编译Bazel\"><a href=\"#编译Bazel\" class=\"headerlink\" title=\"编译Bazel\"></a>编译Bazel</h3><p>首先退出上两级，然后克隆Bazel库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ../..</div><div class=\"line\">git clone https://github.com/bazelbuild/bazel.git</div></pre></td></tr></table></figure>\n<p>然后进入bazel文件夹并切换版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd bazel</div><div class=\"line\">git checkout 0.2.1</div></pre></td></tr></table></figure>\n<p>将之前提出的生成的两个文件复制进来，注意名字（至于为啥是这样的名字，估计是不想改某些文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp /usr/bin/protoc third_party/protobuf/protoc-linux-arm32.exe</div><div class=\"line\">cp ../protobuf/java/target/protobuf-java-3.0.0-beta-2.jar third_party/protobuf/protobuf-java-3.0.0-beta-1.jar</div></pre></td></tr></table></figure>\n<p>在编译Bazel之前，我们需要需要为这次编译设置javac的最大堆大小，否则我们会得到OutOfMemoryError错误。因此，我们需要修改一个小文件bazel/scripts/bootstrap/compile.sh：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim scripts/bootstrap/compile.sh</div></pre></td></tr></table></figure>\n<p>去到128行，你会看见这样一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">run &quot;$&#123;JAVAC&#125;&quot; -classpath &quot;$&#123;classpath&#125;&quot; -sourcepath &quot;$&#123;sourcepath&#125;&quot; \\</div><div class=\"line\">      -d &quot;$&#123;output&#125;/classes&quot; -source &quot;$JAVA_VERSION&quot; -target &quot;$JAVA_VERSION&quot; \\</div><div class=\"line\">      -encoding UTF-8 &quot;@$&#123;paramfile&#125;&quot;</div></pre></td></tr></table></figure>\n<p>在这段代码的最后加上一个参数<code>-J-Xmx500M</code>，意思就是设置了Java最大堆大小为500M，修改后如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">run &quot;$&#123;JAVAC&#125;&quot; -classpath &quot;$&#123;classpath&#125;&quot; -sourcepath &quot;$&#123;sourcepath&#125;&quot; \\</div><div class=\"line\">      -d &quot;$&#123;output&#125;/classes&quot; -source &quot;$JAVA_VERSION&quot; -target &quot;$JAVA_VERSION&quot; \\</div><div class=\"line\">      -encoding UTF-8 &quot;@$&#123;paramfile&#125;&quot; -J-Xmx500M</div></pre></td></tr></table></figure>\n<p>然后让我们开始愉快地编译Bazel吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./compile.sh</div></pre></td></tr></table></figure>\n<p>编译完成后移动可执行文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /usr/local/bin</div><div class=\"line\">cp output/bazel /usr/local/bin/bazel</div></pre></td></tr></table></figure>\n<p>然后先确认一下Bazel是否已经成功安装了，我们是运行一下，它应该会出现帮助信息的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">bazel</div><div class=\"line\"></div><div class=\"line\">Usage: bazel &lt;command&gt; &lt;options&gt; ...</div><div class=\"line\"></div><div class=\"line\">Available commands:</div><div class=\"line\">  analyze-profile     Analyzes build profile data.</div><div class=\"line\">  build               Builds the specified targets.</div><div class=\"line\">  canonicalize-flags  Canonicalizes a list of bazel options.</div><div class=\"line\">  clean               Removes output files and optionally stops the server.</div><div class=\"line\">  dump                Dumps the internal state of the bazel server process.</div><div class=\"line\">  fetch               Fetches external repositories that are prerequisites to the targets.</div><div class=\"line\">  help                Prints help for commands, or the index.</div><div class=\"line\">  info                Displays runtime info about the bazel server.</div><div class=\"line\">  mobile-install      Installs targets to mobile devices.</div><div class=\"line\">  query               Executes a dependency graph query.</div><div class=\"line\">  run                 Runs the specified target.</div><div class=\"line\">  shutdown            Stops the bazel server.</div><div class=\"line\">  test                Builds and runs the specified test targets.</div><div class=\"line\">  version             Prints version information for bazel.</div><div class=\"line\"></div><div class=\"line\">Getting more help:</div><div class=\"line\">  bazel help &lt;command&gt;</div><div class=\"line\">                   Prints help and options for &lt;command&gt;.</div><div class=\"line\">  bazel help startup_options</div><div class=\"line\">                   Options for the JVM hosting bazel.</div><div class=\"line\">  bazel help target-syntax</div><div class=\"line\">                   Explains the syntax for specifying targets.</div><div class=\"line\">  bazel help info-keys</div><div class=\"line\">                   Displays a list of keys used by the info command.</div><div class=\"line\">```    </div><div class=\"line\"></div><div class=\"line\">如果bazel命令没有问题，那我们就可以移动到上一级，继续下一步了：</div></pre></td></tr></table></figure>\n<p>cd ..<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 安装一个编译需要的SWAP</div><div class=\"line\">              </div><div class=\"line\">想要成功编译Tensorflow，树莓派需要更多的内存空间（原来就只有1G），因此我们需要建立一个SWAP空间来扩展一下运行内存，找一个1G以上的闲置U盘吧。</div><div class=\"line\"></div><div class=\"line\">先插入你的U盘，找一下设备的路径`/dev/XXX`：</div></pre></td></tr></table></figure></p>\n<p>blkid<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">举个例子，我的U盘设备的路径是`/dev/sda1`。找到你的设备的路径后，卸载（推出）它而后格式化它：</div></pre></td></tr></table></figure></p>\n<p>umount /dev/XXX<br>mkswap /dev/XXX<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">现在我们需要查询那个U盘的SWAP分区的UUID：</div></pre></td></tr></table></figure></p>\n<p>blkid<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">用查询到的UUID修改/etc/fstab文件，这样做才可以加载U盘中的SWAP分区：</div></pre></td></tr></table></figure></p>\n<p>vim /etc/fstab</p>\n<h1 id=\"加入下面这行，替换XX文本\"><a href=\"#加入下面这行，替换XX文本\" class=\"headerlink\" title=\"加入下面这行，替换XX文本\"></a>加入下面这行，替换XX文本</h1><p>UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX none swap sw,pri=5 0 0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">保存文件后，运行一下命令以激活SWAP分区：</div></pre></td></tr></table></figure></p>\n<p>swapon -a<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">注：如果出错了，就试一下修改/etc/fstab，用`/dev/XXX`替换`UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`：</div></pre></td></tr></table></figure></p>\n<p>/dev/XXX none swap sw,pri=5 0 0<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">好了，现在就已经加载了SWAP分区了，不过先别忘记你的`/dev/XXX`，迟点还要在卸载它的时候用上。</div><div class=\"line\"></div><div class=\"line\">### 编译Tensorflow</div><div class=\"line\">终于到了这一步了，克隆tensorflow库然后进入，并执行替换：</div></pre></td></tr></table></figure></p>\n<p>git clone –recurse-submodules <a href=\"https://github.com/tensorflow/tensorflow\">https://github.com/tensorflow/tensorflow</a><br>cd tensorflow<br>grep -Rl ‘lib64’| xargs sed -i ‘s/lib64/lib/g’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">而后我们需要删除`tensorflow/core/platform/platform.h`中特定的一行：</div></pre></td></tr></table></figure></p>\n<p>vim tensorflow/core/platform/platform.h<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">删除`#define IS_MOBILE_PLATFORM`：</div></pre></td></tr></table></figure></p>\n<p>#elif defined(<strong>arm</strong>)</p>\n<p>#define PLATFORM_POSIX<br>…</p>\n<p>#define IS_MOBILE_PLATFORM   &lt;—– 删除这一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">以上这样做就是为了让tensorflow认为我们的树莓派是一个手机（TF有手机版本）</div><div class=\"line\"></div><div class=\"line\">然后我们开始配置编译（终于用到之前的Bazel）：</div><div class=\"line\">注：如果是Python3的用户，请填写`/usr/bin/python3`</div></pre></td></tr></table></figure></p>\n<p>./configure</p>\n<p>Please specify the location of python. [Default is /usr/bin/python]: /usr/bin/python<br>Do you wish to build TensorFlow with Google Cloud Platform support? [y/N] N<br>Do you wish to build TensorFlow with GPU support? [y/N] N<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后我们就正式开始编译Tensorflow了，**注意了，这要用很长很长很长很长的时间编译！**（n小时吧）。</div></pre></td></tr></table></figure></p>\n<p>bazel build -c opt –copt=”-mfpu=neon” –local_resources 1024,1.0,1.0 –verbose_failures tensorflow/tools/pip_package:build_pip_package<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">注：以上这个编译语句只用了一个核，作者曾试过用4个核，但似乎会有锁。如果你想试试的话（你想怎么样都行，不关我事），可以修改一下参数（四核）：</div></pre></td></tr></table></figure></p>\n<p>bazel build -c opt –copt=”-mfpu=neon” –local_resources 1024,4.0,1.0 –verbose_failures tensorflow/tools/pip_package:build_pip_package<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">当你第二天起床醒来看到编译完成了，是时候该用上编译出来的二进制可执行文件来生成一个Python wheel了：</div></pre></td></tr></table></figure></p>\n<p>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">然后用pip（3）来安装它：</div></pre></td></tr></table></figure></p>\n<p>pip install /tmp/tensorflow_pkg/tensorflow-0.9-cp27-none-linux_armv7l.whl<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 清理残局</div><div class=\"line\">是时候该关闭SWAP分区了，如果你已经不需要了：</div></pre></td></tr></table></figure></p>\n<p>swapoff /dev/XXX<br>```</p>\n<p>然后在<code>/etc/fstab</code>中删除或注释掉之前你写出来的那一行，然后重启即可。</p>\n<p><strong>嗯，终于完成了。</strong></p>\n<p><a href=\"https://github.com/samjabrahams/tensorflow-on-raspberry-pi/blob/master/GUIDE.md\">原文链接</a><br>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"使用NioSocket手动实现HTTP服务器","date":"2017-01-14T11:37:00.000Z","_content":"\n## NioSocket简单复习\n\n### 重要概念\nNioSocket里面的三个重要概念：Buffer、Channel、Selector\n\n- Buffer为要传输的数据\n- Channel为传输数据的通道\n- Selector为通道的分配调度者\n\n<!-- more -->\n\n### 使用步骤\n使用NioSocket实现通信大概如以下步骤：\n\n1. ServerSocketChannel可以通过configureBlocking方法来设置是否采用阻塞模式，设置为false后就可以调用register注册Selector，阻塞模式下不可以用Selector。\n2. 注册后，Selector就可以通过select()来等待请求，通过参数设置等待时长，若传入参数0或者不传入参数，将会采用阻塞模式直到有请求出现。\n3. 接收到请求后Selector调用selectedKeys方法，返回SelectedKey集合。\n4. SelectedKey保存了处理当前请求的Channel和Selector，并提供了不同的操作类型。四种操作属性：SelectedKey.OP_ACCEPT、SelectedKey.OP_CONNECT、SelectedKey.OP_READ、SelectedKey.OP_WRITE。\n5. 通过SelectedKey的isAcceptable、isConnectable、isReadable和isWritable来判断操作类型，并处理相应操作。\n6. 在相应的Handler中提取SelectedKey中的Channel和Buffer信息并执行相应操作。\n\n## 实现HTTP\n### 创建HttpServer类作为程序的主要入口\n\n```java\npublic class HttpServer {\n    public static void main(String[] args) throws Exception{\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress((8080)));\n        serverSocketChannel.configureBlocking(false);\n\n        Selector selector = Selector.open();\n\n        // It must be ACCEPT, or it will throw exception\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true){\n            if (selector.select(3000) == 0){\n                continue;\n            }\n\n            Iterator<SelectionKey> keyIter = selector.selectedKeys().iterator();\n\n            while (keyIter.hasNext()){\n                SelectionKey key = keyIter.next();\n                new Thread(new HttpHandler(key)).run();\n                keyIter.remove();\n            }\n        }\n    }\n}\n```\n\n以上代码的逻辑大致遵循着NioSocket的大概用法，其中serverSocketChannel使用register方法注册到selector仅是OP_ACCEPT，使用其他操作就会操作。但是并不是说不能进行其他操作，而是其他操作稍后实现。\n\n在serverSocketChannel.configureBlocking(false)后，非阻塞模式启动。Server接收到请求后就会将记录了请求信息的key交给HttpHandler做详细处理，处理完就把key从迭代器里面remove掉。可以看到出来，HttpServer对请求里面的信息一概不知，这样才能成为一个出色的管理层，它管理着HttpHandler来处理请求。\n\n既然选用了NioSocket这样的New IO，HttpHandler必然是多线程的实现（否则还有什么意义）。\n\n### 创建HttpHandler来处理请求\n\n对于来自HttpServer的不加工信息，HttpHandler必须要做全套，因此需要HttpHandler自己考虑好有没有中文乱码、Buffer大小是多少等等。HttpHandler大概框架如下即可：\n\n```java\nclass HttpHandler implements Runnable{\n    private int bufferSize = 1024;\n    private String localCharset = \"UTF-8\";\n    private SelectionKey key;\n\n    public HttpHandler(SelectionKey key){\n        this.key = key;\n    }\n\n    public void handleAccept() throws IOException{}\n\n    public void handleRead() throws IOException{}\n\n    @Override\n    public void run() {\n        try {\n            if(key.isAcceptable()){\n                handleAccept();\n            }\n            if(key.isReadable()){\n                handleRead();\n            }\n        }catch (IOException ex){\n            ex.printStackTrace();\n        }\n    }\n}\n```\n\n如上框架简单明了，重载run实现多线程，handleAccept和handleRead用于详细地处理相关操作，bufferSize规定Buffer大小，localCharset的设定提前防止中文乱码。\n\n需要注意的是HttpServer里面，我们只注册了OP_ACCEPT这个操作，那么在HttpHandler里面只有isAcceptable()判定为真，那么handleRead()怎么办呢？我们会在handleAccept()注册好的：\n\n```java\n\tpublic void handleAccept() throws IOException{\n        SocketChannel clientChannel =\n        \t\t((ServerSocketChannel)key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(\n        \t\tkey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)\n        \t);\n    }\n```\n\n在handleAccept里面，我们先取得key里面的请求信息，如对应客户端的SocketChannel （SocketChannel需要ServerSocketChannel接受了后才有），接着就可以为SocketChannel注册OP_READ操作了，带上指定大小的Buffer。注册后，key可是isReadable()了，接下来则是在handleRead中对key进行解剖处理：（代码有点长，但大多是控制台输出和对字符串的拼接操作，看官可放心食用。）\n\n```java\n\tpublic void handleRead() throws IOException{\n        SocketChannel sc = (SocketChannel)key.channel();\n        ByteBuffer buffer = (ByteBuffer)key.attachment();\n        buffer.clear();\n\n        if (sc.read(buffer) == -1){\n            sc.close();\n        }else {\n            buffer.flip();\n            String receiveString = Charset.forName(localCharset).newDecoder().decode(buffer).toString();\n\n            String[] requestMessage = receiveString.split(\"\\r\\n\");\n            for (String s: requestMessage){\n                System.out.println(s);\n                if (s.isEmpty()){\n                    break;\n                }\n            }\n\n            String[] firstLine = requestMessage[0].split(\" \");\n            System.out.println();\n            System.out.println(\"Method:\\t\"+ firstLine[0]);\n            System.out.println(\"url:\\t\"+firstLine[1]);\n            System.out.println(\"HTTP Version:\\t\" + firstLine[2]);\n            System.out.println();\n\n            StringBuilder sendString = new StringBuilder();\n            sendString.append(\"HTTP/1.1 200 OK\\r\\n\");\n            sendString.append(\"Content-Type:text/html;Charset=\"+localCharset+\"\\r\\n\");\n            sendString.append(\"\\r\\n\");\n            sendString.append(\"<html><head><title>SHOW</title></head></body>\");\n            sendString.append(\"Received:<br/>\");\n\n            for (String s : requestMessage){\n                sendString.append(s + \"<br/>\");\n            }\n            sendString.append(\"</body></html>\");\n            buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));\n            sc.write(buffer);\n            sc.close();\n        }\n    }\n```\n\nhandleRead开头先获取到对应的SocketChannel和ByteBuffer，就这两个最为关键，SocketChannel负责与客户端的链接和传输数据，而ByteBuffer充当数据运输的载体。\n\n而后则是简单的判断连接状态，若是连接，将相关信息输出到控制台，并拼接出HTTP头的字符串发送至客户端。\n\n效果如图：\n![](http://source.jianyujianyu.com/2017-01-15-14844539625326.jpg)\n![](http://source.jianyujianyu.com/2017-01-15-14844539849717.jpg)\n\n\n若有错误之处请指出，更多地关注[煎鱼](https://www.jianyujianyu.com)。\n\n\n","source":"_posts/http-server-implement-using-niosocket.md","raw":"title: 使用NioSocket手动实现HTTP服务器\ncategories: Java\ntags: [java,niosocket]\ndate: 2017-01-14 19:37:00\n---\n\n## NioSocket简单复习\n\n### 重要概念\nNioSocket里面的三个重要概念：Buffer、Channel、Selector\n\n- Buffer为要传输的数据\n- Channel为传输数据的通道\n- Selector为通道的分配调度者\n\n<!-- more -->\n\n### 使用步骤\n使用NioSocket实现通信大概如以下步骤：\n\n1. ServerSocketChannel可以通过configureBlocking方法来设置是否采用阻塞模式，设置为false后就可以调用register注册Selector，阻塞模式下不可以用Selector。\n2. 注册后，Selector就可以通过select()来等待请求，通过参数设置等待时长，若传入参数0或者不传入参数，将会采用阻塞模式直到有请求出现。\n3. 接收到请求后Selector调用selectedKeys方法，返回SelectedKey集合。\n4. SelectedKey保存了处理当前请求的Channel和Selector，并提供了不同的操作类型。四种操作属性：SelectedKey.OP_ACCEPT、SelectedKey.OP_CONNECT、SelectedKey.OP_READ、SelectedKey.OP_WRITE。\n5. 通过SelectedKey的isAcceptable、isConnectable、isReadable和isWritable来判断操作类型，并处理相应操作。\n6. 在相应的Handler中提取SelectedKey中的Channel和Buffer信息并执行相应操作。\n\n## 实现HTTP\n### 创建HttpServer类作为程序的主要入口\n\n```java\npublic class HttpServer {\n    public static void main(String[] args) throws Exception{\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress((8080)));\n        serverSocketChannel.configureBlocking(false);\n\n        Selector selector = Selector.open();\n\n        // It must be ACCEPT, or it will throw exception\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true){\n            if (selector.select(3000) == 0){\n                continue;\n            }\n\n            Iterator<SelectionKey> keyIter = selector.selectedKeys().iterator();\n\n            while (keyIter.hasNext()){\n                SelectionKey key = keyIter.next();\n                new Thread(new HttpHandler(key)).run();\n                keyIter.remove();\n            }\n        }\n    }\n}\n```\n\n以上代码的逻辑大致遵循着NioSocket的大概用法，其中serverSocketChannel使用register方法注册到selector仅是OP_ACCEPT，使用其他操作就会操作。但是并不是说不能进行其他操作，而是其他操作稍后实现。\n\n在serverSocketChannel.configureBlocking(false)后，非阻塞模式启动。Server接收到请求后就会将记录了请求信息的key交给HttpHandler做详细处理，处理完就把key从迭代器里面remove掉。可以看到出来，HttpServer对请求里面的信息一概不知，这样才能成为一个出色的管理层，它管理着HttpHandler来处理请求。\n\n既然选用了NioSocket这样的New IO，HttpHandler必然是多线程的实现（否则还有什么意义）。\n\n### 创建HttpHandler来处理请求\n\n对于来自HttpServer的不加工信息，HttpHandler必须要做全套，因此需要HttpHandler自己考虑好有没有中文乱码、Buffer大小是多少等等。HttpHandler大概框架如下即可：\n\n```java\nclass HttpHandler implements Runnable{\n    private int bufferSize = 1024;\n    private String localCharset = \"UTF-8\";\n    private SelectionKey key;\n\n    public HttpHandler(SelectionKey key){\n        this.key = key;\n    }\n\n    public void handleAccept() throws IOException{}\n\n    public void handleRead() throws IOException{}\n\n    @Override\n    public void run() {\n        try {\n            if(key.isAcceptable()){\n                handleAccept();\n            }\n            if(key.isReadable()){\n                handleRead();\n            }\n        }catch (IOException ex){\n            ex.printStackTrace();\n        }\n    }\n}\n```\n\n如上框架简单明了，重载run实现多线程，handleAccept和handleRead用于详细地处理相关操作，bufferSize规定Buffer大小，localCharset的设定提前防止中文乱码。\n\n需要注意的是HttpServer里面，我们只注册了OP_ACCEPT这个操作，那么在HttpHandler里面只有isAcceptable()判定为真，那么handleRead()怎么办呢？我们会在handleAccept()注册好的：\n\n```java\n\tpublic void handleAccept() throws IOException{\n        SocketChannel clientChannel =\n        \t\t((ServerSocketChannel)key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(\n        \t\tkey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)\n        \t);\n    }\n```\n\n在handleAccept里面，我们先取得key里面的请求信息，如对应客户端的SocketChannel （SocketChannel需要ServerSocketChannel接受了后才有），接着就可以为SocketChannel注册OP_READ操作了，带上指定大小的Buffer。注册后，key可是isReadable()了，接下来则是在handleRead中对key进行解剖处理：（代码有点长，但大多是控制台输出和对字符串的拼接操作，看官可放心食用。）\n\n```java\n\tpublic void handleRead() throws IOException{\n        SocketChannel sc = (SocketChannel)key.channel();\n        ByteBuffer buffer = (ByteBuffer)key.attachment();\n        buffer.clear();\n\n        if (sc.read(buffer) == -1){\n            sc.close();\n        }else {\n            buffer.flip();\n            String receiveString = Charset.forName(localCharset).newDecoder().decode(buffer).toString();\n\n            String[] requestMessage = receiveString.split(\"\\r\\n\");\n            for (String s: requestMessage){\n                System.out.println(s);\n                if (s.isEmpty()){\n                    break;\n                }\n            }\n\n            String[] firstLine = requestMessage[0].split(\" \");\n            System.out.println();\n            System.out.println(\"Method:\\t\"+ firstLine[0]);\n            System.out.println(\"url:\\t\"+firstLine[1]);\n            System.out.println(\"HTTP Version:\\t\" + firstLine[2]);\n            System.out.println();\n\n            StringBuilder sendString = new StringBuilder();\n            sendString.append(\"HTTP/1.1 200 OK\\r\\n\");\n            sendString.append(\"Content-Type:text/html;Charset=\"+localCharset+\"\\r\\n\");\n            sendString.append(\"\\r\\n\");\n            sendString.append(\"<html><head><title>SHOW</title></head></body>\");\n            sendString.append(\"Received:<br/>\");\n\n            for (String s : requestMessage){\n                sendString.append(s + \"<br/>\");\n            }\n            sendString.append(\"</body></html>\");\n            buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));\n            sc.write(buffer);\n            sc.close();\n        }\n    }\n```\n\nhandleRead开头先获取到对应的SocketChannel和ByteBuffer，就这两个最为关键，SocketChannel负责与客户端的链接和传输数据，而ByteBuffer充当数据运输的载体。\n\n而后则是简单的判断连接状态，若是连接，将相关信息输出到控制台，并拼接出HTTP头的字符串发送至客户端。\n\n效果如图：\n![](http://source.jianyujianyu.com/2017-01-15-14844539625326.jpg)\n![](http://source.jianyujianyu.com/2017-01-15-14844539849717.jpg)\n\n\n若有错误之处请指出，更多地关注[煎鱼](https://www.jianyujianyu.com)。\n\n\n","slug":"http-server-implement-using-niosocket","published":1,"updated":"2017-04-23T13:42:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtr90003uoevzckp7mqj","content":"<h2 id=\"NioSocket简单复习\"><a href=\"#NioSocket简单复习\" class=\"headerlink\" title=\"NioSocket简单复习\"></a>NioSocket简单复习</h2><h3 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h3><p>NioSocket里面的三个重要概念：Buffer、Channel、Selector</p>\n<ul>\n<li>Buffer为要传输的数据</li>\n<li>Channel为传输数据的通道</li>\n<li>Selector为通道的分配调度者</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>使用NioSocket实现通信大概如以下步骤：</p>\n<ol>\n<li>ServerSocketChannel可以通过configureBlocking方法来设置是否采用阻塞模式，设置为false后就可以调用register注册Selector，阻塞模式下不可以用Selector。</li>\n<li>注册后，Selector就可以通过select()来等待请求，通过参数设置等待时长，若传入参数0或者不传入参数，将会采用阻塞模式直到有请求出现。</li>\n<li>接收到请求后Selector调用selectedKeys方法，返回SelectedKey集合。</li>\n<li>SelectedKey保存了处理当前请求的Channel和Selector，并提供了不同的操作类型。四种操作属性：SelectedKey.OP_ACCEPT、SelectedKey.OP_CONNECT、SelectedKey.OP_READ、SelectedKey.OP_WRITE。</li>\n<li>通过SelectedKey的isAcceptable、isConnectable、isReadable和isWritable来判断操作类型，并处理相应操作。</li>\n<li>在相应的Handler中提取SelectedKey中的Channel和Buffer信息并执行相应操作。</li>\n</ol>\n<h2 id=\"实现HTTP\"><a href=\"#实现HTTP\" class=\"headerlink\" title=\"实现HTTP\"></a>实现HTTP</h2><h3 id=\"创建HttpServer类作为程序的主要入口\"><a href=\"#创建HttpServer类作为程序的主要入口\" class=\"headerlink\" title=\"创建HttpServer类作为程序的主要入口\"></a>创建HttpServer类作为程序的主要入口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServer</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</div><div class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class=\"line\">        serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress((<span class=\"number\">8080</span>)));</div><div class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        Selector selector = Selector.open();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// It must be ACCEPT, or it will throw exception</span></div><div class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (selector.select(<span class=\"number\">3000</span>) == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">while</span> (keyIter.hasNext())&#123;</div><div class=\"line\">                SelectionKey key = keyIter.next();</div><div class=\"line\">                <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> HttpHandler(key)).run();</div><div class=\"line\">                keyIter.remove();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码的逻辑大致遵循着NioSocket的大概用法，其中serverSocketChannel使用register方法注册到selector仅是OP_ACCEPT，使用其他操作就会操作。但是并不是说不能进行其他操作，而是其他操作稍后实现。</p>\n<p>在serverSocketChannel.configureBlocking(false)后，非阻塞模式启动。Server接收到请求后就会将记录了请求信息的key交给HttpHandler做详细处理，处理完就把key从迭代器里面remove掉。可以看到出来，HttpServer对请求里面的信息一概不知，这样才能成为一个出色的管理层，它管理着HttpHandler来处理请求。</p>\n<p>既然选用了NioSocket这样的New IO，HttpHandler必然是多线程的实现（否则还有什么意义）。</p>\n<h3 id=\"创建HttpHandler来处理请求\"><a href=\"#创建HttpHandler来处理请求\" class=\"headerlink\" title=\"创建HttpHandler来处理请求\"></a>创建HttpHandler来处理请求</h3><p>对于来自HttpServer的不加工信息，HttpHandler必须要做全套，因此需要HttpHandler自己考虑好有没有中文乱码、Buffer大小是多少等等。HttpHandler大概框架如下即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">1024</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> String localCharset = <span class=\"string\">\"UTF-8\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> SelectionKey key;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HttpHandler</span><span class=\"params\">(SelectionKey key)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAccept</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(key.isAcceptable())&#123;</div><div class=\"line\">                handleAccept();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>(key.isReadable())&#123;</div><div class=\"line\">                handleRead();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException ex)&#123;</div><div class=\"line\">            ex.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上框架简单明了，重载run实现多线程，handleAccept和handleRead用于详细地处理相关操作，bufferSize规定Buffer大小，localCharset的设定提前防止中文乱码。</p>\n<p>需要注意的是HttpServer里面，我们只注册了OP_ACCEPT这个操作，那么在HttpHandler里面只有isAcceptable()判定为真，那么handleRead()怎么办呢？我们会在handleAccept()注册好的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAccept</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</div><div class=\"line\">       SocketChannel clientChannel =</div><div class=\"line\">       \t\t((ServerSocketChannel)key.channel()).accept();</div><div class=\"line\">       clientChannel.configureBlocking(<span class=\"keyword\">false</span>);</div><div class=\"line\">       clientChannel.register(</div><div class=\"line\">       \t\tkey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)</div><div class=\"line\">       \t);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在handleAccept里面，我们先取得key里面的请求信息，如对应客户端的SocketChannel （SocketChannel需要ServerSocketChannel接受了后才有），接着就可以为SocketChannel注册OP_READ操作了，带上指定大小的Buffer。注册后，key可是isReadable()了，接下来则是在handleRead中对key进行解剖处理：（代码有点长，但大多是控制台输出和对字符串的拼接操作，看官可放心食用。）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</div><div class=\"line\">       SocketChannel sc = (SocketChannel)key.channel();</div><div class=\"line\">       ByteBuffer buffer = (ByteBuffer)key.attachment();</div><div class=\"line\">       buffer.clear();</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (sc.read(buffer) == -<span class=\"number\">1</span>)&#123;</div><div class=\"line\">           sc.close();</div><div class=\"line\">       &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           buffer.flip();</div><div class=\"line\">           String receiveString = Charset.forName(localCharset).newDecoder().decode(buffer).toString();</div><div class=\"line\"></div><div class=\"line\">           String[] requestMessage = receiveString.split(<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">           <span class=\"keyword\">for</span> (String s: requestMessage)&#123;</div><div class=\"line\">               System.out.println(s);</div><div class=\"line\">               <span class=\"keyword\">if</span> (s.isEmpty())&#123;</div><div class=\"line\">                   <span class=\"keyword\">break</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           String[] firstLine = requestMessage[<span class=\"number\">0</span>].split(<span class=\"string\">\" \"</span>);</div><div class=\"line\">           System.out.println();</div><div class=\"line\">           System.out.println(<span class=\"string\">\"Method:\\t\"</span>+ firstLine[<span class=\"number\">0</span>]);</div><div class=\"line\">           System.out.println(<span class=\"string\">\"url:\\t\"</span>+firstLine[<span class=\"number\">1</span>]);</div><div class=\"line\">           System.out.println(<span class=\"string\">\"HTTP Version:\\t\"</span> + firstLine[<span class=\"number\">2</span>]);</div><div class=\"line\">           System.out.println();</div><div class=\"line\"></div><div class=\"line\">           StringBuilder sendString = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">           sendString.append(<span class=\"string\">\"HTTP/1.1 200 OK\\r\\n\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"Content-Type:text/html;Charset=\"</span>+localCharset+<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"&lt;html&gt;&lt;head&gt;&lt;title&gt;SHOW&lt;/title&gt;&lt;/head&gt;&lt;/body&gt;\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"Received:&lt;br/&gt;\"</span>);</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">for</span> (String s : requestMessage)&#123;</div><div class=\"line\">               sendString.append(s + <span class=\"string\">\"&lt;br/&gt;\"</span>);</div><div class=\"line\">           &#125;</div><div class=\"line\">           sendString.append(<span class=\"string\">\"&lt;/body&gt;&lt;/html&gt;\"</span>);</div><div class=\"line\">           buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));</div><div class=\"line\">           sc.write(buffer);</div><div class=\"line\">           sc.close();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>handleRead开头先获取到对应的SocketChannel和ByteBuffer，就这两个最为关键，SocketChannel负责与客户端的链接和传输数据，而ByteBuffer充当数据运输的载体。</p>\n<p>而后则是简单的判断连接状态，若是连接，将相关信息输出到控制台，并拼接出HTTP头的字符串发送至客户端。</p>\n<p>效果如图：<br><img src=\"http://source.jianyujianyu.com/2017-01-15-14844539625326.jpg\" alt=\"\"><br><img src=\"http://source.jianyujianyu.com/2017-01-15-14844539849717.jpg\" alt=\"\"></p>\n<p>若有错误之处请指出，更多地关注<a href=\"https://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"NioSocket简单复习\"><a href=\"#NioSocket简单复习\" class=\"headerlink\" title=\"NioSocket简单复习\"></a>NioSocket简单复习</h2><h3 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h3><p>NioSocket里面的三个重要概念：Buffer、Channel、Selector</p>\n<ul>\n<li>Buffer为要传输的数据</li>\n<li>Channel为传输数据的通道</li>\n<li>Selector为通道的分配调度者</li>\n</ul>","more":"<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>使用NioSocket实现通信大概如以下步骤：</p>\n<ol>\n<li>ServerSocketChannel可以通过configureBlocking方法来设置是否采用阻塞模式，设置为false后就可以调用register注册Selector，阻塞模式下不可以用Selector。</li>\n<li>注册后，Selector就可以通过select()来等待请求，通过参数设置等待时长，若传入参数0或者不传入参数，将会采用阻塞模式直到有请求出现。</li>\n<li>接收到请求后Selector调用selectedKeys方法，返回SelectedKey集合。</li>\n<li>SelectedKey保存了处理当前请求的Channel和Selector，并提供了不同的操作类型。四种操作属性：SelectedKey.OP_ACCEPT、SelectedKey.OP_CONNECT、SelectedKey.OP_READ、SelectedKey.OP_WRITE。</li>\n<li>通过SelectedKey的isAcceptable、isConnectable、isReadable和isWritable来判断操作类型，并处理相应操作。</li>\n<li>在相应的Handler中提取SelectedKey中的Channel和Buffer信息并执行相应操作。</li>\n</ol>\n<h2 id=\"实现HTTP\"><a href=\"#实现HTTP\" class=\"headerlink\" title=\"实现HTTP\"></a>实现HTTP</h2><h3 id=\"创建HttpServer类作为程序的主要入口\"><a href=\"#创建HttpServer类作为程序的主要入口\" class=\"headerlink\" title=\"创建HttpServer类作为程序的主要入口\"></a>创建HttpServer类作为程序的主要入口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpServer</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</div><div class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class=\"line\">        serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress((<span class=\"number\">8080</span>)));</div><div class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</div><div class=\"line\"></div><div class=\"line\">        Selector selector = Selector.open();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// It must be ACCEPT, or it will throw exception</span></div><div class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (selector.select(<span class=\"number\">3000</span>) == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">while</span> (keyIter.hasNext())&#123;</div><div class=\"line\">                SelectionKey key = keyIter.next();</div><div class=\"line\">                <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> HttpHandler(key)).run();</div><div class=\"line\">                keyIter.remove();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码的逻辑大致遵循着NioSocket的大概用法，其中serverSocketChannel使用register方法注册到selector仅是OP_ACCEPT，使用其他操作就会操作。但是并不是说不能进行其他操作，而是其他操作稍后实现。</p>\n<p>在serverSocketChannel.configureBlocking(false)后，非阻塞模式启动。Server接收到请求后就会将记录了请求信息的key交给HttpHandler做详细处理，处理完就把key从迭代器里面remove掉。可以看到出来，HttpServer对请求里面的信息一概不知，这样才能成为一个出色的管理层，它管理着HttpHandler来处理请求。</p>\n<p>既然选用了NioSocket这样的New IO，HttpHandler必然是多线程的实现（否则还有什么意义）。</p>\n<h3 id=\"创建HttpHandler来处理请求\"><a href=\"#创建HttpHandler来处理请求\" class=\"headerlink\" title=\"创建HttpHandler来处理请求\"></a>创建HttpHandler来处理请求</h3><p>对于来自HttpServer的不加工信息，HttpHandler必须要做全套，因此需要HttpHandler自己考虑好有没有中文乱码、Buffer大小是多少等等。HttpHandler大概框架如下即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> bufferSize = <span class=\"number\">1024</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> String localCharset = <span class=\"string\">\"UTF-8\"</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> SelectionKey key;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HttpHandler</span><span class=\"params\">(SelectionKey key)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.key = key;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAccept</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(key.isAcceptable())&#123;</div><div class=\"line\">                handleAccept();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>(key.isReadable())&#123;</div><div class=\"line\">                handleRead();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException ex)&#123;</div><div class=\"line\">            ex.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上框架简单明了，重载run实现多线程，handleAccept和handleRead用于详细地处理相关操作，bufferSize规定Buffer大小，localCharset的设定提前防止中文乱码。</p>\n<p>需要注意的是HttpServer里面，我们只注册了OP_ACCEPT这个操作，那么在HttpHandler里面只有isAcceptable()判定为真，那么handleRead()怎么办呢？我们会在handleAccept()注册好的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleAccept</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</div><div class=\"line\">       SocketChannel clientChannel =</div><div class=\"line\">       \t\t((ServerSocketChannel)key.channel()).accept();</div><div class=\"line\">       clientChannel.configureBlocking(<span class=\"keyword\">false</span>);</div><div class=\"line\">       clientChannel.register(</div><div class=\"line\">       \t\tkey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)</div><div class=\"line\">       \t);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>在handleAccept里面，我们先取得key里面的请求信息，如对应客户端的SocketChannel （SocketChannel需要ServerSocketChannel接受了后才有），接着就可以为SocketChannel注册OP_READ操作了，带上指定大小的Buffer。注册后，key可是isReadable()了，接下来则是在handleRead中对key进行解剖处理：（代码有点长，但大多是控制台输出和对字符串的拼接操作，看官可放心食用。）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</div><div class=\"line\">       SocketChannel sc = (SocketChannel)key.channel();</div><div class=\"line\">       ByteBuffer buffer = (ByteBuffer)key.attachment();</div><div class=\"line\">       buffer.clear();</div><div class=\"line\"></div><div class=\"line\">       <span class=\"keyword\">if</span> (sc.read(buffer) == -<span class=\"number\">1</span>)&#123;</div><div class=\"line\">           sc.close();</div><div class=\"line\">       &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           buffer.flip();</div><div class=\"line\">           String receiveString = Charset.forName(localCharset).newDecoder().decode(buffer).toString();</div><div class=\"line\"></div><div class=\"line\">           String[] requestMessage = receiveString.split(<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">           <span class=\"keyword\">for</span> (String s: requestMessage)&#123;</div><div class=\"line\">               System.out.println(s);</div><div class=\"line\">               <span class=\"keyword\">if</span> (s.isEmpty())&#123;</div><div class=\"line\">                   <span class=\"keyword\">break</span>;</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           String[] firstLine = requestMessage[<span class=\"number\">0</span>].split(<span class=\"string\">\" \"</span>);</div><div class=\"line\">           System.out.println();</div><div class=\"line\">           System.out.println(<span class=\"string\">\"Method:\\t\"</span>+ firstLine[<span class=\"number\">0</span>]);</div><div class=\"line\">           System.out.println(<span class=\"string\">\"url:\\t\"</span>+firstLine[<span class=\"number\">1</span>]);</div><div class=\"line\">           System.out.println(<span class=\"string\">\"HTTP Version:\\t\"</span> + firstLine[<span class=\"number\">2</span>]);</div><div class=\"line\">           System.out.println();</div><div class=\"line\"></div><div class=\"line\">           StringBuilder sendString = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">           sendString.append(<span class=\"string\">\"HTTP/1.1 200 OK\\r\\n\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"Content-Type:text/html;Charset=\"</span>+localCharset+<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"\\r\\n\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"&lt;html&gt;&lt;head&gt;&lt;title&gt;SHOW&lt;/title&gt;&lt;/head&gt;&lt;/body&gt;\"</span>);</div><div class=\"line\">           sendString.append(<span class=\"string\">\"Received:&lt;br/&gt;\"</span>);</div><div class=\"line\"></div><div class=\"line\">           <span class=\"keyword\">for</span> (String s : requestMessage)&#123;</div><div class=\"line\">               sendString.append(s + <span class=\"string\">\"&lt;br/&gt;\"</span>);</div><div class=\"line\">           &#125;</div><div class=\"line\">           sendString.append(<span class=\"string\">\"&lt;/body&gt;&lt;/html&gt;\"</span>);</div><div class=\"line\">           buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));</div><div class=\"line\">           sc.write(buffer);</div><div class=\"line\">           sc.close();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>handleRead开头先获取到对应的SocketChannel和ByteBuffer，就这两个最为关键，SocketChannel负责与客户端的链接和传输数据，而ByteBuffer充当数据运输的载体。</p>\n<p>而后则是简单的判断连接状态，若是连接，将相关信息输出到控制台，并拼接出HTTP头的字符串发送至客户端。</p>\n<p>效果如图：<br><img src=\"http://source.jianyujianyu.com/2017-01-15-14844539625326.jpg\" alt=\"\"><br><img src=\"http://source.jianyujianyu.com/2017-01-15-14844539849717.jpg\" alt=\"\"></p>\n<p>若有错误之处请指出，更多地关注<a href=\"https://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"如何理解SVM | 支持向量机之我见","date":"2016-05-14T01:00:14.000Z","_content":"\n**囫囵吞枣看完SVM，个人感觉如果不好好理解一些概念，或说如果知其然而不知其所以然的话，不如不看。因此我想随便写一写，把整个思路简单地整理一遍。：）**\n\n## SVM与神经网络\n\n支持向量机并不是神经网络，这两个完全是两条不一样的路吧。不过详细来说，线性SVM的计算部分就像一个单层的神经网络一样，而非线性SVM就完全和神经网络不一样了（是的没错，现实生活中大多问题是非线性的），详情可以参考[知乎答案](https://www.zhihu.com/question/22290096)。\n\n这两个冤家一直不争上下，最近基于神经网络的深度学习因为AlphaGo等热门时事，促使神经网络的热度达到了空前最高。毕竟，深度学习那样的多层隐含层的结构，犹如一个黑盒子，一个学习能力极强的潘多拉盒子。有人或许就觉得这就是我们真正的神经网络，我们不知道它那数以百千计的神经元干了什么，也不理解为何如此的结构能诞生如此美好的数据 —— 犹如复杂性科学般，处于高层的我们并不能知道底层的”愚群“为何能涌现。两者一比起来，SVM似乎也没有深度学习等那么令人狂热，连Hinton都开玩笑说SVM不过是浅度学习（来自深度学习的调侃）。\n\n不然，个人觉得相对于热衷于隐含层的神经网络，具有深厚的数学理论的SVM更值得让我们研究。SVM背后伟大的数学理论基础可以说是现今人类的伟大数学成就，因此SVM的解释性也非神经网络可比，可以说，它的数学理论让它充满了理性，这样的理性是一个理工科生向往的。就如，你渴望知道食物的来源以确定食物是否有毒，如果有毒是什么毒，这样的毒会在人体内发生了什么反应以致于让你不适 —— 我的理性驱使我这么想，一个来路不明的食物是不能让我轻易接受的。\n\n<!-- more -->\n\n## SVM是什么\n\n简单点讲，SVM就是个分类器，它用于回归的时候称为SVR（Support Vector Regression），SVM和SVR本质上都一样。下图就是SVM分类：\n\n![](http://source.jianyujianyu.com/2016-05-14-14632059577714.jpg)\n（边界上的点就是支持向量，这些点很关键，这也是”支持向量机“命名的由来）\n\n**SVM的目的：寻找到一个超平面使样本分成两类，并且间隔最大。而我们求得的w就代表着我们需要寻找的超平面的系数。**\n\n用数学语言描述：\n![](http://source.jianyujianyu.com/2016-05-14-14632106164393.jpg)\n这就是SVM的基本型。\n\nSVM的基本型在运筹学里面属于二次规划问题，而且是凸二次规划问题（convex quadratic programming）。\n\n## 二次规划\n\n二次规划的问题主要用于求最优化的问题，从SVM的求解公式也很容易看出来，我们的确要求最优解。\n\n简介：\n在限制条件为\n![](http://source.jianyujianyu.com/2016-05-14-14632121860594.png)\n的条件下，找一个n 维的向量 x ，使得\n![](http://source.jianyujianyu.com/2016-05-14-14632122006481.png)\n为最小。\n\n其中，c为n 维的向量，Q为n × n 维的对称矩阵，A为m × n 维的矩阵，b为m 维的向量。\n\n其中，根据优化理论，如果要到达最优的话，就要符合KKT条件（Karush-Kuhn-Tucker）。\n\n## KKT\n\nKKT是在满足一些有规则的条件下，一个非线性规则问题能有最优解的一个充分必要条件。也就是说，只要约束条件按照这个KKT给出的规则列出，然后符合KKT条件的，就可以有最优解。这是一个广义化拉格朗日乘数的成果。\n\n把所有的不等式约束、等式约束和目标函数全部写为一个式子\n`L(a, b, x)= f(x) + a*g(x)+b*h(x)`\n　　\nKKT条件是说最优值必须满足以下条件：\n- L(a, b, x)对x求导为零\n- h(x) = 0\n- a*g(x) = 0\n\n## 对偶问题\n\n将一个原始问题转换为一个对偶问题，懂的人知道对偶问题不过是把原始问题换了一种问法，从另一角度来求问题的解，其本质上是一样的。就好像我不能证明我比百分之五的人丑，但是我能证明我比百分之九十五的人帅，那样就够了。那么，为啥要用对偶问题，直接求原始问题不好吗？参考一下[为什么我们要考虑线性规划的对偶问题？](https://www.zhihu.com/question/26658861/answer/53394624)\n\n而二次规划的对偶问题也是二次规划，性质、解法和原来一样，所以请放心。（只做简要介绍\n最后训练完成时，大部分的训练样本都不需要保留，最终只会保留支持向量。这一点我们从图上也能看得出来，我们要确定的超平面只和支持向量有关不是吗？\n\n![](http://source.jianyujianyu.com/2016-05-14-14632134952575.jpg)\n（你看，只和支持向量有关）\n\n然而，问题又出现了（新解法的出现总是因为新问题的出现），对于SVM的对偶问题，通过二次规划算法来求解的计算规模和训练样本成正比，开销太大。换句话来说，输入数据小的时候还好，不过小数据几乎没啥用，但是数据量大起来又计算量太大，所以就得寻找一种适合数据量大而且计算量小的解法，这个就是SMO。\n\n## SMO\n\nSMO，Sequential Minimal Optimization，针对SVM对偶问题本身的特性研究出的算法，能有效地提高计算的效率。SMO的思想也很简单：固定欲求的参数之外的所有参数，然后求出欲求的参数。\n\n例如，以下是最终求得的分类函数，也就是我们SVM的目标：\n![](http://source.jianyujianyu.com/2016-05-14-14632140318075.jpg)\nSMO算法每次迭代只选出两个分量ai和aj进行调整，其它分量则保持固定不变，在得到解ai和aj之后，再用ai和aj改进其它分量。\n\n如何高效也能通过SMO算法的思想看得出来 —— 固定其他参数后，仅优化两个参数，比起之前优化多个参数的情况，确实高效了。然而，与通常的分解算法比较，它可能需要更多的迭代次数。不过每次迭代的计算量比较小，所以该算法表现出较好的快速收敛性，且不需要存储核矩阵，也没有矩阵运算。说白了，这样的问题用SMO算法更好。\n\n## 核函数\n\n我们的SVM目的其实也简单，就是找一个超平面，引用一张图即可表述这个目的：\n![](http://source.jianyujianyu.com/2016-05-14-14632144374512.jpg)\n\n然而现实任务中，原始样本空间也许并不能存在一个能正确划分出两类样本的超平面，而且这是很经常的事。你说说要是遇到这样的数据，怎么划分好呢：\n\n![](http://source.jianyujianyu.com/2016-05-14-14632143758259.jpg)\n告诉我你的曲线方程吧，傻了吧~\n\n于是引入了一个新的概念：核函数。它可以将样本从原始空间映射到一个更高维的特质空间中，使得样本在这个新的高维空间中可以被线性划分为两类，即在空间内**线性划分**。这个过程可以观看[视频](https://www.youtube.com/watch?v=3liCbRZPrZA)感受感受，由于是youtube所以我截一下图：\n\n这是原始数据和原始空间，明显有红蓝两类：\n![](http://source.jianyujianyu.com/2016-05-14-14632147909478.jpg)\n\n\n通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：\n![](http://source.jianyujianyu.com/2016-05-14-14632148908664.jpg)\n\n而后进行切割：\n![](http://source.jianyujianyu.com/2016-05-14-14632149178576.jpg)\n\n再将分割的超平面映射回去：\n![](http://source.jianyujianyu.com/2016-05-14-14632149709432.jpg)\n\n![](http://source.jianyujianyu.com/2016-05-14-14632149780244.jpg)\n\n大功告成，这些就是核函数的目的。\n\n再进一步，核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。（这里只涉及概念，不涉及数学原理）\n\n## 软间隔\n\n知道了上面的知识后，你不是就觉得SVM分类就应该是这样的：\n![](http://source.jianyujianyu.com/2016-05-14-14632153433430.jpg)\n\n然而这也不一定是这样的，上图给出的是一种完美的情况，多么恰巧地两类分地很开，多么幸运地能有一个超平面能将两个类区分开来！要是这两个类有一部分掺在一起了，那又该怎么分啊：\n![](http://source.jianyujianyu.com/2016-05-14-14632157241594.jpg)\n\n有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上，而且这样的样本越少越好，”站错队“的样本数量要通过实际来权衡。这就得用上”软间隔“，有软间隔必然有硬间隔，应间隔就是最开始的支持向量机，硬间隔支持向量机只能如此”明确“地分类。特意找来了这个数学解释：\n\n![](http://source.jianyujianyu.com/2016-05-14-14632160235765.jpg)\n\n其中一个样本要是”站错队“就要有损失，我们的目的就是：找出总损失值最小并且能大概分类的超平面。而计算一个样本的损失的损失函数也有很多种，例如：hinge损失、指数损失、対率损失等。\n\n\n\n\n只是简单地把思路整理了一遍而已。\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n","source":"_posts/learing-svm.md","raw":"title: 如何理解SVM | 支持向量机之我见\ncategories: 科学计算\ntags: [机器学习]\ndate: 2016-05-14 09:00:14\n---\n\n**囫囵吞枣看完SVM，个人感觉如果不好好理解一些概念，或说如果知其然而不知其所以然的话，不如不看。因此我想随便写一写，把整个思路简单地整理一遍。：）**\n\n## SVM与神经网络\n\n支持向量机并不是神经网络，这两个完全是两条不一样的路吧。不过详细来说，线性SVM的计算部分就像一个单层的神经网络一样，而非线性SVM就完全和神经网络不一样了（是的没错，现实生活中大多问题是非线性的），详情可以参考[知乎答案](https://www.zhihu.com/question/22290096)。\n\n这两个冤家一直不争上下，最近基于神经网络的深度学习因为AlphaGo等热门时事，促使神经网络的热度达到了空前最高。毕竟，深度学习那样的多层隐含层的结构，犹如一个黑盒子，一个学习能力极强的潘多拉盒子。有人或许就觉得这就是我们真正的神经网络，我们不知道它那数以百千计的神经元干了什么，也不理解为何如此的结构能诞生如此美好的数据 —— 犹如复杂性科学般，处于高层的我们并不能知道底层的”愚群“为何能涌现。两者一比起来，SVM似乎也没有深度学习等那么令人狂热，连Hinton都开玩笑说SVM不过是浅度学习（来自深度学习的调侃）。\n\n不然，个人觉得相对于热衷于隐含层的神经网络，具有深厚的数学理论的SVM更值得让我们研究。SVM背后伟大的数学理论基础可以说是现今人类的伟大数学成就，因此SVM的解释性也非神经网络可比，可以说，它的数学理论让它充满了理性，这样的理性是一个理工科生向往的。就如，你渴望知道食物的来源以确定食物是否有毒，如果有毒是什么毒，这样的毒会在人体内发生了什么反应以致于让你不适 —— 我的理性驱使我这么想，一个来路不明的食物是不能让我轻易接受的。\n\n<!-- more -->\n\n## SVM是什么\n\n简单点讲，SVM就是个分类器，它用于回归的时候称为SVR（Support Vector Regression），SVM和SVR本质上都一样。下图就是SVM分类：\n\n![](http://source.jianyujianyu.com/2016-05-14-14632059577714.jpg)\n（边界上的点就是支持向量，这些点很关键，这也是”支持向量机“命名的由来）\n\n**SVM的目的：寻找到一个超平面使样本分成两类，并且间隔最大。而我们求得的w就代表着我们需要寻找的超平面的系数。**\n\n用数学语言描述：\n![](http://source.jianyujianyu.com/2016-05-14-14632106164393.jpg)\n这就是SVM的基本型。\n\nSVM的基本型在运筹学里面属于二次规划问题，而且是凸二次规划问题（convex quadratic programming）。\n\n## 二次规划\n\n二次规划的问题主要用于求最优化的问题，从SVM的求解公式也很容易看出来，我们的确要求最优解。\n\n简介：\n在限制条件为\n![](http://source.jianyujianyu.com/2016-05-14-14632121860594.png)\n的条件下，找一个n 维的向量 x ，使得\n![](http://source.jianyujianyu.com/2016-05-14-14632122006481.png)\n为最小。\n\n其中，c为n 维的向量，Q为n × n 维的对称矩阵，A为m × n 维的矩阵，b为m 维的向量。\n\n其中，根据优化理论，如果要到达最优的话，就要符合KKT条件（Karush-Kuhn-Tucker）。\n\n## KKT\n\nKKT是在满足一些有规则的条件下，一个非线性规则问题能有最优解的一个充分必要条件。也就是说，只要约束条件按照这个KKT给出的规则列出，然后符合KKT条件的，就可以有最优解。这是一个广义化拉格朗日乘数的成果。\n\n把所有的不等式约束、等式约束和目标函数全部写为一个式子\n`L(a, b, x)= f(x) + a*g(x)+b*h(x)`\n　　\nKKT条件是说最优值必须满足以下条件：\n- L(a, b, x)对x求导为零\n- h(x) = 0\n- a*g(x) = 0\n\n## 对偶问题\n\n将一个原始问题转换为一个对偶问题，懂的人知道对偶问题不过是把原始问题换了一种问法，从另一角度来求问题的解，其本质上是一样的。就好像我不能证明我比百分之五的人丑，但是我能证明我比百分之九十五的人帅，那样就够了。那么，为啥要用对偶问题，直接求原始问题不好吗？参考一下[为什么我们要考虑线性规划的对偶问题？](https://www.zhihu.com/question/26658861/answer/53394624)\n\n而二次规划的对偶问题也是二次规划，性质、解法和原来一样，所以请放心。（只做简要介绍\n最后训练完成时，大部分的训练样本都不需要保留，最终只会保留支持向量。这一点我们从图上也能看得出来，我们要确定的超平面只和支持向量有关不是吗？\n\n![](http://source.jianyujianyu.com/2016-05-14-14632134952575.jpg)\n（你看，只和支持向量有关）\n\n然而，问题又出现了（新解法的出现总是因为新问题的出现），对于SVM的对偶问题，通过二次规划算法来求解的计算规模和训练样本成正比，开销太大。换句话来说，输入数据小的时候还好，不过小数据几乎没啥用，但是数据量大起来又计算量太大，所以就得寻找一种适合数据量大而且计算量小的解法，这个就是SMO。\n\n## SMO\n\nSMO，Sequential Minimal Optimization，针对SVM对偶问题本身的特性研究出的算法，能有效地提高计算的效率。SMO的思想也很简单：固定欲求的参数之外的所有参数，然后求出欲求的参数。\n\n例如，以下是最终求得的分类函数，也就是我们SVM的目标：\n![](http://source.jianyujianyu.com/2016-05-14-14632140318075.jpg)\nSMO算法每次迭代只选出两个分量ai和aj进行调整，其它分量则保持固定不变，在得到解ai和aj之后，再用ai和aj改进其它分量。\n\n如何高效也能通过SMO算法的思想看得出来 —— 固定其他参数后，仅优化两个参数，比起之前优化多个参数的情况，确实高效了。然而，与通常的分解算法比较，它可能需要更多的迭代次数。不过每次迭代的计算量比较小，所以该算法表现出较好的快速收敛性，且不需要存储核矩阵，也没有矩阵运算。说白了，这样的问题用SMO算法更好。\n\n## 核函数\n\n我们的SVM目的其实也简单，就是找一个超平面，引用一张图即可表述这个目的：\n![](http://source.jianyujianyu.com/2016-05-14-14632144374512.jpg)\n\n然而现实任务中，原始样本空间也许并不能存在一个能正确划分出两类样本的超平面，而且这是很经常的事。你说说要是遇到这样的数据，怎么划分好呢：\n\n![](http://source.jianyujianyu.com/2016-05-14-14632143758259.jpg)\n告诉我你的曲线方程吧，傻了吧~\n\n于是引入了一个新的概念：核函数。它可以将样本从原始空间映射到一个更高维的特质空间中，使得样本在这个新的高维空间中可以被线性划分为两类，即在空间内**线性划分**。这个过程可以观看[视频](https://www.youtube.com/watch?v=3liCbRZPrZA)感受感受，由于是youtube所以我截一下图：\n\n这是原始数据和原始空间，明显有红蓝两类：\n![](http://source.jianyujianyu.com/2016-05-14-14632147909478.jpg)\n\n\n通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：\n![](http://source.jianyujianyu.com/2016-05-14-14632148908664.jpg)\n\n而后进行切割：\n![](http://source.jianyujianyu.com/2016-05-14-14632149178576.jpg)\n\n再将分割的超平面映射回去：\n![](http://source.jianyujianyu.com/2016-05-14-14632149709432.jpg)\n\n![](http://source.jianyujianyu.com/2016-05-14-14632149780244.jpg)\n\n大功告成，这些就是核函数的目的。\n\n再进一步，核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。（这里只涉及概念，不涉及数学原理）\n\n## 软间隔\n\n知道了上面的知识后，你不是就觉得SVM分类就应该是这样的：\n![](http://source.jianyujianyu.com/2016-05-14-14632153433430.jpg)\n\n然而这也不一定是这样的，上图给出的是一种完美的情况，多么恰巧地两类分地很开，多么幸运地能有一个超平面能将两个类区分开来！要是这两个类有一部分掺在一起了，那又该怎么分啊：\n![](http://source.jianyujianyu.com/2016-05-14-14632157241594.jpg)\n\n有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上，而且这样的样本越少越好，”站错队“的样本数量要通过实际来权衡。这就得用上”软间隔“，有软间隔必然有硬间隔，应间隔就是最开始的支持向量机，硬间隔支持向量机只能如此”明确“地分类。特意找来了这个数学解释：\n\n![](http://source.jianyujianyu.com/2016-05-14-14632160235765.jpg)\n\n其中一个样本要是”站错队“就要有损失，我们的目的就是：找出总损失值最小并且能大概分类的超平面。而计算一个样本的损失的损失函数也有很多种，例如：hinge损失、指数损失、対率损失等。\n\n\n\n\n只是简单地把思路整理了一遍而已。\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n","slug":"learing-svm","published":1,"updated":"2017-04-23T13:42:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtrf0006uoevovenrbk0","content":"<p><strong>囫囵吞枣看完SVM，个人感觉如果不好好理解一些概念，或说如果知其然而不知其所以然的话，不如不看。因此我想随便写一写，把整个思路简单地整理一遍。：）</strong></p>\n<h2 id=\"SVM与神经网络\"><a href=\"#SVM与神经网络\" class=\"headerlink\" title=\"SVM与神经网络\"></a>SVM与神经网络</h2><p>支持向量机并不是神经网络，这两个完全是两条不一样的路吧。不过详细来说，线性SVM的计算部分就像一个单层的神经网络一样，而非线性SVM就完全和神经网络不一样了（是的没错，现实生活中大多问题是非线性的），详情可以参考<a href=\"https://www.zhihu.com/question/22290096\" target=\"_blank\" rel=\"external\">知乎答案</a>。</p>\n<p>这两个冤家一直不争上下，最近基于神经网络的深度学习因为AlphaGo等热门时事，促使神经网络的热度达到了空前最高。毕竟，深度学习那样的多层隐含层的结构，犹如一个黑盒子，一个学习能力极强的潘多拉盒子。有人或许就觉得这就是我们真正的神经网络，我们不知道它那数以百千计的神经元干了什么，也不理解为何如此的结构能诞生如此美好的数据 —— 犹如复杂性科学般，处于高层的我们并不能知道底层的”愚群“为何能涌现。两者一比起来，SVM似乎也没有深度学习等那么令人狂热，连Hinton都开玩笑说SVM不过是浅度学习（来自深度学习的调侃）。</p>\n<p>不然，个人觉得相对于热衷于隐含层的神经网络，具有深厚的数学理论的SVM更值得让我们研究。SVM背后伟大的数学理论基础可以说是现今人类的伟大数学成就，因此SVM的解释性也非神经网络可比，可以说，它的数学理论让它充满了理性，这样的理性是一个理工科生向往的。就如，你渴望知道食物的来源以确定食物是否有毒，如果有毒是什么毒，这样的毒会在人体内发生了什么反应以致于让你不适 —— 我的理性驱使我这么想，一个来路不明的食物是不能让我轻易接受的。</p>\n<a id=\"more\"></a>\n<h2 id=\"SVM是什么\"><a href=\"#SVM是什么\" class=\"headerlink\" title=\"SVM是什么\"></a>SVM是什么</h2><p>简单点讲，SVM就是个分类器，它用于回归的时候称为SVR（Support Vector Regression），SVM和SVR本质上都一样。下图就是SVM分类：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632059577714.jpg\" alt=\"\"><br>（边界上的点就是支持向量，这些点很关键，这也是”支持向量机“命名的由来）</p>\n<p><strong>SVM的目的：寻找到一个超平面使样本分成两类，并且间隔最大。而我们求得的w就代表着我们需要寻找的超平面的系数。</strong></p>\n<p>用数学语言描述：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632106164393.jpg\" alt=\"\"><br>这就是SVM的基本型。</p>\n<p>SVM的基本型在运筹学里面属于二次规划问题，而且是凸二次规划问题（convex quadratic programming）。</p>\n<h2 id=\"二次规划\"><a href=\"#二次规划\" class=\"headerlink\" title=\"二次规划\"></a>二次规划</h2><p>二次规划的问题主要用于求最优化的问题，从SVM的求解公式也很容易看出来，我们的确要求最优解。</p>\n<p>简介：<br>在限制条件为<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632121860594.png\" alt=\"\"><br>的条件下，找一个n 维的向量 x ，使得<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632122006481.png\" alt=\"\"><br>为最小。</p>\n<p>其中，c为n 维的向量，Q为n × n 维的对称矩阵，A为m × n 维的矩阵，b为m 维的向量。</p>\n<p>其中，根据优化理论，如果要到达最优的话，就要符合KKT条件（Karush-Kuhn-Tucker）。</p>\n<h2 id=\"KKT\"><a href=\"#KKT\" class=\"headerlink\" title=\"KKT\"></a>KKT</h2><p>KKT是在满足一些有规则的条件下，一个非线性规则问题能有最优解的一个充分必要条件。也就是说，只要约束条件按照这个KKT给出的规则列出，然后符合KKT条件的，就可以有最优解。这是一个广义化拉格朗日乘数的成果。</p>\n<p>把所有的不等式约束、等式约束和目标函数全部写为一个式子<br><code>L(a, b, x)= f(x) + a*g(x)+b*h(x)</code><br>　　<br>KKT条件是说最优值必须满足以下条件：</p>\n<ul>\n<li>L(a, b, x)对x求导为零</li>\n<li>h(x) = 0</li>\n<li>a*g(x) = 0</li>\n</ul>\n<h2 id=\"对偶问题\"><a href=\"#对偶问题\" class=\"headerlink\" title=\"对偶问题\"></a>对偶问题</h2><p>将一个原始问题转换为一个对偶问题，懂的人知道对偶问题不过是把原始问题换了一种问法，从另一角度来求问题的解，其本质上是一样的。就好像我不能证明我比百分之五的人丑，但是我能证明我比百分之九十五的人帅，那样就够了。那么，为啥要用对偶问题，直接求原始问题不好吗？参考一下<a href=\"https://www.zhihu.com/question/26658861/answer/53394624\" target=\"_blank\" rel=\"external\">为什么我们要考虑线性规划的对偶问题？</a></p>\n<p>而二次规划的对偶问题也是二次规划，性质、解法和原来一样，所以请放心。（只做简要介绍<br>最后训练完成时，大部分的训练样本都不需要保留，最终只会保留支持向量。这一点我们从图上也能看得出来，我们要确定的超平面只和支持向量有关不是吗？</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632134952575.jpg\" alt=\"\"><br>（你看，只和支持向量有关）</p>\n<p>然而，问题又出现了（新解法的出现总是因为新问题的出现），对于SVM的对偶问题，通过二次规划算法来求解的计算规模和训练样本成正比，开销太大。换句话来说，输入数据小的时候还好，不过小数据几乎没啥用，但是数据量大起来又计算量太大，所以就得寻找一种适合数据量大而且计算量小的解法，这个就是SMO。</p>\n<h2 id=\"SMO\"><a href=\"#SMO\" class=\"headerlink\" title=\"SMO\"></a>SMO</h2><p>SMO，Sequential Minimal Optimization，针对SVM对偶问题本身的特性研究出的算法，能有效地提高计算的效率。SMO的思想也很简单：固定欲求的参数之外的所有参数，然后求出欲求的参数。</p>\n<p>例如，以下是最终求得的分类函数，也就是我们SVM的目标：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632140318075.jpg\" alt=\"\"><br>SMO算法每次迭代只选出两个分量ai和aj进行调整，其它分量则保持固定不变，在得到解ai和aj之后，再用ai和aj改进其它分量。</p>\n<p>如何高效也能通过SMO算法的思想看得出来 —— 固定其他参数后，仅优化两个参数，比起之前优化多个参数的情况，确实高效了。然而，与通常的分解算法比较，它可能需要更多的迭代次数。不过每次迭代的计算量比较小，所以该算法表现出较好的快速收敛性，且不需要存储核矩阵，也没有矩阵运算。说白了，这样的问题用SMO算法更好。</p>\n<h2 id=\"核函数\"><a href=\"#核函数\" class=\"headerlink\" title=\"核函数\"></a>核函数</h2><p>我们的SVM目的其实也简单，就是找一个超平面，引用一张图即可表述这个目的：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632144374512.jpg\" alt=\"\"></p>\n<p>然而现实任务中，原始样本空间也许并不能存在一个能正确划分出两类样本的超平面，而且这是很经常的事。你说说要是遇到这样的数据，怎么划分好呢：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632143758259.jpg\" alt=\"\"><br>告诉我你的曲线方程吧，傻了吧~</p>\n<p>于是引入了一个新的概念：核函数。它可以将样本从原始空间映射到一个更高维的特质空间中，使得样本在这个新的高维空间中可以被线性划分为两类，即在空间内<strong>线性划分</strong>。这个过程可以观看<a href=\"https://www.youtube.com/watch?v=3liCbRZPrZA\" target=\"_blank\" rel=\"external\">视频</a>感受感受，由于是youtube所以我截一下图：</p>\n<p>这是原始数据和原始空间，明显有红蓝两类：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632147909478.jpg\" alt=\"\"></p>\n<p>通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632148908664.jpg\" alt=\"\"></p>\n<p>而后进行切割：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632149178576.jpg\" alt=\"\"></p>\n<p>再将分割的超平面映射回去：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632149709432.jpg\" alt=\"\"></p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632149780244.jpg\" alt=\"\"></p>\n<p>大功告成，这些就是核函数的目的。</p>\n<p>再进一步，核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。（这里只涉及概念，不涉及数学原理）</p>\n<h2 id=\"软间隔\"><a href=\"#软间隔\" class=\"headerlink\" title=\"软间隔\"></a>软间隔</h2><p>知道了上面的知识后，你不是就觉得SVM分类就应该是这样的：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632153433430.jpg\" alt=\"\"></p>\n<p>然而这也不一定是这样的，上图给出的是一种完美的情况，多么恰巧地两类分地很开，多么幸运地能有一个超平面能将两个类区分开来！要是这两个类有一部分掺在一起了，那又该怎么分啊：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632157241594.jpg\" alt=\"\"></p>\n<p>有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上，而且这样的样本越少越好，”站错队“的样本数量要通过实际来权衡。这就得用上”软间隔“，有软间隔必然有硬间隔，应间隔就是最开始的支持向量机，硬间隔支持向量机只能如此”明确“地分类。特意找来了这个数学解释：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632160235765.jpg\" alt=\"\"></p>\n<p>其中一个样本要是”站错队“就要有损失，我们的目的就是：找出总损失值最小并且能大概分类的超平面。而计算一个样本的损失的损失函数也有很多种，例如：hinge损失、指数损失、対率损失等。</p>\n<p>只是简单地把思路整理了一遍而已。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><strong>囫囵吞枣看完SVM，个人感觉如果不好好理解一些概念，或说如果知其然而不知其所以然的话，不如不看。因此我想随便写一写，把整个思路简单地整理一遍。：）</strong></p>\n<h2 id=\"SVM与神经网络\"><a href=\"#SVM与神经网络\" class=\"headerlink\" title=\"SVM与神经网络\"></a>SVM与神经网络</h2><p>支持向量机并不是神经网络，这两个完全是两条不一样的路吧。不过详细来说，线性SVM的计算部分就像一个单层的神经网络一样，而非线性SVM就完全和神经网络不一样了（是的没错，现实生活中大多问题是非线性的），详情可以参考<a href=\"https://www.zhihu.com/question/22290096\">知乎答案</a>。</p>\n<p>这两个冤家一直不争上下，最近基于神经网络的深度学习因为AlphaGo等热门时事，促使神经网络的热度达到了空前最高。毕竟，深度学习那样的多层隐含层的结构，犹如一个黑盒子，一个学习能力极强的潘多拉盒子。有人或许就觉得这就是我们真正的神经网络，我们不知道它那数以百千计的神经元干了什么，也不理解为何如此的结构能诞生如此美好的数据 —— 犹如复杂性科学般，处于高层的我们并不能知道底层的”愚群“为何能涌现。两者一比起来，SVM似乎也没有深度学习等那么令人狂热，连Hinton都开玩笑说SVM不过是浅度学习（来自深度学习的调侃）。</p>\n<p>不然，个人觉得相对于热衷于隐含层的神经网络，具有深厚的数学理论的SVM更值得让我们研究。SVM背后伟大的数学理论基础可以说是现今人类的伟大数学成就，因此SVM的解释性也非神经网络可比，可以说，它的数学理论让它充满了理性，这样的理性是一个理工科生向往的。就如，你渴望知道食物的来源以确定食物是否有毒，如果有毒是什么毒，这样的毒会在人体内发生了什么反应以致于让你不适 —— 我的理性驱使我这么想，一个来路不明的食物是不能让我轻易接受的。</p>","more":"<h2 id=\"SVM是什么\"><a href=\"#SVM是什么\" class=\"headerlink\" title=\"SVM是什么\"></a>SVM是什么</h2><p>简单点讲，SVM就是个分类器，它用于回归的时候称为SVR（Support Vector Regression），SVM和SVR本质上都一样。下图就是SVM分类：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632059577714.jpg\" alt=\"\"><br>（边界上的点就是支持向量，这些点很关键，这也是”支持向量机“命名的由来）</p>\n<p><strong>SVM的目的：寻找到一个超平面使样本分成两类，并且间隔最大。而我们求得的w就代表着我们需要寻找的超平面的系数。</strong></p>\n<p>用数学语言描述：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632106164393.jpg\" alt=\"\"><br>这就是SVM的基本型。</p>\n<p>SVM的基本型在运筹学里面属于二次规划问题，而且是凸二次规划问题（convex quadratic programming）。</p>\n<h2 id=\"二次规划\"><a href=\"#二次规划\" class=\"headerlink\" title=\"二次规划\"></a>二次规划</h2><p>二次规划的问题主要用于求最优化的问题，从SVM的求解公式也很容易看出来，我们的确要求最优解。</p>\n<p>简介：<br>在限制条件为<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632121860594.png\" alt=\"\"><br>的条件下，找一个n 维的向量 x ，使得<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632122006481.png\" alt=\"\"><br>为最小。</p>\n<p>其中，c为n 维的向量，Q为n × n 维的对称矩阵，A为m × n 维的矩阵，b为m 维的向量。</p>\n<p>其中，根据优化理论，如果要到达最优的话，就要符合KKT条件（Karush-Kuhn-Tucker）。</p>\n<h2 id=\"KKT\"><a href=\"#KKT\" class=\"headerlink\" title=\"KKT\"></a>KKT</h2><p>KKT是在满足一些有规则的条件下，一个非线性规则问题能有最优解的一个充分必要条件。也就是说，只要约束条件按照这个KKT给出的规则列出，然后符合KKT条件的，就可以有最优解。这是一个广义化拉格朗日乘数的成果。</p>\n<p>把所有的不等式约束、等式约束和目标函数全部写为一个式子<br><code>L(a, b, x)= f(x) + a*g(x)+b*h(x)</code><br>　　<br>KKT条件是说最优值必须满足以下条件：</p>\n<ul>\n<li>L(a, b, x)对x求导为零</li>\n<li>h(x) = 0</li>\n<li>a*g(x) = 0</li>\n</ul>\n<h2 id=\"对偶问题\"><a href=\"#对偶问题\" class=\"headerlink\" title=\"对偶问题\"></a>对偶问题</h2><p>将一个原始问题转换为一个对偶问题，懂的人知道对偶问题不过是把原始问题换了一种问法，从另一角度来求问题的解，其本质上是一样的。就好像我不能证明我比百分之五的人丑，但是我能证明我比百分之九十五的人帅，那样就够了。那么，为啥要用对偶问题，直接求原始问题不好吗？参考一下<a href=\"https://www.zhihu.com/question/26658861/answer/53394624\">为什么我们要考虑线性规划的对偶问题？</a></p>\n<p>而二次规划的对偶问题也是二次规划，性质、解法和原来一样，所以请放心。（只做简要介绍<br>最后训练完成时，大部分的训练样本都不需要保留，最终只会保留支持向量。这一点我们从图上也能看得出来，我们要确定的超平面只和支持向量有关不是吗？</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632134952575.jpg\" alt=\"\"><br>（你看，只和支持向量有关）</p>\n<p>然而，问题又出现了（新解法的出现总是因为新问题的出现），对于SVM的对偶问题，通过二次规划算法来求解的计算规模和训练样本成正比，开销太大。换句话来说，输入数据小的时候还好，不过小数据几乎没啥用，但是数据量大起来又计算量太大，所以就得寻找一种适合数据量大而且计算量小的解法，这个就是SMO。</p>\n<h2 id=\"SMO\"><a href=\"#SMO\" class=\"headerlink\" title=\"SMO\"></a>SMO</h2><p>SMO，Sequential Minimal Optimization，针对SVM对偶问题本身的特性研究出的算法，能有效地提高计算的效率。SMO的思想也很简单：固定欲求的参数之外的所有参数，然后求出欲求的参数。</p>\n<p>例如，以下是最终求得的分类函数，也就是我们SVM的目标：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632140318075.jpg\" alt=\"\"><br>SMO算法每次迭代只选出两个分量ai和aj进行调整，其它分量则保持固定不变，在得到解ai和aj之后，再用ai和aj改进其它分量。</p>\n<p>如何高效也能通过SMO算法的思想看得出来 —— 固定其他参数后，仅优化两个参数，比起之前优化多个参数的情况，确实高效了。然而，与通常的分解算法比较，它可能需要更多的迭代次数。不过每次迭代的计算量比较小，所以该算法表现出较好的快速收敛性，且不需要存储核矩阵，也没有矩阵运算。说白了，这样的问题用SMO算法更好。</p>\n<h2 id=\"核函数\"><a href=\"#核函数\" class=\"headerlink\" title=\"核函数\"></a>核函数</h2><p>我们的SVM目的其实也简单，就是找一个超平面，引用一张图即可表述这个目的：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632144374512.jpg\" alt=\"\"></p>\n<p>然而现实任务中，原始样本空间也许并不能存在一个能正确划分出两类样本的超平面，而且这是很经常的事。你说说要是遇到这样的数据，怎么划分好呢：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632143758259.jpg\" alt=\"\"><br>告诉我你的曲线方程吧，傻了吧~</p>\n<p>于是引入了一个新的概念：核函数。它可以将样本从原始空间映射到一个更高维的特质空间中，使得样本在这个新的高维空间中可以被线性划分为两类，即在空间内<strong>线性划分</strong>。这个过程可以观看<a href=\"https://www.youtube.com/watch?v=3liCbRZPrZA\">视频</a>感受感受，由于是youtube所以我截一下图：</p>\n<p>这是原始数据和原始空间，明显有红蓝两类：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632147909478.jpg\" alt=\"\"></p>\n<p>通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632148908664.jpg\" alt=\"\"></p>\n<p>而后进行切割：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632149178576.jpg\" alt=\"\"></p>\n<p>再将分割的超平面映射回去：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632149709432.jpg\" alt=\"\"></p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632149780244.jpg\" alt=\"\"></p>\n<p>大功告成，这些就是核函数的目的。</p>\n<p>再进一步，核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。（这里只涉及概念，不涉及数学原理）</p>\n<h2 id=\"软间隔\"><a href=\"#软间隔\" class=\"headerlink\" title=\"软间隔\"></a>软间隔</h2><p>知道了上面的知识后，你不是就觉得SVM分类就应该是这样的：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632153433430.jpg\" alt=\"\"></p>\n<p>然而这也不一定是这样的，上图给出的是一种完美的情况，多么恰巧地两类分地很开，多么幸运地能有一个超平面能将两个类区分开来！要是这两个类有一部分掺在一起了，那又该怎么分啊：<br><img src=\"http://source.jianyujianyu.com/2016-05-14-14632157241594.jpg\" alt=\"\"></p>\n<p>有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上，而且这样的样本越少越好，”站错队“的样本数量要通过实际来权衡。这就得用上”软间隔“，有软间隔必然有硬间隔，应间隔就是最开始的支持向量机，硬间隔支持向量机只能如此”明确“地分类。特意找来了这个数学解释：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-14-14632160235765.jpg\" alt=\"\"></p>\n<p>其中一个样本要是”站错队“就要有损失，我们的目的就是：找出总损失值最小并且能大概分类的超平面。而计算一个样本的损失的损失函数也有很多种，例如：hinge损失、指数损失、対率损失等。</p>\n<p>只是简单地把思路整理了一遍而已。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"谈谈NLP中的终极问题","date":"2016-06-01T07:55:04.000Z","_content":"\n\n*读了点书，写点笔记*\n\n## 歧义消除\n\n分析特定的上下文的词被赋予何种意思。需要联系上下文，利用临近的词汇的相近含义。NLP中出现歧义的原因较多是因为是同一句句子可被分割为不同的结构，而不同的结构又能译出不同的意思。举个例子，如“咬死了猎人的狗”，“南京市长江大桥”等等，这些句子都能根据不同的结构分成不止一种的歧义。煎鱼所知道消除歧义的方法就两种（毕竟煎鱼读的书少），一是根据统计计算出跟普遍的用法，二则是将问题反问与用户。\n\n第一种的话，也不需要太多地阐述，通俗点来讲就是看看这些歧义中，哪一种会被更多人接受。如“南京市长江大桥”，更多人认可是“南京市-长江-大桥”，而不是“南京-市长-江大桥”（当然煎鱼是讲得太过通俗了，这里的筛选其实是有严格的数据做支撑的）。\n\n而第二种做法是煎鱼更为认同的，其实别说机器了，当我们人类遇到歧义时也是一脸懵逼的，所以当人类都不知道应该是哪一个意思的时候，为何要为难机器在这两个中选一个呢？更何况，概率小者也不该被忽略！而第二种做法就是：将问题反问给用户 —— 请问你说的是“南京-市长-江大桥”还是“南京市-长江-大桥”呢？\n\n<!-- more -->\n\n## 指代消除\n\n通常需要分清某代词是指前文的主语还是宾语，例如“Fafa偷了煎鱼送给女朋友的项链，最后被警察捉了。”、“Fafa偷了煎鱼送给女朋友的项链，最后还是被归还了。”，究竟是哪个被警察捉，哪个被归还呢？这样的指代歧义想要消除就必须要理解前一句话整句话的意思 —— 这就有意思了，想要理解一句话，就要理解它前一句话的意思对吧（为啥我会想到0.5的无数次平方永远大于零）。\n\n指代消除的一种做法是深度学习消除，可以参考《基于Deep Learning的代词指代消解》（奚雪峰，周国栋，2013.06），这里不作描述。\n\n## 自动生成语言\n\n主要在自动回答和机器翻译中常用，依赖于对文意的理解以及机器对人类语言结构的掌握。煎鱼个人觉得两个都是难点，理解文意就不用说了，一直是难点；而语言结构为啥说也很难呢，主要是人类这种神奇的东西，ta可以通过人类语言中原本有限的语法规则，组合成口语中无限的可能，你看看啥事宾语前置、状语后置、X语X置什么鬼的。当然你也可以说，过于口语的语法不给机器用就行了 —— 这样的确可以，但是不会自动学习新语法规则的人工智能是人工智能吗？\n\n同时，机器也要掌握一定的语言风格，当然也可以模仿别的语言者（语言风格包含了口头禅、喜欢用的词语搭配、是否有文采等）。\n\n## 机器翻译\n\n机器翻译一直是语言理解的圣杯，它几乎是NLP的起源。可以说，机器翻译不仅要求机器充分理解句子的含义，而且还必须掌握了两门语言（甚至是历史文化）的异同。这样的工作，现在要求信雅达的翻译也得用人工，机器这是做不来！到现在，即使是大家大户的微软、谷歌等都没有一个较为完美的解决办法，可以说，它的解决方法是全人类都在寻找的（BTW，这个算是NP完全问题么）。\n\n## 人机对话系统\n\n煎鱼第一想到的就是这名的图灵测试了 —— 究竟机器与真人两者同时和你聊天，你最后是否真的能区分出哪个是人类，哪个是机器呢？\n\n当然，广义的人机对话即是人机交互了（煎鱼的理解）。人机对话可通过多种形式进行，有字符、手势、语音、表情、肢体动作等。其中，比较热门的语音的交互形式包含了语音识别和句意解释，而语音识别在现在也已经比较成熟了（微信开发都已经标配了语音识别了，有兴趣的加煎鱼的小小机器人，然后用语音尝试一下）。而人脸识别也是较为成熟。。吧。\n\n\n## NLP流程\n\n![](http://source.jianyujianyu.com/2016-06-02-14647820410821.jpg)\n![](http://source.jianyujianyu.com/2016-06-02-14647820553120.jpg)\n\n\n其中涉及：发音模型语位学（Phonology），形态规划形态学（Morphology），词汇和语法句法（Syntax），话语背景语义（Semantics），领域知识推理（Reasoning）。\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n","source":"_posts/talking-about-nlp-problems.md","raw":"title: 谈谈NLP中的终极问题\ncategories: 人工智能\ntags: [NLP,AI]\ndate: 2016-06-01 15:55:04\n---\n\n\n*读了点书，写点笔记*\n\n## 歧义消除\n\n分析特定的上下文的词被赋予何种意思。需要联系上下文，利用临近的词汇的相近含义。NLP中出现歧义的原因较多是因为是同一句句子可被分割为不同的结构，而不同的结构又能译出不同的意思。举个例子，如“咬死了猎人的狗”，“南京市长江大桥”等等，这些句子都能根据不同的结构分成不止一种的歧义。煎鱼所知道消除歧义的方法就两种（毕竟煎鱼读的书少），一是根据统计计算出跟普遍的用法，二则是将问题反问与用户。\n\n第一种的话，也不需要太多地阐述，通俗点来讲就是看看这些歧义中，哪一种会被更多人接受。如“南京市长江大桥”，更多人认可是“南京市-长江-大桥”，而不是“南京-市长-江大桥”（当然煎鱼是讲得太过通俗了，这里的筛选其实是有严格的数据做支撑的）。\n\n而第二种做法是煎鱼更为认同的，其实别说机器了，当我们人类遇到歧义时也是一脸懵逼的，所以当人类都不知道应该是哪一个意思的时候，为何要为难机器在这两个中选一个呢？更何况，概率小者也不该被忽略！而第二种做法就是：将问题反问给用户 —— 请问你说的是“南京-市长-江大桥”还是“南京市-长江-大桥”呢？\n\n<!-- more -->\n\n## 指代消除\n\n通常需要分清某代词是指前文的主语还是宾语，例如“Fafa偷了煎鱼送给女朋友的项链，最后被警察捉了。”、“Fafa偷了煎鱼送给女朋友的项链，最后还是被归还了。”，究竟是哪个被警察捉，哪个被归还呢？这样的指代歧义想要消除就必须要理解前一句话整句话的意思 —— 这就有意思了，想要理解一句话，就要理解它前一句话的意思对吧（为啥我会想到0.5的无数次平方永远大于零）。\n\n指代消除的一种做法是深度学习消除，可以参考《基于Deep Learning的代词指代消解》（奚雪峰，周国栋，2013.06），这里不作描述。\n\n## 自动生成语言\n\n主要在自动回答和机器翻译中常用，依赖于对文意的理解以及机器对人类语言结构的掌握。煎鱼个人觉得两个都是难点，理解文意就不用说了，一直是难点；而语言结构为啥说也很难呢，主要是人类这种神奇的东西，ta可以通过人类语言中原本有限的语法规则，组合成口语中无限的可能，你看看啥事宾语前置、状语后置、X语X置什么鬼的。当然你也可以说，过于口语的语法不给机器用就行了 —— 这样的确可以，但是不会自动学习新语法规则的人工智能是人工智能吗？\n\n同时，机器也要掌握一定的语言风格，当然也可以模仿别的语言者（语言风格包含了口头禅、喜欢用的词语搭配、是否有文采等）。\n\n## 机器翻译\n\n机器翻译一直是语言理解的圣杯，它几乎是NLP的起源。可以说，机器翻译不仅要求机器充分理解句子的含义，而且还必须掌握了两门语言（甚至是历史文化）的异同。这样的工作，现在要求信雅达的翻译也得用人工，机器这是做不来！到现在，即使是大家大户的微软、谷歌等都没有一个较为完美的解决办法，可以说，它的解决方法是全人类都在寻找的（BTW，这个算是NP完全问题么）。\n\n## 人机对话系统\n\n煎鱼第一想到的就是这名的图灵测试了 —— 究竟机器与真人两者同时和你聊天，你最后是否真的能区分出哪个是人类，哪个是机器呢？\n\n当然，广义的人机对话即是人机交互了（煎鱼的理解）。人机对话可通过多种形式进行，有字符、手势、语音、表情、肢体动作等。其中，比较热门的语音的交互形式包含了语音识别和句意解释，而语音识别在现在也已经比较成熟了（微信开发都已经标配了语音识别了，有兴趣的加煎鱼的小小机器人，然后用语音尝试一下）。而人脸识别也是较为成熟。。吧。\n\n\n## NLP流程\n\n![](http://source.jianyujianyu.com/2016-06-02-14647820410821.jpg)\n![](http://source.jianyujianyu.com/2016-06-02-14647820553120.jpg)\n\n\n其中涉及：发音模型语位学（Phonology），形态规划形态学（Morphology），词汇和语法句法（Syntax），话语背景语义（Semantics），领域知识推理（Reasoning）。\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n","slug":"talking-about-nlp-problems","published":1,"updated":"2017-04-23T13:43:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtrg0007uoevcvpl4lv8","content":"<p><em>读了点书，写点笔记</em></p>\n<h2 id=\"歧义消除\"><a href=\"#歧义消除\" class=\"headerlink\" title=\"歧义消除\"></a>歧义消除</h2><p>分析特定的上下文的词被赋予何种意思。需要联系上下文，利用临近的词汇的相近含义。NLP中出现歧义的原因较多是因为是同一句句子可被分割为不同的结构，而不同的结构又能译出不同的意思。举个例子，如“咬死了猎人的狗”，“南京市长江大桥”等等，这些句子都能根据不同的结构分成不止一种的歧义。煎鱼所知道消除歧义的方法就两种（毕竟煎鱼读的书少），一是根据统计计算出跟普遍的用法，二则是将问题反问与用户。</p>\n<p>第一种的话，也不需要太多地阐述，通俗点来讲就是看看这些歧义中，哪一种会被更多人接受。如“南京市长江大桥”，更多人认可是“南京市-长江-大桥”，而不是“南京-市长-江大桥”（当然煎鱼是讲得太过通俗了，这里的筛选其实是有严格的数据做支撑的）。</p>\n<p>而第二种做法是煎鱼更为认同的，其实别说机器了，当我们人类遇到歧义时也是一脸懵逼的，所以当人类都不知道应该是哪一个意思的时候，为何要为难机器在这两个中选一个呢？更何况，概率小者也不该被忽略！而第二种做法就是：将问题反问给用户 —— 请问你说的是“南京-市长-江大桥”还是“南京市-长江-大桥”呢？</p>\n<a id=\"more\"></a>\n<h2 id=\"指代消除\"><a href=\"#指代消除\" class=\"headerlink\" title=\"指代消除\"></a>指代消除</h2><p>通常需要分清某代词是指前文的主语还是宾语，例如“Fafa偷了煎鱼送给女朋友的项链，最后被警察捉了。”、“Fafa偷了煎鱼送给女朋友的项链，最后还是被归还了。”，究竟是哪个被警察捉，哪个被归还呢？这样的指代歧义想要消除就必须要理解前一句话整句话的意思 —— 这就有意思了，想要理解一句话，就要理解它前一句话的意思对吧（为啥我会想到0.5的无数次平方永远大于零）。</p>\n<p>指代消除的一种做法是深度学习消除，可以参考《基于Deep Learning的代词指代消解》（奚雪峰，周国栋，2013.06），这里不作描述。</p>\n<h2 id=\"自动生成语言\"><a href=\"#自动生成语言\" class=\"headerlink\" title=\"自动生成语言\"></a>自动生成语言</h2><p>主要在自动回答和机器翻译中常用，依赖于对文意的理解以及机器对人类语言结构的掌握。煎鱼个人觉得两个都是难点，理解文意就不用说了，一直是难点；而语言结构为啥说也很难呢，主要是人类这种神奇的东西，ta可以通过人类语言中原本有限的语法规则，组合成口语中无限的可能，你看看啥事宾语前置、状语后置、X语X置什么鬼的。当然你也可以说，过于口语的语法不给机器用就行了 —— 这样的确可以，但是不会自动学习新语法规则的人工智能是人工智能吗？</p>\n<p>同时，机器也要掌握一定的语言风格，当然也可以模仿别的语言者（语言风格包含了口头禅、喜欢用的词语搭配、是否有文采等）。</p>\n<h2 id=\"机器翻译\"><a href=\"#机器翻译\" class=\"headerlink\" title=\"机器翻译\"></a>机器翻译</h2><p>机器翻译一直是语言理解的圣杯，它几乎是NLP的起源。可以说，机器翻译不仅要求机器充分理解句子的含义，而且还必须掌握了两门语言（甚至是历史文化）的异同。这样的工作，现在要求信雅达的翻译也得用人工，机器这是做不来！到现在，即使是大家大户的微软、谷歌等都没有一个较为完美的解决办法，可以说，它的解决方法是全人类都在寻找的（BTW，这个算是NP完全问题么）。</p>\n<h2 id=\"人机对话系统\"><a href=\"#人机对话系统\" class=\"headerlink\" title=\"人机对话系统\"></a>人机对话系统</h2><p>煎鱼第一想到的就是这名的图灵测试了 —— 究竟机器与真人两者同时和你聊天，你最后是否真的能区分出哪个是人类，哪个是机器呢？</p>\n<p>当然，广义的人机对话即是人机交互了（煎鱼的理解）。人机对话可通过多种形式进行，有字符、手势、语音、表情、肢体动作等。其中，比较热门的语音的交互形式包含了语音识别和句意解释，而语音识别在现在也已经比较成熟了（微信开发都已经标配了语音识别了，有兴趣的加煎鱼的小小机器人，然后用语音尝试一下）。而人脸识别也是较为成熟。。吧。</p>\n<h2 id=\"NLP流程\"><a href=\"#NLP流程\" class=\"headerlink\" title=\"NLP流程\"></a>NLP流程</h2><p><img src=\"http://source.jianyujianyu.com/2016-06-02-14647820410821.jpg\" alt=\"\"><br><img src=\"http://source.jianyujianyu.com/2016-06-02-14647820553120.jpg\" alt=\"\"></p>\n<p>其中涉及：发音模型语位学（Phonology），形态规划形态学（Morphology），词汇和语法句法（Syntax），话语背景语义（Semantics），领域知识推理（Reasoning）。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><em>读了点书，写点笔记</em></p>\n<h2 id=\"歧义消除\"><a href=\"#歧义消除\" class=\"headerlink\" title=\"歧义消除\"></a>歧义消除</h2><p>分析特定的上下文的词被赋予何种意思。需要联系上下文，利用临近的词汇的相近含义。NLP中出现歧义的原因较多是因为是同一句句子可被分割为不同的结构，而不同的结构又能译出不同的意思。举个例子，如“咬死了猎人的狗”，“南京市长江大桥”等等，这些句子都能根据不同的结构分成不止一种的歧义。煎鱼所知道消除歧义的方法就两种（毕竟煎鱼读的书少），一是根据统计计算出跟普遍的用法，二则是将问题反问与用户。</p>\n<p>第一种的话，也不需要太多地阐述，通俗点来讲就是看看这些歧义中，哪一种会被更多人接受。如“南京市长江大桥”，更多人认可是“南京市-长江-大桥”，而不是“南京-市长-江大桥”（当然煎鱼是讲得太过通俗了，这里的筛选其实是有严格的数据做支撑的）。</p>\n<p>而第二种做法是煎鱼更为认同的，其实别说机器了，当我们人类遇到歧义时也是一脸懵逼的，所以当人类都不知道应该是哪一个意思的时候，为何要为难机器在这两个中选一个呢？更何况，概率小者也不该被忽略！而第二种做法就是：将问题反问给用户 —— 请问你说的是“南京-市长-江大桥”还是“南京市-长江-大桥”呢？</p>","more":"<h2 id=\"指代消除\"><a href=\"#指代消除\" class=\"headerlink\" title=\"指代消除\"></a>指代消除</h2><p>通常需要分清某代词是指前文的主语还是宾语，例如“Fafa偷了煎鱼送给女朋友的项链，最后被警察捉了。”、“Fafa偷了煎鱼送给女朋友的项链，最后还是被归还了。”，究竟是哪个被警察捉，哪个被归还呢？这样的指代歧义想要消除就必须要理解前一句话整句话的意思 —— 这就有意思了，想要理解一句话，就要理解它前一句话的意思对吧（为啥我会想到0.5的无数次平方永远大于零）。</p>\n<p>指代消除的一种做法是深度学习消除，可以参考《基于Deep Learning的代词指代消解》（奚雪峰，周国栋，2013.06），这里不作描述。</p>\n<h2 id=\"自动生成语言\"><a href=\"#自动生成语言\" class=\"headerlink\" title=\"自动生成语言\"></a>自动生成语言</h2><p>主要在自动回答和机器翻译中常用，依赖于对文意的理解以及机器对人类语言结构的掌握。煎鱼个人觉得两个都是难点，理解文意就不用说了，一直是难点；而语言结构为啥说也很难呢，主要是人类这种神奇的东西，ta可以通过人类语言中原本有限的语法规则，组合成口语中无限的可能，你看看啥事宾语前置、状语后置、X语X置什么鬼的。当然你也可以说，过于口语的语法不给机器用就行了 —— 这样的确可以，但是不会自动学习新语法规则的人工智能是人工智能吗？</p>\n<p>同时，机器也要掌握一定的语言风格，当然也可以模仿别的语言者（语言风格包含了口头禅、喜欢用的词语搭配、是否有文采等）。</p>\n<h2 id=\"机器翻译\"><a href=\"#机器翻译\" class=\"headerlink\" title=\"机器翻译\"></a>机器翻译</h2><p>机器翻译一直是语言理解的圣杯，它几乎是NLP的起源。可以说，机器翻译不仅要求机器充分理解句子的含义，而且还必须掌握了两门语言（甚至是历史文化）的异同。这样的工作，现在要求信雅达的翻译也得用人工，机器这是做不来！到现在，即使是大家大户的微软、谷歌等都没有一个较为完美的解决办法，可以说，它的解决方法是全人类都在寻找的（BTW，这个算是NP完全问题么）。</p>\n<h2 id=\"人机对话系统\"><a href=\"#人机对话系统\" class=\"headerlink\" title=\"人机对话系统\"></a>人机对话系统</h2><p>煎鱼第一想到的就是这名的图灵测试了 —— 究竟机器与真人两者同时和你聊天，你最后是否真的能区分出哪个是人类，哪个是机器呢？</p>\n<p>当然，广义的人机对话即是人机交互了（煎鱼的理解）。人机对话可通过多种形式进行，有字符、手势、语音、表情、肢体动作等。其中，比较热门的语音的交互形式包含了语音识别和句意解释，而语音识别在现在也已经比较成熟了（微信开发都已经标配了语音识别了，有兴趣的加煎鱼的小小机器人，然后用语音尝试一下）。而人脸识别也是较为成熟。。吧。</p>\n<h2 id=\"NLP流程\"><a href=\"#NLP流程\" class=\"headerlink\" title=\"NLP流程\"></a>NLP流程</h2><p><img src=\"http://source.jianyujianyu.com/2016-06-02-14647820410821.jpg\" alt=\"\"><br><img src=\"http://source.jianyujianyu.com/2016-06-02-14647820553120.jpg\" alt=\"\"></p>\n<p>其中涉及：发音模型语位学（Phonology），形态规划形态学（Morphology），词汇和语法句法（Syntax），话语背景语义（Semantics），领域知识推理（Reasoning）。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"思考卷积神经网络（CNN）中各种意义","date":"2016-09-02T06:00:01.000Z","_content":"\n\n*只是知道CNN是不够，我们需要对其进行解剖，继而分析不同部件存在的意义*\n\n## CNN的目的\n\n简单来说，CNN的目的是以一定的模型对事物进行特征提取，而后根据特征对该事物进行分类、识别、预测或决策等。在这个过程里，最重要的步骤在于特征提取，即如何提取到能最大程度区分事物的特征。如果提取的特征无法将不同的事物进行划分，那么该特征提取步骤将毫无意义。而实现这个伟大的模型的，是对CNN进行迭代训练。\n\n<!-- more -->\n\n### 特征\n\n在图像中（举个例子），目标事物的特征主要体现在像素与像素之间的关系。比如说，我们能区分一张图片中有一条直线，是因为直线上的像素与直线外邻像素的区别足够大（或直线两边的像素区别足够大），以至于这“直线”能被识别出来：\n\n![直线上的像素与直线外邻像素的区别足够大](http://source.jianyujianyu.com/2016-09-02-14728207615074.jpg)\n\n![直线两边的像素区别足够大](http://source.jianyujianyu.com/2016-09-02-14728208045910.jpg)\n\n除了直线外，其他特征也同理。在CNN中，大部分特征提取依赖于卷积运算。\n\n## 卷积与特征提取\n\n卷积在此其实就是内积，步骤很简单，就是根据多个一定的权重（即卷积核），对一个块的像素进行内积运算，其输出就是提取的特征之一：\n\n![](http://source.jianyujianyu.com/2016-09-02-14728212916756.gif)\n\n### 选用卷积的原因\n\n#### 局部感知\n简单来说，卷积核的大小一般小于输入图像的大小（如果等于则是全连接），因此卷积提取出的特征会更多地关注局部 —— 这很符合日常我们接触到的图像处理。而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。\n\n#### 参数共享\n参数共享最大的作用莫过于很大限度地减少运算量了。\n\n#### 多核\n一般我们都不会只用一个卷积核对输入图像进行过滤，因为一个核的参数是固定的，其提取的特征也会单一化。这就有点像是我们平时如何客观看待事物，必须要从多个角度分析事物，这样才能尽可能地避免对该事物产生偏见。我们也需要多个卷积核对输入图像进行卷积。\n\n#### Down-Pooling\n卷积后再接上一个池化层（Pooling）简直就是绝配，能很好的聚合特征、降维来减少运算量。\n\n#### 多层卷积\n层数越高，提取到的特征就越全局化。\n\n## 池化\n\n池化，即对一块数据进行抽样或聚合，例如选择该区域的最大值（或平均值）取代该区域：\n\n![](http://source.jianyujianyu.com/2016-09-02-14728222809788.gif)\n\n上图的池化例子，将10 * 10的区域池化层1 * 1的区域，这样使数据的敏感度大大降低，同时也在保留数据信息的基础上降低了数据的计算复杂度。\n\n## 激活函数的意义\n\n在数学上，激活函数的作用就是将输入数据映射到0到1上（tanh是映射-1到+1上）。至于映射的原因，除了对数据进行正则化外，大概是控制数据，使其只在一定的范围内。当然也有另外细节作用，例如Sigmoid（tanh）中，能在激活的时候，更关注数据在零（或中心点）前后的细小变化，而忽略数据在极端时的变化，例如ReLU还有避免梯度消失的作用。通常，Sigmoid（tanh）多用于全连接层，而ReLU多用于卷积层。\n\n![](http://source.jianyujianyu.com/2016-09-02-14728233650926.jpg)\n\n![](http://source.jianyujianyu.com/2016-09-02-14728233755870.jpg)\n\n或者我们换一个卷积核（换一种角度）来看待这个激活函数，如果我们把每一次激活动作当成一次分类，即对输入数据分成两类（0或1），那么激活函数得到的输出是在0到1的值，它可以代表着这次“分类”的归属度。如果我们把0规定为未激活，1表示激活，那么输出0.44就表示激活了44%。\n\n而激活函数的使用却有可能带来一定的负面影响（对于训练的负面影响），激活函数可能会使我们得输入数据都激活了大半，对此我们有另外的对策 —— LRN。\n\n## LRN的催化与抑制\n\nLRN，局部响应归一化。在神经学科中，有一个叫横向抑制（lateral inhibition）的概念，这种抑制的作用就是阻止兴奋神经元向邻近神经元传播其动作趋势，从而减少兴奋神经元的邻近神经元的激活程度。借鉴了这一生物现象（其实我们全部东西都是借鉴生物的，不是？），我们使用LRN层来对激活函数的输出数据进行横向抑制，在为激活函数收拾残局的同时，LRN还凸显了该区域的一个峰值 —— 这个峰值特征就是我们想要的特征。\n\n特别是ReLU，它无限制的激活使得我们更需要LRN来到数据进行归一化。在大规模的数据中，我们大多情况下更看重被凸显的高频特征。因此，用LRN对数据的峰值进行催化而对其周围进行抑制，何乐不为。\n\n## IP层\n\n![BP神经网络中d的全连接层](http://source.jianyujianyu.com/2016-09-02-14728250710656.png)\n\n在许多CNN的后部分，都存在着一个IP（Inner Product）层/内积层/fc（full connect）层/全连接层。这个全连接网络的代表性层级，其存在于CNN的意义我不得而知。在许多论文中，它替代了softmax来特征负责最终的提取，而有人也指出CNN最后可以不用IP层。\n\n## Dropout的舍弃\n\n舍弃一直是一个伟大的哲学，生物的进化上例子比比皆是。Dropout的任务就是在训练时，通过设置阈值并与某些隐含层节点的权重对比，让特定的权重不工作 —— 在该层舍弃这些权重。Dropout的作用也很明显，除了加速运算外，就是防止过拟合了。\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n","source":"_posts/thinking-about-cnn.md","raw":"title: 思考卷积神经网络（CNN）中各种意义\ncategories: 图像处理\ntags: [CNN,卷积神经网络]\ndate: 2016-09-02 14:00:01\n---\n\n\n*只是知道CNN是不够，我们需要对其进行解剖，继而分析不同部件存在的意义*\n\n## CNN的目的\n\n简单来说，CNN的目的是以一定的模型对事物进行特征提取，而后根据特征对该事物进行分类、识别、预测或决策等。在这个过程里，最重要的步骤在于特征提取，即如何提取到能最大程度区分事物的特征。如果提取的特征无法将不同的事物进行划分，那么该特征提取步骤将毫无意义。而实现这个伟大的模型的，是对CNN进行迭代训练。\n\n<!-- more -->\n\n### 特征\n\n在图像中（举个例子），目标事物的特征主要体现在像素与像素之间的关系。比如说，我们能区分一张图片中有一条直线，是因为直线上的像素与直线外邻像素的区别足够大（或直线两边的像素区别足够大），以至于这“直线”能被识别出来：\n\n![直线上的像素与直线外邻像素的区别足够大](http://source.jianyujianyu.com/2016-09-02-14728207615074.jpg)\n\n![直线两边的像素区别足够大](http://source.jianyujianyu.com/2016-09-02-14728208045910.jpg)\n\n除了直线外，其他特征也同理。在CNN中，大部分特征提取依赖于卷积运算。\n\n## 卷积与特征提取\n\n卷积在此其实就是内积，步骤很简单，就是根据多个一定的权重（即卷积核），对一个块的像素进行内积运算，其输出就是提取的特征之一：\n\n![](http://source.jianyujianyu.com/2016-09-02-14728212916756.gif)\n\n### 选用卷积的原因\n\n#### 局部感知\n简单来说，卷积核的大小一般小于输入图像的大小（如果等于则是全连接），因此卷积提取出的特征会更多地关注局部 —— 这很符合日常我们接触到的图像处理。而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。\n\n#### 参数共享\n参数共享最大的作用莫过于很大限度地减少运算量了。\n\n#### 多核\n一般我们都不会只用一个卷积核对输入图像进行过滤，因为一个核的参数是固定的，其提取的特征也会单一化。这就有点像是我们平时如何客观看待事物，必须要从多个角度分析事物，这样才能尽可能地避免对该事物产生偏见。我们也需要多个卷积核对输入图像进行卷积。\n\n#### Down-Pooling\n卷积后再接上一个池化层（Pooling）简直就是绝配，能很好的聚合特征、降维来减少运算量。\n\n#### 多层卷积\n层数越高，提取到的特征就越全局化。\n\n## 池化\n\n池化，即对一块数据进行抽样或聚合，例如选择该区域的最大值（或平均值）取代该区域：\n\n![](http://source.jianyujianyu.com/2016-09-02-14728222809788.gif)\n\n上图的池化例子，将10 * 10的区域池化层1 * 1的区域，这样使数据的敏感度大大降低，同时也在保留数据信息的基础上降低了数据的计算复杂度。\n\n## 激活函数的意义\n\n在数学上，激活函数的作用就是将输入数据映射到0到1上（tanh是映射-1到+1上）。至于映射的原因，除了对数据进行正则化外，大概是控制数据，使其只在一定的范围内。当然也有另外细节作用，例如Sigmoid（tanh）中，能在激活的时候，更关注数据在零（或中心点）前后的细小变化，而忽略数据在极端时的变化，例如ReLU还有避免梯度消失的作用。通常，Sigmoid（tanh）多用于全连接层，而ReLU多用于卷积层。\n\n![](http://source.jianyujianyu.com/2016-09-02-14728233650926.jpg)\n\n![](http://source.jianyujianyu.com/2016-09-02-14728233755870.jpg)\n\n或者我们换一个卷积核（换一种角度）来看待这个激活函数，如果我们把每一次激活动作当成一次分类，即对输入数据分成两类（0或1），那么激活函数得到的输出是在0到1的值，它可以代表着这次“分类”的归属度。如果我们把0规定为未激活，1表示激活，那么输出0.44就表示激活了44%。\n\n而激活函数的使用却有可能带来一定的负面影响（对于训练的负面影响），激活函数可能会使我们得输入数据都激活了大半，对此我们有另外的对策 —— LRN。\n\n## LRN的催化与抑制\n\nLRN，局部响应归一化。在神经学科中，有一个叫横向抑制（lateral inhibition）的概念，这种抑制的作用就是阻止兴奋神经元向邻近神经元传播其动作趋势，从而减少兴奋神经元的邻近神经元的激活程度。借鉴了这一生物现象（其实我们全部东西都是借鉴生物的，不是？），我们使用LRN层来对激活函数的输出数据进行横向抑制，在为激活函数收拾残局的同时，LRN还凸显了该区域的一个峰值 —— 这个峰值特征就是我们想要的特征。\n\n特别是ReLU，它无限制的激活使得我们更需要LRN来到数据进行归一化。在大规模的数据中，我们大多情况下更看重被凸显的高频特征。因此，用LRN对数据的峰值进行催化而对其周围进行抑制，何乐不为。\n\n## IP层\n\n![BP神经网络中d的全连接层](http://source.jianyujianyu.com/2016-09-02-14728250710656.png)\n\n在许多CNN的后部分，都存在着一个IP（Inner Product）层/内积层/fc（full connect）层/全连接层。这个全连接网络的代表性层级，其存在于CNN的意义我不得而知。在许多论文中，它替代了softmax来特征负责最终的提取，而有人也指出CNN最后可以不用IP层。\n\n## Dropout的舍弃\n\n舍弃一直是一个伟大的哲学，生物的进化上例子比比皆是。Dropout的任务就是在训练时，通过设置阈值并与某些隐含层节点的权重对比，让特定的权重不工作 —— 在该层舍弃这些权重。Dropout的作用也很明显，除了加速运算外，就是防止过拟合了。\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n","slug":"thinking-about-cnn","published":1,"updated":"2017-04-23T13:43:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtri0008uoevhuw4s33z","content":"<p><em>只是知道CNN是不够，我们需要对其进行解剖，继而分析不同部件存在的意义</em></p>\n<h2 id=\"CNN的目的\"><a href=\"#CNN的目的\" class=\"headerlink\" title=\"CNN的目的\"></a>CNN的目的</h2><p>简单来说，CNN的目的是以一定的模型对事物进行特征提取，而后根据特征对该事物进行分类、识别、预测或决策等。在这个过程里，最重要的步骤在于特征提取，即如何提取到能最大程度区分事物的特征。如果提取的特征无法将不同的事物进行划分，那么该特征提取步骤将毫无意义。而实现这个伟大的模型的，是对CNN进行迭代训练。</p>\n<a id=\"more\"></a>\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p>在图像中（举个例子），目标事物的特征主要体现在像素与像素之间的关系。比如说，我们能区分一张图片中有一条直线，是因为直线上的像素与直线外邻像素的区别足够大（或直线两边的像素区别足够大），以至于这“直线”能被识别出来：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728207615074.jpg\" alt=\"直线上的像素与直线外邻像素的区别足够大\"></p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728208045910.jpg\" alt=\"直线两边的像素区别足够大\"></p>\n<p>除了直线外，其他特征也同理。在CNN中，大部分特征提取依赖于卷积运算。</p>\n<h2 id=\"卷积与特征提取\"><a href=\"#卷积与特征提取\" class=\"headerlink\" title=\"卷积与特征提取\"></a>卷积与特征提取</h2><p>卷积在此其实就是内积，步骤很简单，就是根据多个一定的权重（即卷积核），对一个块的像素进行内积运算，其输出就是提取的特征之一：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728212916756.gif\" alt=\"\"></p>\n<h3 id=\"选用卷积的原因\"><a href=\"#选用卷积的原因\" class=\"headerlink\" title=\"选用卷积的原因\"></a>选用卷积的原因</h3><h4 id=\"局部感知\"><a href=\"#局部感知\" class=\"headerlink\" title=\"局部感知\"></a>局部感知</h4><p>简单来说，卷积核的大小一般小于输入图像的大小（如果等于则是全连接），因此卷积提取出的特征会更多地关注局部 —— 这很符合日常我们接触到的图像处理。而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。</p>\n<h4 id=\"参数共享\"><a href=\"#参数共享\" class=\"headerlink\" title=\"参数共享\"></a>参数共享</h4><p>参数共享最大的作用莫过于很大限度地减少运算量了。</p>\n<h4 id=\"多核\"><a href=\"#多核\" class=\"headerlink\" title=\"多核\"></a>多核</h4><p>一般我们都不会只用一个卷积核对输入图像进行过滤，因为一个核的参数是固定的，其提取的特征也会单一化。这就有点像是我们平时如何客观看待事物，必须要从多个角度分析事物，这样才能尽可能地避免对该事物产生偏见。我们也需要多个卷积核对输入图像进行卷积。</p>\n<h4 id=\"Down-Pooling\"><a href=\"#Down-Pooling\" class=\"headerlink\" title=\"Down-Pooling\"></a>Down-Pooling</h4><p>卷积后再接上一个池化层（Pooling）简直就是绝配，能很好的聚合特征、降维来减少运算量。</p>\n<h4 id=\"多层卷积\"><a href=\"#多层卷积\" class=\"headerlink\" title=\"多层卷积\"></a>多层卷积</h4><p>层数越高，提取到的特征就越全局化。</p>\n<h2 id=\"池化\"><a href=\"#池化\" class=\"headerlink\" title=\"池化\"></a>池化</h2><p>池化，即对一块数据进行抽样或聚合，例如选择该区域的最大值（或平均值）取代该区域：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728222809788.gif\" alt=\"\"></p>\n<p>上图的池化例子，将10 <em> 10的区域池化层1 </em> 1的区域，这样使数据的敏感度大大降低，同时也在保留数据信息的基础上降低了数据的计算复杂度。</p>\n<h2 id=\"激活函数的意义\"><a href=\"#激活函数的意义\" class=\"headerlink\" title=\"激活函数的意义\"></a>激活函数的意义</h2><p>在数学上，激活函数的作用就是将输入数据映射到0到1上（tanh是映射-1到+1上）。至于映射的原因，除了对数据进行正则化外，大概是控制数据，使其只在一定的范围内。当然也有另外细节作用，例如Sigmoid（tanh）中，能在激活的时候，更关注数据在零（或中心点）前后的细小变化，而忽略数据在极端时的变化，例如ReLU还有避免梯度消失的作用。通常，Sigmoid（tanh）多用于全连接层，而ReLU多用于卷积层。</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728233650926.jpg\" alt=\"\"></p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728233755870.jpg\" alt=\"\"></p>\n<p>或者我们换一个卷积核（换一种角度）来看待这个激活函数，如果我们把每一次激活动作当成一次分类，即对输入数据分成两类（0或1），那么激活函数得到的输出是在0到1的值，它可以代表着这次“分类”的归属度。如果我们把0规定为未激活，1表示激活，那么输出0.44就表示激活了44%。</p>\n<p>而激活函数的使用却有可能带来一定的负面影响（对于训练的负面影响），激活函数可能会使我们得输入数据都激活了大半，对此我们有另外的对策 —— LRN。</p>\n<h2 id=\"LRN的催化与抑制\"><a href=\"#LRN的催化与抑制\" class=\"headerlink\" title=\"LRN的催化与抑制\"></a>LRN的催化与抑制</h2><p>LRN，局部响应归一化。在神经学科中，有一个叫横向抑制（lateral inhibition）的概念，这种抑制的作用就是阻止兴奋神经元向邻近神经元传播其动作趋势，从而减少兴奋神经元的邻近神经元的激活程度。借鉴了这一生物现象（其实我们全部东西都是借鉴生物的，不是？），我们使用LRN层来对激活函数的输出数据进行横向抑制，在为激活函数收拾残局的同时，LRN还凸显了该区域的一个峰值 —— 这个峰值特征就是我们想要的特征。</p>\n<p>特别是ReLU，它无限制的激活使得我们更需要LRN来到数据进行归一化。在大规模的数据中，我们大多情况下更看重被凸显的高频特征。因此，用LRN对数据的峰值进行催化而对其周围进行抑制，何乐不为。</p>\n<h2 id=\"IP层\"><a href=\"#IP层\" class=\"headerlink\" title=\"IP层\"></a>IP层</h2><p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728250710656.png\" alt=\"BP神经网络中d的全连接层\"></p>\n<p>在许多CNN的后部分，都存在着一个IP（Inner Product）层/内积层/fc（full connect）层/全连接层。这个全连接网络的代表性层级，其存在于CNN的意义我不得而知。在许多论文中，它替代了softmax来特征负责最终的提取，而有人也指出CNN最后可以不用IP层。</p>\n<h2 id=\"Dropout的舍弃\"><a href=\"#Dropout的舍弃\" class=\"headerlink\" title=\"Dropout的舍弃\"></a>Dropout的舍弃</h2><p>舍弃一直是一个伟大的哲学，生物的进化上例子比比皆是。Dropout的任务就是在训练时，通过设置阈值并与某些隐含层节点的权重对比，让特定的权重不工作 —— 在该层舍弃这些权重。Dropout的作用也很明显，除了加速运算外，就是防止过拟合了。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><em>只是知道CNN是不够，我们需要对其进行解剖，继而分析不同部件存在的意义</em></p>\n<h2 id=\"CNN的目的\"><a href=\"#CNN的目的\" class=\"headerlink\" title=\"CNN的目的\"></a>CNN的目的</h2><p>简单来说，CNN的目的是以一定的模型对事物进行特征提取，而后根据特征对该事物进行分类、识别、预测或决策等。在这个过程里，最重要的步骤在于特征提取，即如何提取到能最大程度区分事物的特征。如果提取的特征无法将不同的事物进行划分，那么该特征提取步骤将毫无意义。而实现这个伟大的模型的，是对CNN进行迭代训练。</p>","more":"<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p>在图像中（举个例子），目标事物的特征主要体现在像素与像素之间的关系。比如说，我们能区分一张图片中有一条直线，是因为直线上的像素与直线外邻像素的区别足够大（或直线两边的像素区别足够大），以至于这“直线”能被识别出来：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728207615074.jpg\" alt=\"直线上的像素与直线外邻像素的区别足够大\"></p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728208045910.jpg\" alt=\"直线两边的像素区别足够大\"></p>\n<p>除了直线外，其他特征也同理。在CNN中，大部分特征提取依赖于卷积运算。</p>\n<h2 id=\"卷积与特征提取\"><a href=\"#卷积与特征提取\" class=\"headerlink\" title=\"卷积与特征提取\"></a>卷积与特征提取</h2><p>卷积在此其实就是内积，步骤很简单，就是根据多个一定的权重（即卷积核），对一个块的像素进行内积运算，其输出就是提取的特征之一：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728212916756.gif\" alt=\"\"></p>\n<h3 id=\"选用卷积的原因\"><a href=\"#选用卷积的原因\" class=\"headerlink\" title=\"选用卷积的原因\"></a>选用卷积的原因</h3><h4 id=\"局部感知\"><a href=\"#局部感知\" class=\"headerlink\" title=\"局部感知\"></a>局部感知</h4><p>简单来说，卷积核的大小一般小于输入图像的大小（如果等于则是全连接），因此卷积提取出的特征会更多地关注局部 —— 这很符合日常我们接触到的图像处理。而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。</p>\n<h4 id=\"参数共享\"><a href=\"#参数共享\" class=\"headerlink\" title=\"参数共享\"></a>参数共享</h4><p>参数共享最大的作用莫过于很大限度地减少运算量了。</p>\n<h4 id=\"多核\"><a href=\"#多核\" class=\"headerlink\" title=\"多核\"></a>多核</h4><p>一般我们都不会只用一个卷积核对输入图像进行过滤，因为一个核的参数是固定的，其提取的特征也会单一化。这就有点像是我们平时如何客观看待事物，必须要从多个角度分析事物，这样才能尽可能地避免对该事物产生偏见。我们也需要多个卷积核对输入图像进行卷积。</p>\n<h4 id=\"Down-Pooling\"><a href=\"#Down-Pooling\" class=\"headerlink\" title=\"Down-Pooling\"></a>Down-Pooling</h4><p>卷积后再接上一个池化层（Pooling）简直就是绝配，能很好的聚合特征、降维来减少运算量。</p>\n<h4 id=\"多层卷积\"><a href=\"#多层卷积\" class=\"headerlink\" title=\"多层卷积\"></a>多层卷积</h4><p>层数越高，提取到的特征就越全局化。</p>\n<h2 id=\"池化\"><a href=\"#池化\" class=\"headerlink\" title=\"池化\"></a>池化</h2><p>池化，即对一块数据进行抽样或聚合，例如选择该区域的最大值（或平均值）取代该区域：</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728222809788.gif\" alt=\"\"></p>\n<p>上图的池化例子，将10 <em> 10的区域池化层1 </em> 1的区域，这样使数据的敏感度大大降低，同时也在保留数据信息的基础上降低了数据的计算复杂度。</p>\n<h2 id=\"激活函数的意义\"><a href=\"#激活函数的意义\" class=\"headerlink\" title=\"激活函数的意义\"></a>激活函数的意义</h2><p>在数学上，激活函数的作用就是将输入数据映射到0到1上（tanh是映射-1到+1上）。至于映射的原因，除了对数据进行正则化外，大概是控制数据，使其只在一定的范围内。当然也有另外细节作用，例如Sigmoid（tanh）中，能在激活的时候，更关注数据在零（或中心点）前后的细小变化，而忽略数据在极端时的变化，例如ReLU还有避免梯度消失的作用。通常，Sigmoid（tanh）多用于全连接层，而ReLU多用于卷积层。</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728233650926.jpg\" alt=\"\"></p>\n<p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728233755870.jpg\" alt=\"\"></p>\n<p>或者我们换一个卷积核（换一种角度）来看待这个激活函数，如果我们把每一次激活动作当成一次分类，即对输入数据分成两类（0或1），那么激活函数得到的输出是在0到1的值，它可以代表着这次“分类”的归属度。如果我们把0规定为未激活，1表示激活，那么输出0.44就表示激活了44%。</p>\n<p>而激活函数的使用却有可能带来一定的负面影响（对于训练的负面影响），激活函数可能会使我们得输入数据都激活了大半，对此我们有另外的对策 —— LRN。</p>\n<h2 id=\"LRN的催化与抑制\"><a href=\"#LRN的催化与抑制\" class=\"headerlink\" title=\"LRN的催化与抑制\"></a>LRN的催化与抑制</h2><p>LRN，局部响应归一化。在神经学科中，有一个叫横向抑制（lateral inhibition）的概念，这种抑制的作用就是阻止兴奋神经元向邻近神经元传播其动作趋势，从而减少兴奋神经元的邻近神经元的激活程度。借鉴了这一生物现象（其实我们全部东西都是借鉴生物的，不是？），我们使用LRN层来对激活函数的输出数据进行横向抑制，在为激活函数收拾残局的同时，LRN还凸显了该区域的一个峰值 —— 这个峰值特征就是我们想要的特征。</p>\n<p>特别是ReLU，它无限制的激活使得我们更需要LRN来到数据进行归一化。在大规模的数据中，我们大多情况下更看重被凸显的高频特征。因此，用LRN对数据的峰值进行催化而对其周围进行抑制，何乐不为。</p>\n<h2 id=\"IP层\"><a href=\"#IP层\" class=\"headerlink\" title=\"IP层\"></a>IP层</h2><p><img src=\"http://source.jianyujianyu.com/2016-09-02-14728250710656.png\" alt=\"BP神经网络中d的全连接层\"></p>\n<p>在许多CNN的后部分，都存在着一个IP（Inner Product）层/内积层/fc（full connect）层/全连接层。这个全连接网络的代表性层级，其存在于CNN的意义我不得而知。在许多论文中，它替代了softmax来特征负责最终的提取，而有人也指出CNN最后可以不用IP层。</p>\n<h2 id=\"Dropout的舍弃\"><a href=\"#Dropout的舍弃\" class=\"headerlink\" title=\"Dropout的舍弃\"></a>Dropout的舍弃</h2><p>舍弃一直是一个伟大的哲学，生物的进化上例子比比皆是。Dropout的任务就是在训练时，通过设置阈值并与某些隐含层节点的权重对比，让特定的权重不工作 —— 在该层舍弃这些权重。Dropout的作用也很明显，除了加速运算外，就是防止过拟合了。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"ubuntu14.04 + cuda8 + caffe + cudnn5.0 (GTX1080 + GTX750Ti)","date":"2017-03-09T19:15:59.000Z","_content":"\n\n*工作室的内网出了问题，不能修改以前写的文档，于是我便修改了放在个人网站*\n\n## 版本\nlinux系统：Ubuntu 14.04.5 （64位）\n显卡：GTX1080 + GTX750Ti\ncuda: cuda_8.0.27_linux.run （传送门：https://developer.nvidia.com/cuda-toolkit）\n显卡驱动：NVIDIA-Linux-x86_64-367.27.run （传送门：http://www.geforce.cn/drivers/results/104314）\ncudnn：cudnn-5.1 ( for CUDA 8 rc) （传送门：https://developer.nvidia.com/cudnn）\nBLAS：BLAS选用intel的MKL parallel_studio_xe_2016，或者Atlas\n\n以下默认使用root用户，sudo已忽略\n\n## 安装ubuntu：\n**需要注意事项：**\nubuntu14.04默认开源驱动不兼容GTX1080，因此需要先拔掉GTX1080或将GTX750Ti置于PCI优先位置\n在显示屏使用GTX750Ti的情况下，安装以及启动ubuntu\n\n<!-- more -->\n\n## 禁用nouveau驱动\n按Ctrl+Alt+F1进入命令提示符,新建一个黑名单文件\n\n`vim /etc/modprobe.d/blacklist-nouveau.conf`\n\n输入\n\n`blacklist nouveau options nouveau modset=0`\n\n保存退出（:wq)\n然后执行\n\n`update-initramfs -u`\n\n执行 `lspci | grep nouveau`查看是否有内容\n如果没有内容 ，说明禁用成功，如果有内容，就重启一下再查看\n`reboot`\n重启后，进入登录界面的时候，不要登录进入桌面，直接按Ctrl+Alt+F1进入命令提示符。\n\n## 安装CUDA和NVIDIA驱动\n（目前使用最新的CUDA里面包含的NVIDIA驱动足矣）\n\n`chmod 755 NVIDIA-Linux-x86_64-367.27.run  //获取权限 `\n`./NVIDIA-Linux-x86_64-367.27.run  //安装驱动  `\n\n安装后就可以用nvidia-smi命令查看显卡和驱动情况。\n\n`chmod 755 cuda_8.0.27_linux.run  `\n`./cuda_8.0.27_linux.run  `\n\nPS：8.0.27可能已经过旧，请到官网下载最新版\n需要注意该版本CUDA8中的NVIDIA驱动太旧，而且我们已经安装了，所以安装CUDA过程中唯有驱动不安装\n除了第二项“”是否安装显卡驱动“选择no之外，其他全部按照默认设定\n安装过程显示如下信息\n\n```\nDo you accept the previously read EULA?\naccept/decline/quit: accept\n\nInstall NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62?\n(y)es/(n)o/(q)uit: n\n\nInstall the CUDA 8.0 Toolkit?\n(y)es/(n)o/(q)uit: y\n\nEnter Toolkit Location\n[ default is /usr/local/cuda-8.0 ]:\n\nDo you want to install a symbolic link at /usr/local/cuda?\n(y)es/(n)o/(q)uit: y\n\nInstall the CUDA 8.0 Samples?\n(y)es/(n)o/(q)uit: y\n\nEnter CUDA Samples Location\n[ default is /home/zhou ]:\n\nInstalling the CUDA Toolkit in /usr/local/cuda-8.0 …\nMissing recommended library: libGLU.so\nMissing recommended library: libX11.so\nMissing recommended library: libXi.so\nMissing recommended library: libXmu.so\n\nInstalling the CUDA Samples in /root …\nCopying samples to /root/NVIDIA_CUDA-8.0_Samples now…\nFinished copying samples.\n.\n.\n.\n```\n\n设置环境变量\n（error while loading shared libraries: xxx.so.x\" 错误的原因和解决办法）\n\n`vim /etc/profile  `\n加上两句\n\n```\nexport PATH=/usr/local/cuda/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH\n```\n\n`vim /etc/ld.so.conf.d/cuda.conf`\n中添加\n`/usr/local/cuda/lib64`\n\n执行`ldconfig  `\n\n## make CUDA库\n安装依赖：\n\n```\napt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev  libglu1-mesa libglu1-mesa-dev libgl1-mesa-glx\ncd /usr/local/cuda/samples\nmake all -j8\n```\n\n以上的make编译时为了测试cuda库和环境安装成功并编译玩一下。\n\n`cd ./bin/x86_64/linux/release`\n`./deviceQuery `    查询显卡信息\n\n![](https://oda3wj69k.qnssl.com/Cache_3fb1040ea54e9bed..jpg)\n\n## 安装CUDNN5.0\n\n解压好CUDNN得到cuda目录\n\n```\ncd cuda\nsudo cp lib64/lib* /usr/local/cuda/lib64/\nsudo cp include/cudnn.h /usr/local/cuda/include/\ncd /usr/local/cuda/lib64/\nsudo chmod +r libcudnn.so.5.0.5\nsudo ln -sf libcudnn.so.5.0.5 libcudnn.so.5\nsudo ln -sf libcudnn.so.5 libcudnn.so\nsudo ldconfig\n```\n\n\n## 安装OPENCV\n推荐安装pyenv来管理python版本环境（自行查找）\n\n提前安装libegl的库，免得安装到一并报错：\n`apt install libegl1-mesa libegl1-mesa-drivers`\n\n参考https://github.com/jayrambhia/Install-OpenCV一键安装opencv\n\n## 编译安装Caffe\n\n### 安装依赖：\n```\napt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev libgflags-dev libgoogle-glog-dev  liblmdb-dev  libboost-all-dev\n```\n\n### 如果不用mkl，而是用atlas，则安装:\n\n```\napt-get install libatlas-dev libatlas-base-dev\n```\n\n### 所有python依赖:（按照不同情况自行查看关系安装）\n\n```\napt-get install python-dev python-pip cython python-numpy python-scipy python-opencv\n```\n\n### 在github上clone Caffe： https://github.com/BVLC/caffe\n进入其目录，并按照实际修改Makefile.config，主要是启用CUDNN，改用MKL（如果安装了），然后编译：\n\n```\ngit clone https://github.com/BVLC/caffe\ncd caffe\nmake all -j8\nmake test -j8\nmake runtest -j8\n```\n\nPS：j后面的8表示启用多少线程来编译，视性能而定\n\n如果还需要使用pycaffe：需要对pycaffe进行编译：\n\n`make pycaffe -j8`\n\n而后进入python目录，用pip安装依赖：\n\n```\napt-get install python-pip\ncd python\npip install -r requirements.txt\n```\n\n顺手把graphviz也安装了：\n\n```\napt-get install graphviz graphviz-dev\npip install pydot\npip install pygraphviz\n```\n\n最后添加pythonpath的环境变量：\n`vim /etc/profile`\n添加`export PYTHONPATH=/root/caffe/python:$PYTHONPATH  # path to pytho in caffe`\n然后执行 `source /etc/profile`\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n","source":"_posts/ubuntu14.04-cuda8-caffe-cudnn5.0-GTX1080-GTX750Ti.md","raw":"title: ubuntu14.04 + cuda8 + caffe + cudnn5.0 (GTX1080 + GTX750Ti)\ncategories: caffe\ntags: [caffe]\ndate: 2017-03-10 03:15:59\n---\n\n\n*工作室的内网出了问题，不能修改以前写的文档，于是我便修改了放在个人网站*\n\n## 版本\nlinux系统：Ubuntu 14.04.5 （64位）\n显卡：GTX1080 + GTX750Ti\ncuda: cuda_8.0.27_linux.run （传送门：https://developer.nvidia.com/cuda-toolkit）\n显卡驱动：NVIDIA-Linux-x86_64-367.27.run （传送门：http://www.geforce.cn/drivers/results/104314）\ncudnn：cudnn-5.1 ( for CUDA 8 rc) （传送门：https://developer.nvidia.com/cudnn）\nBLAS：BLAS选用intel的MKL parallel_studio_xe_2016，或者Atlas\n\n以下默认使用root用户，sudo已忽略\n\n## 安装ubuntu：\n**需要注意事项：**\nubuntu14.04默认开源驱动不兼容GTX1080，因此需要先拔掉GTX1080或将GTX750Ti置于PCI优先位置\n在显示屏使用GTX750Ti的情况下，安装以及启动ubuntu\n\n<!-- more -->\n\n## 禁用nouveau驱动\n按Ctrl+Alt+F1进入命令提示符,新建一个黑名单文件\n\n`vim /etc/modprobe.d/blacklist-nouveau.conf`\n\n输入\n\n`blacklist nouveau options nouveau modset=0`\n\n保存退出（:wq)\n然后执行\n\n`update-initramfs -u`\n\n执行 `lspci | grep nouveau`查看是否有内容\n如果没有内容 ，说明禁用成功，如果有内容，就重启一下再查看\n`reboot`\n重启后，进入登录界面的时候，不要登录进入桌面，直接按Ctrl+Alt+F1进入命令提示符。\n\n## 安装CUDA和NVIDIA驱动\n（目前使用最新的CUDA里面包含的NVIDIA驱动足矣）\n\n`chmod 755 NVIDIA-Linux-x86_64-367.27.run  //获取权限 `\n`./NVIDIA-Linux-x86_64-367.27.run  //安装驱动  `\n\n安装后就可以用nvidia-smi命令查看显卡和驱动情况。\n\n`chmod 755 cuda_8.0.27_linux.run  `\n`./cuda_8.0.27_linux.run  `\n\nPS：8.0.27可能已经过旧，请到官网下载最新版\n需要注意该版本CUDA8中的NVIDIA驱动太旧，而且我们已经安装了，所以安装CUDA过程中唯有驱动不安装\n除了第二项“”是否安装显卡驱动“选择no之外，其他全部按照默认设定\n安装过程显示如下信息\n\n```\nDo you accept the previously read EULA?\naccept/decline/quit: accept\n\nInstall NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62?\n(y)es/(n)o/(q)uit: n\n\nInstall the CUDA 8.0 Toolkit?\n(y)es/(n)o/(q)uit: y\n\nEnter Toolkit Location\n[ default is /usr/local/cuda-8.0 ]:\n\nDo you want to install a symbolic link at /usr/local/cuda?\n(y)es/(n)o/(q)uit: y\n\nInstall the CUDA 8.0 Samples?\n(y)es/(n)o/(q)uit: y\n\nEnter CUDA Samples Location\n[ default is /home/zhou ]:\n\nInstalling the CUDA Toolkit in /usr/local/cuda-8.0 …\nMissing recommended library: libGLU.so\nMissing recommended library: libX11.so\nMissing recommended library: libXi.so\nMissing recommended library: libXmu.so\n\nInstalling the CUDA Samples in /root …\nCopying samples to /root/NVIDIA_CUDA-8.0_Samples now…\nFinished copying samples.\n.\n.\n.\n```\n\n设置环境变量\n（error while loading shared libraries: xxx.so.x\" 错误的原因和解决办法）\n\n`vim /etc/profile  `\n加上两句\n\n```\nexport PATH=/usr/local/cuda/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH\n```\n\n`vim /etc/ld.so.conf.d/cuda.conf`\n中添加\n`/usr/local/cuda/lib64`\n\n执行`ldconfig  `\n\n## make CUDA库\n安装依赖：\n\n```\napt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev  libglu1-mesa libglu1-mesa-dev libgl1-mesa-glx\ncd /usr/local/cuda/samples\nmake all -j8\n```\n\n以上的make编译时为了测试cuda库和环境安装成功并编译玩一下。\n\n`cd ./bin/x86_64/linux/release`\n`./deviceQuery `    查询显卡信息\n\n![](https://oda3wj69k.qnssl.com/Cache_3fb1040ea54e9bed..jpg)\n\n## 安装CUDNN5.0\n\n解压好CUDNN得到cuda目录\n\n```\ncd cuda\nsudo cp lib64/lib* /usr/local/cuda/lib64/\nsudo cp include/cudnn.h /usr/local/cuda/include/\ncd /usr/local/cuda/lib64/\nsudo chmod +r libcudnn.so.5.0.5\nsudo ln -sf libcudnn.so.5.0.5 libcudnn.so.5\nsudo ln -sf libcudnn.so.5 libcudnn.so\nsudo ldconfig\n```\n\n\n## 安装OPENCV\n推荐安装pyenv来管理python版本环境（自行查找）\n\n提前安装libegl的库，免得安装到一并报错：\n`apt install libegl1-mesa libegl1-mesa-drivers`\n\n参考https://github.com/jayrambhia/Install-OpenCV一键安装opencv\n\n## 编译安装Caffe\n\n### 安装依赖：\n```\napt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev libgflags-dev libgoogle-glog-dev  liblmdb-dev  libboost-all-dev\n```\n\n### 如果不用mkl，而是用atlas，则安装:\n\n```\napt-get install libatlas-dev libatlas-base-dev\n```\n\n### 所有python依赖:（按照不同情况自行查看关系安装）\n\n```\napt-get install python-dev python-pip cython python-numpy python-scipy python-opencv\n```\n\n### 在github上clone Caffe： https://github.com/BVLC/caffe\n进入其目录，并按照实际修改Makefile.config，主要是启用CUDNN，改用MKL（如果安装了），然后编译：\n\n```\ngit clone https://github.com/BVLC/caffe\ncd caffe\nmake all -j8\nmake test -j8\nmake runtest -j8\n```\n\nPS：j后面的8表示启用多少线程来编译，视性能而定\n\n如果还需要使用pycaffe：需要对pycaffe进行编译：\n\n`make pycaffe -j8`\n\n而后进入python目录，用pip安装依赖：\n\n```\napt-get install python-pip\ncd python\npip install -r requirements.txt\n```\n\n顺手把graphviz也安装了：\n\n```\napt-get install graphviz graphviz-dev\npip install pydot\npip install pygraphviz\n```\n\n最后添加pythonpath的环境变量：\n`vim /etc/profile`\n添加`export PYTHONPATH=/root/caffe/python:$PYTHONPATH  # path to pytho in caffe`\n然后执行 `source /etc/profile`\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n","slug":"ubuntu14.04-cuda8-caffe-cudnn5.0-GTX1080-GTX750Ti","published":1,"updated":"2017-05-07T03:06:47.000Z","_id":"cj1utjtrm000buoev5963iyb5","comments":1,"layout":"post","photos":[],"link":"","content":"<p><em>工作室的内网出了问题，不能修改以前写的文档，于是我便修改了放在个人网站</em></p>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><p>linux系统：Ubuntu 14.04.5 （64位）<br>显卡：GTX1080 + GTX750Ti<br>cuda: cuda_8.0.27_linux.run （传送门：<a href=\"https://developer.nvidia.com/cuda-toolkit）\" target=\"_blank\" rel=\"external\">https://developer.nvidia.com/cuda-toolkit）</a><br>显卡驱动：NVIDIA-Linux-x86_64-367.27.run （传送门：<a href=\"http://www.geforce.cn/drivers/results/104314）\" target=\"_blank\" rel=\"external\">http://www.geforce.cn/drivers/results/104314）</a><br>cudnn：cudnn-5.1 ( for CUDA 8 rc) （传送门：<a href=\"https://developer.nvidia.com/cudnn）\" target=\"_blank\" rel=\"external\">https://developer.nvidia.com/cudnn）</a><br>BLAS：BLAS选用intel的MKL parallel_studio_xe_2016，或者Atlas</p>\n<p>以下默认使用root用户，sudo已忽略</p>\n<h2 id=\"安装ubuntu：\"><a href=\"#安装ubuntu：\" class=\"headerlink\" title=\"安装ubuntu：\"></a>安装ubuntu：</h2><p><strong>需要注意事项：</strong><br>ubuntu14.04默认开源驱动不兼容GTX1080，因此需要先拔掉GTX1080或将GTX750Ti置于PCI优先位置<br>在显示屏使用GTX750Ti的情况下，安装以及启动ubuntu</p>\n<a id=\"more\"></a>\n<h2 id=\"禁用nouveau驱动\"><a href=\"#禁用nouveau驱动\" class=\"headerlink\" title=\"禁用nouveau驱动\"></a>禁用nouveau驱动</h2><p>按Ctrl+Alt+F1进入命令提示符,新建一个黑名单文件</p>\n<p><code>vim /etc/modprobe.d/blacklist-nouveau.conf</code></p>\n<p>输入</p>\n<p><code>blacklist nouveau options nouveau modset=0</code></p>\n<p>保存退出（:wq)<br>然后执行</p>\n<p><code>update-initramfs -u</code></p>\n<p>执行 <code>lspci | grep nouveau</code>查看是否有内容<br>如果没有内容 ，说明禁用成功，如果有内容，就重启一下再查看<br><code>reboot</code><br>重启后，进入登录界面的时候，不要登录进入桌面，直接按Ctrl+Alt+F1进入命令提示符。</p>\n<h2 id=\"安装CUDA和NVIDIA驱动\"><a href=\"#安装CUDA和NVIDIA驱动\" class=\"headerlink\" title=\"安装CUDA和NVIDIA驱动\"></a>安装CUDA和NVIDIA驱动</h2><p>（目前使用最新的CUDA里面包含的NVIDIA驱动足矣）</p>\n<p><code>chmod 755 NVIDIA-Linux-x86_64-367.27.run  //获取权限</code><br><code>./NVIDIA-Linux-x86_64-367.27.run  //安装驱动</code></p>\n<p>安装后就可以用nvidia-smi命令查看显卡和驱动情况。</p>\n<p><code>chmod 755 cuda_8.0.27_linux.run</code><br><code>./cuda_8.0.27_linux.run</code></p>\n<p>PS：8.0.27可能已经过旧，请到官网下载最新版<br>需要注意该版本CUDA8中的NVIDIA驱动太旧，而且我们已经安装了，所以安装CUDA过程中唯有驱动不安装<br>除了第二项“”是否安装显卡驱动“选择no之外，其他全部按照默认设定<br>安装过程显示如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">Do you accept the previously read EULA?</div><div class=\"line\">accept/decline/quit: accept</div><div class=\"line\"></div><div class=\"line\">Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62?</div><div class=\"line\">(y)es/(n)o/(q)uit: n</div><div class=\"line\"></div><div class=\"line\">Install the CUDA 8.0 Toolkit?</div><div class=\"line\">(y)es/(n)o/(q)uit: y</div><div class=\"line\"></div><div class=\"line\">Enter Toolkit Location</div><div class=\"line\">[ default is /usr/local/cuda-8.0 ]:</div><div class=\"line\"></div><div class=\"line\">Do you want to install a symbolic link at /usr/local/cuda?</div><div class=\"line\">(y)es/(n)o/(q)uit: y</div><div class=\"line\"></div><div class=\"line\">Install the CUDA 8.0 Samples?</div><div class=\"line\">(y)es/(n)o/(q)uit: y</div><div class=\"line\"></div><div class=\"line\">Enter CUDA Samples Location</div><div class=\"line\">[ default is /home/zhou ]:</div><div class=\"line\"></div><div class=\"line\">Installing the CUDA Toolkit in /usr/local/cuda-8.0 …</div><div class=\"line\">Missing recommended library: libGLU.so</div><div class=\"line\">Missing recommended library: libX11.so</div><div class=\"line\">Missing recommended library: libXi.so</div><div class=\"line\">Missing recommended library: libXmu.so</div><div class=\"line\"></div><div class=\"line\">Installing the CUDA Samples in /root …</div><div class=\"line\">Copying samples to /root/NVIDIA_CUDA-8.0_Samples now…</div><div class=\"line\">Finished copying samples.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div></pre></td></tr></table></figure>\n<p>设置环境变量<br>（error while loading shared libraries: xxx.so.x” 错误的原因和解决办法）</p>\n<p><code>vim /etc/profile</code><br>加上两句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=/usr/local/cuda/bin:$PATH</div><div class=\"line\">export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</div></pre></td></tr></table></figure>\n<p><code>vim /etc/ld.so.conf.d/cuda.conf</code><br>中添加<br><code>/usr/local/cuda/lib64</code></p>\n<p>执行<code>ldconfig</code></p>\n<h2 id=\"make-CUDA库\"><a href=\"#make-CUDA库\" class=\"headerlink\" title=\"make CUDA库\"></a>make CUDA库</h2><p>安装依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev  libglu1-mesa libglu1-mesa-dev libgl1-mesa-glx</div><div class=\"line\">cd /usr/local/cuda/samples</div><div class=\"line\">make all -j8</div></pre></td></tr></table></figure>\n<p>以上的make编译时为了测试cuda库和环境安装成功并编译玩一下。</p>\n<p><code>cd ./bin/x86_64/linux/release</code><br><code>./deviceQuery</code>    查询显卡信息</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Cache_3fb1040ea54e9bed..jpg\" alt=\"\"></p>\n<h2 id=\"安装CUDNN5-0\"><a href=\"#安装CUDNN5-0\" class=\"headerlink\" title=\"安装CUDNN5.0\"></a>安装CUDNN5.0</h2><p>解压好CUDNN得到cuda目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd cuda</div><div class=\"line\">sudo cp lib64/lib* /usr/local/cuda/lib64/</div><div class=\"line\">sudo cp include/cudnn.h /usr/local/cuda/include/</div><div class=\"line\">cd /usr/local/cuda/lib64/</div><div class=\"line\">sudo chmod +r libcudnn.so.5.0.5</div><div class=\"line\">sudo ln -sf libcudnn.so.5.0.5 libcudnn.so.5</div><div class=\"line\">sudo ln -sf libcudnn.so.5 libcudnn.so</div><div class=\"line\">sudo ldconfig</div></pre></td></tr></table></figure>\n<h2 id=\"安装OPENCV\"><a href=\"#安装OPENCV\" class=\"headerlink\" title=\"安装OPENCV\"></a>安装OPENCV</h2><p>推荐安装pyenv来管理python版本环境（自行查找）</p>\n<p>提前安装libegl的库，免得安装到一并报错：<br><code>apt install libegl1-mesa libegl1-mesa-drivers</code></p>\n<p>参考<a href=\"https://github.com/jayrambhia/Install-OpenCV一键安装opencv\" target=\"_blank\" rel=\"external\">https://github.com/jayrambhia/Install-OpenCV一键安装opencv</a></p>\n<h2 id=\"编译安装Caffe\"><a href=\"#编译安装Caffe\" class=\"headerlink\" title=\"编译安装Caffe\"></a>编译安装Caffe</h2><h3 id=\"安装依赖：\"><a href=\"#安装依赖：\" class=\"headerlink\" title=\"安装依赖：\"></a>安装依赖：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev libgflags-dev libgoogle-glog-dev  liblmdb-dev  libboost-all-dev</div></pre></td></tr></table></figure>\n<h3 id=\"如果不用mkl，而是用atlas，则安装\"><a href=\"#如果不用mkl，而是用atlas，则安装\" class=\"headerlink\" title=\"如果不用mkl，而是用atlas，则安装:\"></a>如果不用mkl，而是用atlas，则安装:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install libatlas-dev libatlas-base-dev</div></pre></td></tr></table></figure>\n<h3 id=\"所有python依赖-（按照不同情况自行查看关系安装）\"><a href=\"#所有python依赖-（按照不同情况自行查看关系安装）\" class=\"headerlink\" title=\"所有python依赖:（按照不同情况自行查看关系安装）\"></a>所有python依赖:（按照不同情况自行查看关系安装）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install python-dev python-pip cython python-numpy python-scipy python-opencv</div></pre></td></tr></table></figure>\n<h3 id=\"在github上clone-Caffe：-https-github-com-BVLC-caffe\"><a href=\"#在github上clone-Caffe：-https-github-com-BVLC-caffe\" class=\"headerlink\" title=\"在github上clone Caffe： https://github.com/BVLC/caffe\"></a>在github上clone Caffe： <a href=\"https://github.com/BVLC/caffe\" target=\"_blank\" rel=\"external\">https://github.com/BVLC/caffe</a></h3><p>进入其目录，并按照实际修改Makefile.config，主要是启用CUDNN，改用MKL（如果安装了），然后编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/BVLC/caffe</div><div class=\"line\">cd caffe</div><div class=\"line\">make all -j8</div><div class=\"line\">make test -j8</div><div class=\"line\">make runtest -j8</div></pre></td></tr></table></figure>\n<p>PS：j后面的8表示启用多少线程来编译，视性能而定</p>\n<p>如果还需要使用pycaffe：需要对pycaffe进行编译：</p>\n<p><code>make pycaffe -j8</code></p>\n<p>而后进入python目录，用pip安装依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install python-pip</div><div class=\"line\">cd python</div><div class=\"line\">pip install -r requirements.txt</div></pre></td></tr></table></figure>\n<p>顺手把graphviz也安装了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install graphviz graphviz-dev</div><div class=\"line\">pip install pydot</div><div class=\"line\">pip install pygraphviz</div></pre></td></tr></table></figure>\n<p>最后添加pythonpath的环境变量：<br><code>vim /etc/profile</code><br>添加<code>export PYTHONPATH=/root/caffe/python:$PYTHONPATH  # path to pytho in caffe</code><br>然后执行 <code>source /etc/profile</code></p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><em>工作室的内网出了问题，不能修改以前写的文档，于是我便修改了放在个人网站</em></p>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><p>linux系统：Ubuntu 14.04.5 （64位）<br>显卡：GTX1080 + GTX750Ti<br>cuda: cuda_8.0.27_linux.run （传送门：<a href=\"https://developer.nvidia.com/cuda-toolkit）\">https://developer.nvidia.com/cuda-toolkit）</a><br>显卡驱动：NVIDIA-Linux-x86_64-367.27.run （传送门：<a href=\"http://www.geforce.cn/drivers/results/104314）\">http://www.geforce.cn/drivers/results/104314）</a><br>cudnn：cudnn-5.1 ( for CUDA 8 rc) （传送门：<a href=\"https://developer.nvidia.com/cudnn）\">https://developer.nvidia.com/cudnn）</a><br>BLAS：BLAS选用intel的MKL parallel_studio_xe_2016，或者Atlas</p>\n<p>以下默认使用root用户，sudo已忽略</p>\n<h2 id=\"安装ubuntu：\"><a href=\"#安装ubuntu：\" class=\"headerlink\" title=\"安装ubuntu：\"></a>安装ubuntu：</h2><p><strong>需要注意事项：</strong><br>ubuntu14.04默认开源驱动不兼容GTX1080，因此需要先拔掉GTX1080或将GTX750Ti置于PCI优先位置<br>在显示屏使用GTX750Ti的情况下，安装以及启动ubuntu</p>","more":"<h2 id=\"禁用nouveau驱动\"><a href=\"#禁用nouveau驱动\" class=\"headerlink\" title=\"禁用nouveau驱动\"></a>禁用nouveau驱动</h2><p>按Ctrl+Alt+F1进入命令提示符,新建一个黑名单文件</p>\n<p><code>vim /etc/modprobe.d/blacklist-nouveau.conf</code></p>\n<p>输入</p>\n<p><code>blacklist nouveau options nouveau modset=0</code></p>\n<p>保存退出（:wq)<br>然后执行</p>\n<p><code>update-initramfs -u</code></p>\n<p>执行 <code>lspci | grep nouveau</code>查看是否有内容<br>如果没有内容 ，说明禁用成功，如果有内容，就重启一下再查看<br><code>reboot</code><br>重启后，进入登录界面的时候，不要登录进入桌面，直接按Ctrl+Alt+F1进入命令提示符。</p>\n<h2 id=\"安装CUDA和NVIDIA驱动\"><a href=\"#安装CUDA和NVIDIA驱动\" class=\"headerlink\" title=\"安装CUDA和NVIDIA驱动\"></a>安装CUDA和NVIDIA驱动</h2><p>（目前使用最新的CUDA里面包含的NVIDIA驱动足矣）</p>\n<p><code>chmod 755 NVIDIA-Linux-x86_64-367.27.run  //获取权限</code><br><code>./NVIDIA-Linux-x86_64-367.27.run  //安装驱动</code></p>\n<p>安装后就可以用nvidia-smi命令查看显卡和驱动情况。</p>\n<p><code>chmod 755 cuda_8.0.27_linux.run</code><br><code>./cuda_8.0.27_linux.run</code></p>\n<p>PS：8.0.27可能已经过旧，请到官网下载最新版<br>需要注意该版本CUDA8中的NVIDIA驱动太旧，而且我们已经安装了，所以安装CUDA过程中唯有驱动不安装<br>除了第二项“”是否安装显卡驱动“选择no之外，其他全部按照默认设定<br>安装过程显示如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">Do you accept the previously read EULA?</div><div class=\"line\">accept/decline/quit: accept</div><div class=\"line\"></div><div class=\"line\">Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62?</div><div class=\"line\">(y)es/(n)o/(q)uit: n</div><div class=\"line\"></div><div class=\"line\">Install the CUDA 8.0 Toolkit?</div><div class=\"line\">(y)es/(n)o/(q)uit: y</div><div class=\"line\"></div><div class=\"line\">Enter Toolkit Location</div><div class=\"line\">[ default is /usr/local/cuda-8.0 ]:</div><div class=\"line\"></div><div class=\"line\">Do you want to install a symbolic link at /usr/local/cuda?</div><div class=\"line\">(y)es/(n)o/(q)uit: y</div><div class=\"line\"></div><div class=\"line\">Install the CUDA 8.0 Samples?</div><div class=\"line\">(y)es/(n)o/(q)uit: y</div><div class=\"line\"></div><div class=\"line\">Enter CUDA Samples Location</div><div class=\"line\">[ default is /home/zhou ]:</div><div class=\"line\"></div><div class=\"line\">Installing the CUDA Toolkit in /usr/local/cuda-8.0 …</div><div class=\"line\">Missing recommended library: libGLU.so</div><div class=\"line\">Missing recommended library: libX11.so</div><div class=\"line\">Missing recommended library: libXi.so</div><div class=\"line\">Missing recommended library: libXmu.so</div><div class=\"line\"></div><div class=\"line\">Installing the CUDA Samples in /root …</div><div class=\"line\">Copying samples to /root/NVIDIA_CUDA-8.0_Samples now…</div><div class=\"line\">Finished copying samples.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div></pre></td></tr></table></figure>\n<p>设置环境变量<br>（error while loading shared libraries: xxx.so.x” 错误的原因和解决办法）</p>\n<p><code>vim /etc/profile</code><br>加上两句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export PATH=/usr/local/cuda/bin:$PATH</div><div class=\"line\">export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH</div></pre></td></tr></table></figure>\n<p><code>vim /etc/ld.so.conf.d/cuda.conf</code><br>中添加<br><code>/usr/local/cuda/lib64</code></p>\n<p>执行<code>ldconfig</code></p>\n<h2 id=\"make-CUDA库\"><a href=\"#make-CUDA库\" class=\"headerlink\" title=\"make CUDA库\"></a>make CUDA库</h2><p>安装依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev  libglu1-mesa libglu1-mesa-dev libgl1-mesa-glx</div><div class=\"line\">cd /usr/local/cuda/samples</div><div class=\"line\">make all -j8</div></pre></td></tr></table></figure>\n<p>以上的make编译时为了测试cuda库和环境安装成功并编译玩一下。</p>\n<p><code>cd ./bin/x86_64/linux/release</code><br><code>./deviceQuery</code>    查询显卡信息</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Cache_3fb1040ea54e9bed..jpg\" alt=\"\"></p>\n<h2 id=\"安装CUDNN5-0\"><a href=\"#安装CUDNN5-0\" class=\"headerlink\" title=\"安装CUDNN5.0\"></a>安装CUDNN5.0</h2><p>解压好CUDNN得到cuda目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd cuda</div><div class=\"line\">sudo cp lib64/lib* /usr/local/cuda/lib64/</div><div class=\"line\">sudo cp include/cudnn.h /usr/local/cuda/include/</div><div class=\"line\">cd /usr/local/cuda/lib64/</div><div class=\"line\">sudo chmod +r libcudnn.so.5.0.5</div><div class=\"line\">sudo ln -sf libcudnn.so.5.0.5 libcudnn.so.5</div><div class=\"line\">sudo ln -sf libcudnn.so.5 libcudnn.so</div><div class=\"line\">sudo ldconfig</div></pre></td></tr></table></figure>\n<h2 id=\"安装OPENCV\"><a href=\"#安装OPENCV\" class=\"headerlink\" title=\"安装OPENCV\"></a>安装OPENCV</h2><p>推荐安装pyenv来管理python版本环境（自行查找）</p>\n<p>提前安装libegl的库，免得安装到一并报错：<br><code>apt install libegl1-mesa libegl1-mesa-drivers</code></p>\n<p>参考<a href=\"https://github.com/jayrambhia/Install-OpenCV一键安装opencv\">https://github.com/jayrambhia/Install-OpenCV一键安装opencv</a></p>\n<h2 id=\"编译安装Caffe\"><a href=\"#编译安装Caffe\" class=\"headerlink\" title=\"编译安装Caffe\"></a>编译安装Caffe</h2><h3 id=\"安装依赖：\"><a href=\"#安装依赖：\" class=\"headerlink\" title=\"安装依赖：\"></a>安装依赖：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev libgflags-dev libgoogle-glog-dev  liblmdb-dev  libboost-all-dev</div></pre></td></tr></table></figure>\n<h3 id=\"如果不用mkl，而是用atlas，则安装\"><a href=\"#如果不用mkl，而是用atlas，则安装\" class=\"headerlink\" title=\"如果不用mkl，而是用atlas，则安装:\"></a>如果不用mkl，而是用atlas，则安装:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install libatlas-dev libatlas-base-dev</div></pre></td></tr></table></figure>\n<h3 id=\"所有python依赖-（按照不同情况自行查看关系安装）\"><a href=\"#所有python依赖-（按照不同情况自行查看关系安装）\" class=\"headerlink\" title=\"所有python依赖:（按照不同情况自行查看关系安装）\"></a>所有python依赖:（按照不同情况自行查看关系安装）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install python-dev python-pip cython python-numpy python-scipy python-opencv</div></pre></td></tr></table></figure>\n<h3 id=\"在github上clone-Caffe：-https-github-com-BVLC-caffe\"><a href=\"#在github上clone-Caffe：-https-github-com-BVLC-caffe\" class=\"headerlink\" title=\"在github上clone Caffe： https://github.com/BVLC/caffe\"></a>在github上clone Caffe： <a href=\"https://github.com/BVLC/caffe\">https://github.com/BVLC/caffe</a></h3><p>进入其目录，并按照实际修改Makefile.config，主要是启用CUDNN，改用MKL（如果安装了），然后编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/BVLC/caffe</div><div class=\"line\">cd caffe</div><div class=\"line\">make all -j8</div><div class=\"line\">make test -j8</div><div class=\"line\">make runtest -j8</div></pre></td></tr></table></figure>\n<p>PS：j后面的8表示启用多少线程来编译，视性能而定</p>\n<p>如果还需要使用pycaffe：需要对pycaffe进行编译：</p>\n<p><code>make pycaffe -j8</code></p>\n<p>而后进入python目录，用pip安装依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install python-pip</div><div class=\"line\">cd python</div><div class=\"line\">pip install -r requirements.txt</div></pre></td></tr></table></figure>\n<p>顺手把graphviz也安装了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install graphviz graphviz-dev</div><div class=\"line\">pip install pydot</div><div class=\"line\">pip install pygraphviz</div></pre></td></tr></table></figure>\n<p>最后添加pythonpath的环境变量：<br><code>vim /etc/profile</code><br>添加<code>export PYTHONPATH=/root/caffe/python:$PYTHONPATH  # path to pytho in caffe</code><br>然后执行 <code>source /etc/profile</code></p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"从JDBC的不足思考Mybatis的构建","date":"2017-03-03T00:13:37.000Z","_content":"\n\n## 用JDBC实现对数据上的操作\n\n```Java\npublic static List<Map<String,Object>> queryForList(){  \n        Connection connection = null;  \n        ResultSet rs = null;  \n        PreparedStatement stmt = null;  \n        List<Map<String,Object>> resultList = new ArrayList<Map<String,Object>>();  \n          \n        try {  \n            // 1.加载JDBC驱动  \n            Class.forName(\"oracle.jdbc.driver.OracleDriver\").newInstance();  \n            String url = \"jdbc:oracle:thin:@localhost:1521:ORACLEDB\";  \n              \n            String user = \"trainer\";   \n            String password = \"trainer\";   \n              \n            // 2.获取数据库连接，这里需要填写数据库的信息，包括账号密码\n            connection = DriverManager.getConnection(url,user,password);   \n              \n            // 创建查询语句\n            String sql = \"select * from userinfo where user_id = ? \";  \n            // 3.创建Statement对象（每一个Statement为一次数据库执行请求\n            stmt = connection.prepareStatement(sql);  \n              \n            // 4.设置传入参数  \n            stmt.setString(1, \"zhangsan\");  \n              \n            // 5.执行SQL语句  \n            rs = stmt.executeQuery();  \n              \n            // 6.处理查询结果（将查询结果转换成List<Map>格式）  \n            ResultSetMetaData rsmd = rs.getMetaData();  \n            int num = rsmd.getColumnCount();  \n              \n            while(rs.next()){  \n                Map map = new HashMap();  \n                for(int i = 0;i < num;i++){  \n                    String columnName = rsmd.getColumnName(i+1);  \n                    map.put(columnName,rs.getString(columnName));  \n                }  \n                resultList.add(map);  \n            }  \n              \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        } finally { \n        \t\t // 7. 释放所有资源\n            try {  \n                   //关闭结果集  \n                if (rs != null) {  \n                    rs.close();  \n                    rs = null;  \n                }  \n                   //关闭执行  \n                if (stmt != null) {  \n                    stmt.close();  \n                    stmt = null;  \n                }  \n                if (connection != null) {  \n                    connection.close();  \n                    connection = null;  \n                }  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n          \n        return resultList;  \n    }  \n```\n\n<!-- more -->\n\n## 从JDBC中思考Mybatis的构建\nMyBatis是将sql语句中的输入参数和输出参数映射为java对象，放弃了对数据表的完整性控制，但是获得了更灵活和响应性能更快的优势。\n代码注释中标出的7步，在开发中显得略微复杂繁琐，因此在此思考Mybatis是如何改进JDBC的缺点的。\n\n### 连接获取和释放\n如果每次请求数据库都获取连接然后释放，则过于浪费性能；如果都放在一个try里面，则增加代码复杂度以至于难以阅读。可以是用连接池以重复使用连接，但是连接池的多样化问题略为严重。\n\n**解决：**通过一个中间层DataSource进行解耦，统一从DataSource获取连接，DataSource可通过配置选择不同的连接池（DBCP、JNDI）。\n\n### SQL统一存取\n以上例子中的查询语句依然使用SQL字符串，并且还略为发散，根据大佬的话，有三处不足：\n\n- 可读性很差，不利于维护以及做性能调优\n- 改动Java代码需要重新编译、打包部署\n- 不利于取出SQL在数据库客户端执行\n\n**解决：**将SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放），但涉及读取SQL语句的加载问题。\n\n### 传入参数映射和动态SQL\n通过在SQL语句中设置占位符来传参，就要求参数与占位符一一匹配，当传参不确定时，还是得自己拼接于是还是只能在代码中写SQL，因此需要方法根据不同的传参动态生成。\n\n**解决：**类似if-else清晰的结构，使用key-value的Map，在解析的时候根据变量名的具体值来判断，同时使用一种有别于SQL的语法来嵌入变量（如`#变量名#`），如此便可生成符合上下文的SQL语句。\n\n同时，要区分开占位符变量和非占位变量，可以使用`#变量名#`表示占位符变量，使用`$变量名$`表示非占位符变量。\n\n### 结果映射和结果缓存\n执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源的步骤必须是有序的，否则会出错。（如，获取结果不能在释放之后）因此可以封装起来，但主要的是处理结果，如果能把常用的结果处理方法都到位，就可将整个过程封装起来。\n\n**解决：**由于返回和处理结果的多样性，必须要设置两个参数：返回对象的类型，返回数据与处理结构的映射。同时，采用KV缓存提供SQL的性能，而为了保证key的唯一，key采用SQL语句和参数。\n\n### 重复SQL语句问题\n个别语句只是条件不同，主体大致，而表结构的改动促使代码多处修改导致不利于维护。\n\n**解决：**将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用，即模块化。\n\n## 总结\nHibernate属于全自动，Mybatis属于半自动，JDBC属于手动\n从开发效率上讲Hibernate较高，Mybatis居中，JDBC较低\n从执行效率上讲Hibernate较低，Mybatis居中，JDBC较高\n\n## 其他问题：ibatis与Mybatis的区别\nibatis是Mybatis的前身\n\n- Mybatis实现了接口绑定，使用更加方便\n- 对象关系映射的改进，效率更高\n- MyBatis采用功能强大的基于OGNL的表达式来消除其他元素\n\n\n<br/><br/>\n若有错误之处请指出，更多地关注[煎鱼](https://www.jianyujianyu.com)。\n\n\n\n\n\n\n","source":"_posts/thinking-about-mybatis-from-jdbc.md","raw":"title: 从JDBC的不足思考Mybatis的构建\ncategories: Java\ntags: [jdbc,mybatis]\ndate: 2017-03-03 08:13:37\n---\n\n\n## 用JDBC实现对数据上的操作\n\n```Java\npublic static List<Map<String,Object>> queryForList(){  \n        Connection connection = null;  \n        ResultSet rs = null;  \n        PreparedStatement stmt = null;  \n        List<Map<String,Object>> resultList = new ArrayList<Map<String,Object>>();  \n          \n        try {  \n            // 1.加载JDBC驱动  \n            Class.forName(\"oracle.jdbc.driver.OracleDriver\").newInstance();  \n            String url = \"jdbc:oracle:thin:@localhost:1521:ORACLEDB\";  \n              \n            String user = \"trainer\";   \n            String password = \"trainer\";   \n              \n            // 2.获取数据库连接，这里需要填写数据库的信息，包括账号密码\n            connection = DriverManager.getConnection(url,user,password);   \n              \n            // 创建查询语句\n            String sql = \"select * from userinfo where user_id = ? \";  \n            // 3.创建Statement对象（每一个Statement为一次数据库执行请求\n            stmt = connection.prepareStatement(sql);  \n              \n            // 4.设置传入参数  \n            stmt.setString(1, \"zhangsan\");  \n              \n            // 5.执行SQL语句  \n            rs = stmt.executeQuery();  \n              \n            // 6.处理查询结果（将查询结果转换成List<Map>格式）  \n            ResultSetMetaData rsmd = rs.getMetaData();  \n            int num = rsmd.getColumnCount();  \n              \n            while(rs.next()){  \n                Map map = new HashMap();  \n                for(int i = 0;i < num;i++){  \n                    String columnName = rsmd.getColumnName(i+1);  \n                    map.put(columnName,rs.getString(columnName));  \n                }  \n                resultList.add(map);  \n            }  \n              \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        } finally { \n        \t\t // 7. 释放所有资源\n            try {  \n                   //关闭结果集  \n                if (rs != null) {  \n                    rs.close();  \n                    rs = null;  \n                }  \n                   //关闭执行  \n                if (stmt != null) {  \n                    stmt.close();  \n                    stmt = null;  \n                }  \n                if (connection != null) {  \n                    connection.close();  \n                    connection = null;  \n                }  \n            } catch (SQLException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n          \n        return resultList;  \n    }  \n```\n\n<!-- more -->\n\n## 从JDBC中思考Mybatis的构建\nMyBatis是将sql语句中的输入参数和输出参数映射为java对象，放弃了对数据表的完整性控制，但是获得了更灵活和响应性能更快的优势。\n代码注释中标出的7步，在开发中显得略微复杂繁琐，因此在此思考Mybatis是如何改进JDBC的缺点的。\n\n### 连接获取和释放\n如果每次请求数据库都获取连接然后释放，则过于浪费性能；如果都放在一个try里面，则增加代码复杂度以至于难以阅读。可以是用连接池以重复使用连接，但是连接池的多样化问题略为严重。\n\n**解决：**通过一个中间层DataSource进行解耦，统一从DataSource获取连接，DataSource可通过配置选择不同的连接池（DBCP、JNDI）。\n\n### SQL统一存取\n以上例子中的查询语句依然使用SQL字符串，并且还略为发散，根据大佬的话，有三处不足：\n\n- 可读性很差，不利于维护以及做性能调优\n- 改动Java代码需要重新编译、打包部署\n- 不利于取出SQL在数据库客户端执行\n\n**解决：**将SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放），但涉及读取SQL语句的加载问题。\n\n### 传入参数映射和动态SQL\n通过在SQL语句中设置占位符来传参，就要求参数与占位符一一匹配，当传参不确定时，还是得自己拼接于是还是只能在代码中写SQL，因此需要方法根据不同的传参动态生成。\n\n**解决：**类似if-else清晰的结构，使用key-value的Map，在解析的时候根据变量名的具体值来判断，同时使用一种有别于SQL的语法来嵌入变量（如`#变量名#`），如此便可生成符合上下文的SQL语句。\n\n同时，要区分开占位符变量和非占位变量，可以使用`#变量名#`表示占位符变量，使用`$变量名$`表示非占位符变量。\n\n### 结果映射和结果缓存\n执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源的步骤必须是有序的，否则会出错。（如，获取结果不能在释放之后）因此可以封装起来，但主要的是处理结果，如果能把常用的结果处理方法都到位，就可将整个过程封装起来。\n\n**解决：**由于返回和处理结果的多样性，必须要设置两个参数：返回对象的类型，返回数据与处理结构的映射。同时，采用KV缓存提供SQL的性能，而为了保证key的唯一，key采用SQL语句和参数。\n\n### 重复SQL语句问题\n个别语句只是条件不同，主体大致，而表结构的改动促使代码多处修改导致不利于维护。\n\n**解决：**将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用，即模块化。\n\n## 总结\nHibernate属于全自动，Mybatis属于半自动，JDBC属于手动\n从开发效率上讲Hibernate较高，Mybatis居中，JDBC较低\n从执行效率上讲Hibernate较低，Mybatis居中，JDBC较高\n\n## 其他问题：ibatis与Mybatis的区别\nibatis是Mybatis的前身\n\n- Mybatis实现了接口绑定，使用更加方便\n- 对象关系映射的改进，效率更高\n- MyBatis采用功能强大的基于OGNL的表达式来消除其他元素\n\n\n<br/><br/>\n若有错误之处请指出，更多地关注[煎鱼](https://www.jianyujianyu.com)。\n\n\n\n\n\n\n","slug":"thinking-about-mybatis-from-jdbc","published":1,"updated":"2017-04-23T13:43:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtrn000duoevjzutihqp","content":"<h2 id=\"用JDBC实现对数据上的操作\"><a href=\"#用JDBC实现对数据上的操作\" class=\"headerlink\" title=\"用JDBC实现对数据上的操作\"></a>用JDBC实现对数据上的操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Map&lt;String,Object&gt;&gt; queryForList()&#123;  </div><div class=\"line\">        Connection connection = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        ResultSet rs = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        PreparedStatement stmt = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        List&lt;Map&lt;String,Object&gt;&gt; resultList = <span class=\"keyword\">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            <span class=\"comment\">// 1.加载JDBC驱动  </span></div><div class=\"line\">            Class.forName(<span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>).newInstance();  </div><div class=\"line\">            String url = <span class=\"string\">\"jdbc:oracle:thin:@localhost:1521:ORACLEDB\"</span>;  </div><div class=\"line\">              </div><div class=\"line\">            String user = <span class=\"string\">\"trainer\"</span>;   </div><div class=\"line\">            String password = <span class=\"string\">\"trainer\"</span>;   </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 2.获取数据库连接，这里需要填写数据库的信息，包括账号密码</span></div><div class=\"line\">            connection = DriverManager.getConnection(url,user,password);   </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 创建查询语句</span></div><div class=\"line\">            String sql = <span class=\"string\">\"select * from userinfo where user_id = ? \"</span>;  </div><div class=\"line\">            <span class=\"comment\">// 3.创建Statement对象（每一个Statement为一次数据库执行请求</span></div><div class=\"line\">            stmt = connection.prepareStatement(sql);  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 4.设置传入参数  </span></div><div class=\"line\">            stmt.setString(<span class=\"number\">1</span>, <span class=\"string\">\"zhangsan\"</span>);  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 5.执行SQL语句  </span></div><div class=\"line\">            rs = stmt.executeQuery();  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 6.处理查询结果（将查询结果转换成List&lt;Map&gt;格式）  </span></div><div class=\"line\">            ResultSetMetaData rsmd = rs.getMetaData();  </div><div class=\"line\">            <span class=\"keyword\">int</span> num = rsmd.getColumnCount();  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"keyword\">while</span>(rs.next())&#123;  </div><div class=\"line\">                Map map = <span class=\"keyword\">new</span> HashMap();  </div><div class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; num;i++)&#123;  </div><div class=\"line\">                    String columnName = rsmd.getColumnName(i+<span class=\"number\">1</span>);  </div><div class=\"line\">                    map.put(columnName,rs.getString(columnName));  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                resultList.add(map);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">              </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">        \t\t <span class=\"comment\">// 7. 释放所有资源</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">                   <span class=\"comment\">//关闭结果集  </span></div><div class=\"line\">                <span class=\"keyword\">if</span> (rs != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    rs.close();  </div><div class=\"line\">                    rs = <span class=\"keyword\">null</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                   <span class=\"comment\">//关闭执行  </span></div><div class=\"line\">                <span class=\"keyword\">if</span> (stmt != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    stmt.close();  </div><div class=\"line\">                    stmt = <span class=\"keyword\">null</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    connection.close();  </div><div class=\"line\">                    connection = <span class=\"keyword\">null</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">return</span> resultList;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"从JDBC中思考Mybatis的构建\"><a href=\"#从JDBC中思考Mybatis的构建\" class=\"headerlink\" title=\"从JDBC中思考Mybatis的构建\"></a>从JDBC中思考Mybatis的构建</h2><p>MyBatis是将sql语句中的输入参数和输出参数映射为java对象，放弃了对数据表的完整性控制，但是获得了更灵活和响应性能更快的优势。<br>代码注释中标出的7步，在开发中显得略微复杂繁琐，因此在此思考Mybatis是如何改进JDBC的缺点的。</p>\n<h3 id=\"连接获取和释放\"><a href=\"#连接获取和释放\" class=\"headerlink\" title=\"连接获取和释放\"></a>连接获取和释放</h3><p>如果每次请求数据库都获取连接然后释放，则过于浪费性能；如果都放在一个try里面，则增加代码复杂度以至于难以阅读。可以是用连接池以重复使用连接，但是连接池的多样化问题略为严重。</p>\n<p><strong>解决：</strong>通过一个中间层DataSource进行解耦，统一从DataSource获取连接，DataSource可通过配置选择不同的连接池（DBCP、JNDI）。</p>\n<h3 id=\"SQL统一存取\"><a href=\"#SQL统一存取\" class=\"headerlink\" title=\"SQL统一存取\"></a>SQL统一存取</h3><p>以上例子中的查询语句依然使用SQL字符串，并且还略为发散，根据大佬的话，有三处不足：</p>\n<ul>\n<li>可读性很差，不利于维护以及做性能调优</li>\n<li>改动Java代码需要重新编译、打包部署</li>\n<li>不利于取出SQL在数据库客户端执行</li>\n</ul>\n<p><strong>解决：</strong>将SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放），但涉及读取SQL语句的加载问题。</p>\n<h3 id=\"传入参数映射和动态SQL\"><a href=\"#传入参数映射和动态SQL\" class=\"headerlink\" title=\"传入参数映射和动态SQL\"></a>传入参数映射和动态SQL</h3><p>通过在SQL语句中设置占位符来传参，就要求参数与占位符一一匹配，当传参不确定时，还是得自己拼接于是还是只能在代码中写SQL，因此需要方法根据不同的传参动态生成。</p>\n<p><strong>解决：</strong>类似if-else清晰的结构，使用key-value的Map，在解析的时候根据变量名的具体值来判断，同时使用一种有别于SQL的语法来嵌入变量（如<code>#变量名#</code>），如此便可生成符合上下文的SQL语句。</p>\n<p>同时，要区分开占位符变量和非占位变量，可以使用<code>#变量名#</code>表示占位符变量，使用<code>$变量名$</code>表示非占位符变量。</p>\n<h3 id=\"结果映射和结果缓存\"><a href=\"#结果映射和结果缓存\" class=\"headerlink\" title=\"结果映射和结果缓存\"></a>结果映射和结果缓存</h3><p>执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源的步骤必须是有序的，否则会出错。（如，获取结果不能在释放之后）因此可以封装起来，但主要的是处理结果，如果能把常用的结果处理方法都到位，就可将整个过程封装起来。</p>\n<p><strong>解决：</strong>由于返回和处理结果的多样性，必须要设置两个参数：返回对象的类型，返回数据与处理结构的映射。同时，采用KV缓存提供SQL的性能，而为了保证key的唯一，key采用SQL语句和参数。</p>\n<h3 id=\"重复SQL语句问题\"><a href=\"#重复SQL语句问题\" class=\"headerlink\" title=\"重复SQL语句问题\"></a>重复SQL语句问题</h3><p>个别语句只是条件不同，主体大致，而表结构的改动促使代码多处修改导致不利于维护。</p>\n<p><strong>解决：</strong>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用，即模块化。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Hibernate属于全自动，Mybatis属于半自动，JDBC属于手动<br>从开发效率上讲Hibernate较高，Mybatis居中，JDBC较低<br>从执行效率上讲Hibernate较低，Mybatis居中，JDBC较高</p>\n<h2 id=\"其他问题：ibatis与Mybatis的区别\"><a href=\"#其他问题：ibatis与Mybatis的区别\" class=\"headerlink\" title=\"其他问题：ibatis与Mybatis的区别\"></a>其他问题：ibatis与Mybatis的区别</h2><p>ibatis是Mybatis的前身</p>\n<ul>\n<li>Mybatis实现了接口绑定，使用更加方便</li>\n<li>对象关系映射的改进，效率更高</li>\n<li>MyBatis采用功能强大的基于OGNL的表达式来消除其他元素</li>\n</ul>\n<p><br><br><br>若有错误之处请指出，更多地关注<a href=\"https://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"用JDBC实现对数据上的操作\"><a href=\"#用JDBC实现对数据上的操作\" class=\"headerlink\" title=\"用JDBC实现对数据上的操作\"></a>用JDBC实现对数据上的操作</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Map&lt;String,Object&gt;&gt; queryForList()&#123;  </div><div class=\"line\">        Connection connection = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        ResultSet rs = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        PreparedStatement stmt = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        List&lt;Map&lt;String,Object&gt;&gt; resultList = <span class=\"keyword\">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            <span class=\"comment\">// 1.加载JDBC驱动  </span></div><div class=\"line\">            Class.forName(<span class=\"string\">\"oracle.jdbc.driver.OracleDriver\"</span>).newInstance();  </div><div class=\"line\">            String url = <span class=\"string\">\"jdbc:oracle:thin:@localhost:1521:ORACLEDB\"</span>;  </div><div class=\"line\">              </div><div class=\"line\">            String user = <span class=\"string\">\"trainer\"</span>;   </div><div class=\"line\">            String password = <span class=\"string\">\"trainer\"</span>;   </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 2.获取数据库连接，这里需要填写数据库的信息，包括账号密码</span></div><div class=\"line\">            connection = DriverManager.getConnection(url,user,password);   </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 创建查询语句</span></div><div class=\"line\">            String sql = <span class=\"string\">\"select * from userinfo where user_id = ? \"</span>;  </div><div class=\"line\">            <span class=\"comment\">// 3.创建Statement对象（每一个Statement为一次数据库执行请求</span></div><div class=\"line\">            stmt = connection.prepareStatement(sql);  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 4.设置传入参数  </span></div><div class=\"line\">            stmt.setString(<span class=\"number\">1</span>, <span class=\"string\">\"zhangsan\"</span>);  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 5.执行SQL语句  </span></div><div class=\"line\">            rs = stmt.executeQuery();  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"comment\">// 6.处理查询结果（将查询结果转换成List&lt;Map&gt;格式）  </span></div><div class=\"line\">            ResultSetMetaData rsmd = rs.getMetaData();  </div><div class=\"line\">            <span class=\"keyword\">int</span> num = rsmd.getColumnCount();  </div><div class=\"line\">              </div><div class=\"line\">            <span class=\"keyword\">while</span>(rs.next())&#123;  </div><div class=\"line\">                Map map = <span class=\"keyword\">new</span> HashMap();  </div><div class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; num;i++)&#123;  </div><div class=\"line\">                    String columnName = rsmd.getColumnName(i+<span class=\"number\">1</span>);  </div><div class=\"line\">                    map.put(columnName,rs.getString(columnName));  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                resultList.add(map);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">              </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123; </div><div class=\"line\">        \t\t <span class=\"comment\">// 7. 释放所有资源</span></div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">                   <span class=\"comment\">//关闭结果集  </span></div><div class=\"line\">                <span class=\"keyword\">if</span> (rs != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    rs.close();  </div><div class=\"line\">                    rs = <span class=\"keyword\">null</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                   <span class=\"comment\">//关闭执行  </span></div><div class=\"line\">                <span class=\"keyword\">if</span> (stmt != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    stmt.close();  </div><div class=\"line\">                    stmt = <span class=\"keyword\">null</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">                    connection.close();  </div><div class=\"line\">                    connection = <span class=\"keyword\">null</span>;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">return</span> resultList;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>","more":"<h2 id=\"从JDBC中思考Mybatis的构建\"><a href=\"#从JDBC中思考Mybatis的构建\" class=\"headerlink\" title=\"从JDBC中思考Mybatis的构建\"></a>从JDBC中思考Mybatis的构建</h2><p>MyBatis是将sql语句中的输入参数和输出参数映射为java对象，放弃了对数据表的完整性控制，但是获得了更灵活和响应性能更快的优势。<br>代码注释中标出的7步，在开发中显得略微复杂繁琐，因此在此思考Mybatis是如何改进JDBC的缺点的。</p>\n<h3 id=\"连接获取和释放\"><a href=\"#连接获取和释放\" class=\"headerlink\" title=\"连接获取和释放\"></a>连接获取和释放</h3><p>如果每次请求数据库都获取连接然后释放，则过于浪费性能；如果都放在一个try里面，则增加代码复杂度以至于难以阅读。可以是用连接池以重复使用连接，但是连接池的多样化问题略为严重。</p>\n<p><strong>解决：</strong>通过一个中间层DataSource进行解耦，统一从DataSource获取连接，DataSource可通过配置选择不同的连接池（DBCP、JNDI）。</p>\n<h3 id=\"SQL统一存取\"><a href=\"#SQL统一存取\" class=\"headerlink\" title=\"SQL统一存取\"></a>SQL统一存取</h3><p>以上例子中的查询语句依然使用SQL字符串，并且还略为发散，根据大佬的话，有三处不足：</p>\n<ul>\n<li>可读性很差，不利于维护以及做性能调优</li>\n<li>改动Java代码需要重新编译、打包部署</li>\n<li>不利于取出SQL在数据库客户端执行</li>\n</ul>\n<p><strong>解决：</strong>将SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放），但涉及读取SQL语句的加载问题。</p>\n<h3 id=\"传入参数映射和动态SQL\"><a href=\"#传入参数映射和动态SQL\" class=\"headerlink\" title=\"传入参数映射和动态SQL\"></a>传入参数映射和动态SQL</h3><p>通过在SQL语句中设置占位符来传参，就要求参数与占位符一一匹配，当传参不确定时，还是得自己拼接于是还是只能在代码中写SQL，因此需要方法根据不同的传参动态生成。</p>\n<p><strong>解决：</strong>类似if-else清晰的结构，使用key-value的Map，在解析的时候根据变量名的具体值来判断，同时使用一种有别于SQL的语法来嵌入变量（如<code>#变量名#</code>），如此便可生成符合上下文的SQL语句。</p>\n<p>同时，要区分开占位符变量和非占位变量，可以使用<code>#变量名#</code>表示占位符变量，使用<code>$变量名$</code>表示非占位符变量。</p>\n<h3 id=\"结果映射和结果缓存\"><a href=\"#结果映射和结果缓存\" class=\"headerlink\" title=\"结果映射和结果缓存\"></a>结果映射和结果缓存</h3><p>执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源的步骤必须是有序的，否则会出错。（如，获取结果不能在释放之后）因此可以封装起来，但主要的是处理结果，如果能把常用的结果处理方法都到位，就可将整个过程封装起来。</p>\n<p><strong>解决：</strong>由于返回和处理结果的多样性，必须要设置两个参数：返回对象的类型，返回数据与处理结构的映射。同时，采用KV缓存提供SQL的性能，而为了保证key的唯一，key采用SQL语句和参数。</p>\n<h3 id=\"重复SQL语句问题\"><a href=\"#重复SQL语句问题\" class=\"headerlink\" title=\"重复SQL语句问题\"></a>重复SQL语句问题</h3><p>个别语句只是条件不同，主体大致，而表结构的改动促使代码多处修改导致不利于维护。</p>\n<p><strong>解决：</strong>将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用，即模块化。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Hibernate属于全自动，Mybatis属于半自动，JDBC属于手动<br>从开发效率上讲Hibernate较高，Mybatis居中，JDBC较低<br>从执行效率上讲Hibernate较低，Mybatis居中，JDBC较高</p>\n<h2 id=\"其他问题：ibatis与Mybatis的区别\"><a href=\"#其他问题：ibatis与Mybatis的区别\" class=\"headerlink\" title=\"其他问题：ibatis与Mybatis的区别\"></a>其他问题：ibatis与Mybatis的区别</h2><p>ibatis是Mybatis的前身</p>\n<ul>\n<li>Mybatis实现了接口绑定，使用更加方便</li>\n<li>对象关系映射的改进，效率更高</li>\n<li>MyBatis采用功能强大的基于OGNL的表达式来消除其他元素</li>\n</ul>\n<p><br/><br/><br>若有错误之处请指出，更多地关注<a href=\"https://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"用Go写一个简单Web应用","date":"2016-08-05T19:15:59.000Z","_content":"\n\n## 简介和要求\n\n教程将涵盖以下知识：\n\n- 创建一个带有load和save方法的数据结构体\n- 使用net/http包来创建web应用\n- 使用html/template包来处理HTML模板\n- 使用regexp包来检测用户的输入\n- 使用闭包\n\n假设你已经有以下知识：\n\n- 编程经验\n- 明白基础的web知识（HTTP，HTML）\n- 具有些UNIX、DOS的命令行知识\n\n<!-- more -->\n\n## 开始\n\n首先，你需要有一个装了FreeBSD、Linux、MacOS甚至是Windows系统的机器来跑Go程序。然后，你需要有一个Go环境，即你需要安装Go（废话）。\n\n为了这个教程，我们先在GOPATH里创建一个文件夹，并用cd命令进入里面：\n\n```\n$ mkdir gowiki\n$ cd gowiki\n```\n\n而后创建一个名为wiki.go的文件，用你最中意的编辑器打开它，并在里面加上以下内容：\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n```\n\n以上我们从Go的标准库中导入了fmt和ioutil包。而之后我们会用import声明来引入更多的包，如果我们要实现更多额外的功能的话。\n\n## 数据结构体\n\n现在我们开始定义一个结构体。想象一下，一个wiki应该有什么？它应该有一堆互有关系（互含链接）的网页Page，而后每个网页Page都起码有一个标题Title和主体Body，主体就是内容。因此我们先定义一个网页Page的结构，它有一个标题域和主体域：\n\n```\ntype Page struct {\n    Title string\n    Body  []byte\n}\n```\n\n其中[]byte是“比特切片”的意思，不选用string而选用[]byte，是因为我们会在io库中用到[]byte类型，接下来你会看到的。\n\nPage结构体描述了网页的数据存储在内存中的形式，然而持久化存储呢？我们可以为Page创建一个save方法来实现存储：\n\n```\nfunc (p *Page) save() error {\n    filename := p.Title + \".txt\"\n    return ioutil.WriteFile(filename, p.Body, 0600)\n}\n```\n\n这个方法的声明`func (p *Page) save() error{}`表明了这个方法名为save，属于p，即Page指针类型可调用的方法，而且它不需要传入任何参数，而后返回一个error类型的值。\n\n这个方法会将网页的主体保存到一个txt文件中，而方便起见，我们选用这个网页的Title项作为这个txt文件的名字。而这个save方法返回一个error类型是因为error也是WriteFile的返回类型（WriteFile是一个用于将[]byte写入文件的标准库函数），当然这样返回error也是为了能让程序在写文件时发生错误后处理好。而大多数情况是一切安好，没有故障，这样Page.save()就会返回一个nil（nil是指针、接口或其他类型的”零值“）。\n\n如果你足够细心的话，你会发现WriteFile的第三个参数很奇怪。这个一个八进制数字0600，表明了这个txt文件只对于当前用户，是以具有可读写权限的方式打开的（p.s. 不懂为啥是600的可以看一下Unix/Linux的权限的表达方式）。\n\n有了存储save()方法，对应的也应该有读取的方法：\n\n```\nfunc loadPage(title string) *Page {\n    filename := title + \".txt\"\n    body, _ := ioutil.ReadFile(filename)\n    return &Page{Title: title, Body: body}\n}\n```\n\nloadPage的思想很简单：读取与title有相应名字的txt文件，将文件的内容赋值给变量body，而后返回一个带有Title和Body的Page结构体实例的指针。\n\n首先我们得知道函数是可以返回多个返回值的。而标准库函数io.ReadFile返回了[]byte和error两个类型的值。当然这个简单的loadPage，并没有对错误进行处理 —— 上述代码使用了空标识符，即下划线_，用于抛弃这个error返回值（本质上，这样就是将变量分配到空，就是抛弃）。\n\n但是问题很严重 —— 如果有error了应该怎么办？举个例子，可能这个txt文件并不存在，总不能抛弃吧。因此我们不能坐视不理，我们应该修改一下这个方法：\n\n```\nfunc loadPage(title string) (*Page, error) {\n    filename := title + \".txt\"\n    body, err := ioutil.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n    return &Page{Title: title, Body: body}, nil\n}\n```\n\n现在这个方法的调用者就可以检测一下第二返回值是否为空，以此来检测是否成功读取到Page了。\n\n而在这个moment，我们已经有一些简单的数据结构和读取页面的方法了。我们可以着手于写一个main来测试一下我们写的有没有错误：\n\n```\nfunc main() {\n    p1 := &Page{Title: \"TestPage\", Body: []byte(\"This is a sample Page.\")}\n    p1.save()\n    p2, _ := loadPage(\"TestPage\")\n    fmt.Println(string(p2.Body))\n}\n```\n\n以上代码编译和执行完后，一个名为TestPage.txt、包含着p1内容的文件将会被创建出来。而后这个文件会被p2这个结构体读取，而后这个p2结构体的Body内容将会被输出到屏幕上。\n\n好，现在我们可以编译和运行了：\n\n```\n$ go build wiki.go\n$ ./wiki\nThis is a sample page.\n```\n\n（如果你是windows上跑的，运行的时候直接打\"wiki\"就行，不需要“./”了。）\n\n## 介绍一下net/http包\n\n以下是一个简单的web服务器程序例子：\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:])\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\nmain函数一开始就调用了http.HandleFunc，这个函数就是告诉http包，将web服务器所有/下的请求交给handler处理。接着main函数又调用了http.ListenAndServe，目的就是指定8080端口（先不用管那个第二个参数nil），这个ListenAndServe会一直阻塞整个程序，直到程序被终止。\n\n函数handler的类型是http.HandlerFunc，它需要两个参数，http.ResponseWriter和http.Request。http.ResponseWriter变量的作用就是回应HTTP请求，向它写入一些东西即向HTTP客户端发送一些东西。而http.Request是一个代表了HTTP客户请求的数据结构。handler中的r.URL.Path是请求URL的路径部分，紧跟着的[1:]是对路径的一个切片动作，即返回r.URL.Path的第一个字符到结尾的切片，在这里，实际意味着除去/符号，只要后面的。\n\n如果你运行该程序，并访问以下地址：\n\n```\nhttp://localhost:8080/monkeys\n```\n\n这个程序就会在终端中输出：\n\n```\nHi there, I love monkeys!\n```\n\n## 将wiki和net/http包合并使用\n\n想要使用net/http包，我们必须先将它导入：\n\n```\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n```\n\n而后我们创建一个handler，叫做viewHandler，它可允许用户访问wiki的页面，它会处理前缀是/view/的URL。\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    fmt.Fprintf(w, \"<h1>%s</h1><div>%s</div>\", p.Title, p.Body)\n}\n```\n\n首先，函数先在请求URL的路径部分，即r.URL.Path中提取页面的title。路径被[len(\"/view/\"):]重新切片了一下，为的就是除掉请求URL中/view/的部分，这是因为/view/并不是page的名称。而后函数读取这个txt文件，然后将内容格式转换为的string形式的简单的HTML，继而将这个string写到w，即http.ResponseWriter。\n\n同样这里需要注意一下这个_，这里的_也是直接忽略了loadPage的error返回值，这样做仅是为了程序的简单易懂，而这样忽略通常是极其不好的习惯。我们迟点再对这里进行修改（其实，很多时候都是说迟点再改然后就忘了- -）。\n\n要使用这个handler，我们需要重写一下我们的main函数中的http初始化部分：\n\n```\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n然后我们手动创建一下txt文件（比如说test.txt，用编辑器在里面写句Hello world），然后编译一下我们的代码并运行。\n\n```\n$ go build wiki.go\n$ ./wiki\n```\n\n接着你就可以在浏览器访问http://localhost:8080/view/test看看是不是有一个Hello world，或者是你自己自定义的启动txt文件内容。\n\n## wiki的编辑页面\n\n不能编辑wiki页面的wiki不是一个好wiki。因此，我们需要额外创建两个handler，一个叫做editHandler，用来显示一个wiki的编辑页面，另一个handler叫saveHandler，用来通过提交的表单保存\n数据。\n\n首先，我们先将一下这些添加到main：\n\n```\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.HandleFunc(\"/edit/\", editHandler)\n    http.HandleFunc(\"/save/\", saveHandler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n而后以下的函数editHandler将会载入页面（或者如果这个页面不存在的话，创建一个新的页面结构），然后在浏览器显示这个编辑的表单：\n\n```\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    fmt.Fprintf(w, \"<h1>Editing %s</h1>\"+\n        \"<form action=\\\"/save/%s\\\" method=\\\"POST\\\">\"+\n        \"<textarea name=\\\"body\\\">%s</textarea><br>\"+\n        \"<input type=\\\"submit\\\" value=\\\"Save\\\">\"+\n        \"</form>\",\n        p.Title, p.Title, p.Body)\n}\n```\n\n这样的代码是没有问题的，它能正常运行，但是，这样的硬编码HTML实在是太难看了，我们需要一种“优雅”的输出HTML的方式。\n\n## 使用html/template包优雅地输出HTML\n\nhtml/template包属于Go标准库。使用这个包，我们就可以分离HTML到一个单独的HTML文件，这样我们在修改编辑页面的布局时，就不用再Go代码里面修改了。\n\n首先，我们还是先在import列表中加入我们要导入的html/template，同时，这一次我们不再想要用fmt将内容输出到屏幕了，我们将fmt去掉：\n\n```\nimport (\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n```\n\n接下来，我们创建一个包含了HTML表单的模板 —— 新建一个名为edit.html的文件并添加以下内容：\n\n```\n<h1>Editing {{.Title}}</h1>\n\n<form action=\"/save/{{.Title}}\" method=\"POST\">\n<div><textarea name=\"body\" rows=\"20\" cols=\"80\">{{printf \"%s\" .Body}}</textarea></div>\n<div><input type=\"submit\" value=\"Save\"></div>\n</form>\n```\n\n修改editHandler，将硬编码HTML替换为使用模板：\n\n```\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    t, _ := template.ParseFiles(\"edit.html\")\n    t.Execute(w, p)\n}\n```\n\ntemplate.ParseFiles函数会读取edit.html内容，并返回一个模板的指针*template.Template。而t.Execute函数则是将内容写入模板而后生成HTML到http.ResponseWriter。模板中.Title和.Body中使用的点就是指传入的对象的对应属性，在这里指p.Title和p.Body。\n\n模板中的变量要使用双花括号套住。而模板中的指令`printf \"%s\" .Body`，则是一个以string形式而不是bytes串形式输出Body值的函数调用，这样就相当于fmt.Printf函数，只是一个是输出于浏览器页面上，另一个输出于终端上。\n\nhtml/template包可以帮我们通过模板生成安全的、正确的HTML代码。比如说，它能自动帮你转换大于号（>），就是自动地帮你替换`&gt;`，这样就保证用户数据不会对HTML表单造成干扰。\n\n既然我们已经在使用模板了，我们就继续用模板的这个套路来创建我们的view.html以及调用它的viewHandler。\n\n```\n<h1>{{.Title}}</h1>\n\n<p>[<a href=\"/edit/{{.Title}}\">edit</a>]</p>\n\n<div>{{printf \"%s\" .Body}}</div>\n```\n\n修改viewHandler：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    t, _ := template.ParseFiles(\"view.html\")\n    t.Execute(w, p)\n}\n```\n\n好，该重点细节的时候来了。你看，我们两个handler都有相同的代码来渲染HTML，一个合格的程序员看到这种情况应该要将重复的部分模块化：\n\n```\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, _ := template.ParseFiles(tmpl + \".html\")\n    t.Execute(w, p)\n}\n```\n\n然后两个handler就变成：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    renderTemplate(w, \"view\", p)\n}\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n```\n\n不要觉得代码反而变长了就不重要，甚至嘲笑，重要的是思想:)\n\n## 处理好不存在的页面\n\n如果你去访问/view/APageThatDoesntExist这样一个不存在的页面（假设他不存在），会发生什么？如果是上述代码的Web应用，你应该会看到一个包含着HTML的页面，这是因为我们在loadPage中忽略了文件不存在时的错误处理（这事终于被提上日程了），于是这样地读文件，它只读了个空。其实，如果请求的页面不存在，这样的请求就应该被重定向到编辑页面，这样用户就可以创建一个新的文件了。\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n```\n\nhttp.Redirect函数参数包含了一个状态码http.StatusFound (302)，以及一个响应的目标地址。\n\n## 保存页面\n\n函数saveHandler将会处理好编辑页面中表单的子任务：\n\n```\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    p.save()\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n页面标题（由URL提供）以及Body都会被保存在新的Page实例中。然后save()函数的调用就是要将数据写入到一个文件中，然后客户端就被重定向到/view/中对应的页面。\n\n其中函数FormValue()的返回值是string类型，我们需要将它转换为[]byte类型，这样才能用它来生成新的Page结构体实例。我们使用`[]byte(body) `来实现这个转换。\n\n## 错误处理\n\n我们的程序有几处地方忽略了不该忽略的错误，这是一个坏习惯，尤其是程序发生了你意想不到的错误的时候，你更会后悔莫及。一个较好的处理方案就是先程序自行处理好错误，然后将错误信息发送给用户。按照这样的方案，我们的应用必然会和我们预料的一样执行，并在有问题的时候通知用户。\n\n首先，我们需要在我们刚才分离出来的renderTemplate里面添加处理信息的代码（模块化的好处开始凸显）：\n\n```\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, err := template.ParseFiles(tmpl + \".html\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    err = t.Execute(w, p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\n```\n\nhttp.Error函数会给用户发送一个特定的状态码（这里是Internal Server Error）和错误信息。然后我们继续以同样的方法修改saveHandler：\n\n```\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n当p.save()执行时发生了错误，就会调用http.Error，用户就会得知此错误信息。\n\n## 模板的缓存\n\n当然这个简单的web应用还是不够高效，怎么个不够高效法呢？就是没有缓存，每次用户查看页面，Go程序都需要读取数据并重新渲染一下模板。也就是说，renderTemplate每次都调用ParseFiles。我们对其进行优化，比较好的方案是在程序初始化的时候调用ParseFiles一次，然后将所有模板都赋值到一个*Template里面，我们之后就用ExecuteTemplate来渲染特定的模板了。\n\n首先我们先用ParseFiles函数初始化一个全局变量，名为templates：\n\n```\nvar templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))\n```\n\ntemplate.Must是个封装好的函数，它会在Parse返回err不为nil时，调用panic，而其他情况下，它会照常返回Template指针。Must的引入允许我们不用显式地处理错误，而我们只关注这个业务功能而忽略它还会返回一个错误。而panic在这里也用得较为合适 —— 如果模板都不能被加载了，那么能做得好的事就只能是退出程序了。\n\nParseFiles函数的参数是任意数量的string，这些string对应着我们的模板文件。然后这些模板都会按照文件的命名加载到templates中。当然如果我们要添加更多的模板文件，我们只需要将它们的名字加到ParseFiles的参数里面。\n\n然后我们正式地对renderTemplate进行修改，改成调用templates.ExecuteTemplate的形式：\n\n```\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    err := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\n```\n\np.s.记得加上.html哦。\n\n## 验证\n\n其实如果你足够细心，你会发现一个安全隐患问题：用户可以在服务器应用下的任意路径做读取和修改。为了尽可能避免这个安全隐患，我们写一个函数，它可以用正则表达式来验证title的合法性。\n\n首先我们先将regexp加入到import列表中，然后我们需要创建一个全局变量来存储我们需要用到的表达式：\n\n```\nvar validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")\n```\n\n在这里，我们看到了熟悉的身影Must：regexp.MustCompile，它负责转换和遍历正则表达式，然后返回一个regexp.Regexp类型的变量。类似的，MustCompile和Compile这个妖艳贱货不一样，Must在处理失败的时候会返回一个panic。\n\n然后，我们可以开始写一个函数，它专门用于验证validPath的正确性并从中提取文件的title：\n\n```\nfunc getTitle(w http.ResponseWriter, r *http.Request) (string, error) {\n    m := validPath.FindStringSubmatch(r.URL.Path)\n    if m == nil {\n        http.NotFound(w, r)\n        return \"\", errors.New(\"Invalid Page Title\")\n    }\n    return m[2], nil // The title is the second subexpression.\n}\n```\n\n如果路径合法，它会带着一个nil值返回（第二个返回值）；如果路径不合法，函数就会将“404 Not Found”写进HTTP连接，然后给handler返回一个error。当然，为了可以新建error，我们需要import一下errors包。\n\n然后我们修改所有handler，让它们在里面调用getTitle来验证合法性：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err = p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n## 闭包\n\n心细的你又再次发现，为了捕捉和处理各种错误，我们使用了很多代码，而且还是很多重复的代码，那么我们能不能做点什么呢？也许抽象函数能帮得到我们。\n\n首先，我们重写一下handler的函数定义（以同样的形式，整齐的参数）：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string)\n```\n\n接下来我们定义一个包装函数，它需要的参数类型是*上面我们声明的函数类型*，即`func (http.ResponseWriter, *http.Request, string)`，然后返回一个http.HandlerFunc类型的函数，这个包装函数的大致框架如下：\n\n```\nfunc makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Here we will extract the page title from the Request,\n\t\t// and call the provided handler 'fn'\n\t}\n}\n```\n\n上述函数return了一个函数自己内部定义的函数，称为闭包。在这里，变量fn（即makeHandler唯一的参数）被闭包直接用了，而fn可以是我们的view、save或者edit的handler。\n\n然后我们可以开始着手于闭包里面的实现，我们可以借用getTitle的代码：\n\n```\nfunc makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        m := validPath.FindStringSubmatch(r.URL.Path)\n        if m == nil {\n            http.NotFound(w, r)\n            return\n        }\n        fn(w, r, m[2])\n    }\n}\n```\n\nmakeHandler返回的闭包是带有http.ResponseWriter和http.Request参数的函数。而在这里，闭包在请求路径中提取了title，然后使用TitleValidator正则来检验合法性。如果不合法，它将会向ResponseWriter 用http.NotFound函数写入一个error；如果合法，函数将会用ResponseWriter、Request和title三个参数来调用fn。\n\n然后我们就可以在main函数里面包装我们的handler了：\n\n```\nfunc main() {\n    http.HandleFunc(\"/view/\", makeHandler(viewHandler))\n    http.HandleFunc(\"/edit/\", makeHandler(editHandler))\n    http.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n然后我们去掉先前的getTitle，让handler变得苗条点：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n## 最终再试一下\n\n重新编译运行试试？\n\n```\n$ go build wiki.go\n$ ./wiki\n```\n\n试试运行访问http://localhost:8080/view/ANewPage，看看会怎么样？它应该会给出一个新的编辑页面，然后你可以输入一些内容，你可以保存，在保存后它会将你重定向到新的wiki页面~\n\n### P.S.如果你很混乱，那么我附上最终的全部代码？\n\n```\n// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\ntype Page struct {\n\tTitle string\n\tBody  []byte\n}\n\nfunc (p *Page) save() error {\n\tfilename := p.Title + \".txt\"\n\treturn ioutil.WriteFile(filename, p.Body, 0600)\n}\n\nfunc loadPage(title string) (*Page, error) {\n\tfilename := title + \".txt\"\n\tbody, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Page{Title: title, Body: body}, nil\n}\n\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n\tp, err := loadPage(title)\n\tif err != nil {\n\t\thttp.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n\t\treturn\n\t}\n\trenderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string) {\n\tp, err := loadPage(title)\n\tif err != nil {\n\t\tp = &Page{Title: title}\n\t}\n\trenderTemplate(w, \"edit\", p)\n}\n\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n\tbody := r.FormValue(\"body\")\n\tp := &Page{Title: title, Body: []byte(body)}\n\terr := p.save()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\thttp.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n\nvar templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))\n\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n\terr := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n}\n\nvar validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")\n\nfunc makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tm := validPath.FindStringSubmatch(r.URL.Path)\n\t\tif m == nil {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfn(w, r, m[2])\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/view/\", makeHandler(viewHandler))\n\thttp.HandleFunc(\"/edit/\", makeHandler(editHandler))\n\thttp.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n","source":"_posts/writing-web-using-go.md","raw":"title: 用Go写一个简单Web应用\ncategories: Golang\ntags: [go,web]\ndate: 2016-08-06 03:15:59\n---\n\n\n## 简介和要求\n\n教程将涵盖以下知识：\n\n- 创建一个带有load和save方法的数据结构体\n- 使用net/http包来创建web应用\n- 使用html/template包来处理HTML模板\n- 使用regexp包来检测用户的输入\n- 使用闭包\n\n假设你已经有以下知识：\n\n- 编程经验\n- 明白基础的web知识（HTTP，HTML）\n- 具有些UNIX、DOS的命令行知识\n\n<!-- more -->\n\n## 开始\n\n首先，你需要有一个装了FreeBSD、Linux、MacOS甚至是Windows系统的机器来跑Go程序。然后，你需要有一个Go环境，即你需要安装Go（废话）。\n\n为了这个教程，我们先在GOPATH里创建一个文件夹，并用cd命令进入里面：\n\n```\n$ mkdir gowiki\n$ cd gowiki\n```\n\n而后创建一个名为wiki.go的文件，用你最中意的编辑器打开它，并在里面加上以下内容：\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n```\n\n以上我们从Go的标准库中导入了fmt和ioutil包。而之后我们会用import声明来引入更多的包，如果我们要实现更多额外的功能的话。\n\n## 数据结构体\n\n现在我们开始定义一个结构体。想象一下，一个wiki应该有什么？它应该有一堆互有关系（互含链接）的网页Page，而后每个网页Page都起码有一个标题Title和主体Body，主体就是内容。因此我们先定义一个网页Page的结构，它有一个标题域和主体域：\n\n```\ntype Page struct {\n    Title string\n    Body  []byte\n}\n```\n\n其中[]byte是“比特切片”的意思，不选用string而选用[]byte，是因为我们会在io库中用到[]byte类型，接下来你会看到的。\n\nPage结构体描述了网页的数据存储在内存中的形式，然而持久化存储呢？我们可以为Page创建一个save方法来实现存储：\n\n```\nfunc (p *Page) save() error {\n    filename := p.Title + \".txt\"\n    return ioutil.WriteFile(filename, p.Body, 0600)\n}\n```\n\n这个方法的声明`func (p *Page) save() error{}`表明了这个方法名为save，属于p，即Page指针类型可调用的方法，而且它不需要传入任何参数，而后返回一个error类型的值。\n\n这个方法会将网页的主体保存到一个txt文件中，而方便起见，我们选用这个网页的Title项作为这个txt文件的名字。而这个save方法返回一个error类型是因为error也是WriteFile的返回类型（WriteFile是一个用于将[]byte写入文件的标准库函数），当然这样返回error也是为了能让程序在写文件时发生错误后处理好。而大多数情况是一切安好，没有故障，这样Page.save()就会返回一个nil（nil是指针、接口或其他类型的”零值“）。\n\n如果你足够细心的话，你会发现WriteFile的第三个参数很奇怪。这个一个八进制数字0600，表明了这个txt文件只对于当前用户，是以具有可读写权限的方式打开的（p.s. 不懂为啥是600的可以看一下Unix/Linux的权限的表达方式）。\n\n有了存储save()方法，对应的也应该有读取的方法：\n\n```\nfunc loadPage(title string) *Page {\n    filename := title + \".txt\"\n    body, _ := ioutil.ReadFile(filename)\n    return &Page{Title: title, Body: body}\n}\n```\n\nloadPage的思想很简单：读取与title有相应名字的txt文件，将文件的内容赋值给变量body，而后返回一个带有Title和Body的Page结构体实例的指针。\n\n首先我们得知道函数是可以返回多个返回值的。而标准库函数io.ReadFile返回了[]byte和error两个类型的值。当然这个简单的loadPage，并没有对错误进行处理 —— 上述代码使用了空标识符，即下划线_，用于抛弃这个error返回值（本质上，这样就是将变量分配到空，就是抛弃）。\n\n但是问题很严重 —— 如果有error了应该怎么办？举个例子，可能这个txt文件并不存在，总不能抛弃吧。因此我们不能坐视不理，我们应该修改一下这个方法：\n\n```\nfunc loadPage(title string) (*Page, error) {\n    filename := title + \".txt\"\n    body, err := ioutil.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n    return &Page{Title: title, Body: body}, nil\n}\n```\n\n现在这个方法的调用者就可以检测一下第二返回值是否为空，以此来检测是否成功读取到Page了。\n\n而在这个moment，我们已经有一些简单的数据结构和读取页面的方法了。我们可以着手于写一个main来测试一下我们写的有没有错误：\n\n```\nfunc main() {\n    p1 := &Page{Title: \"TestPage\", Body: []byte(\"This is a sample Page.\")}\n    p1.save()\n    p2, _ := loadPage(\"TestPage\")\n    fmt.Println(string(p2.Body))\n}\n```\n\n以上代码编译和执行完后，一个名为TestPage.txt、包含着p1内容的文件将会被创建出来。而后这个文件会被p2这个结构体读取，而后这个p2结构体的Body内容将会被输出到屏幕上。\n\n好，现在我们可以编译和运行了：\n\n```\n$ go build wiki.go\n$ ./wiki\nThis is a sample page.\n```\n\n（如果你是windows上跑的，运行的时候直接打\"wiki\"就行，不需要“./”了。）\n\n## 介绍一下net/http包\n\n以下是一个简单的web服务器程序例子：\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:])\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\nmain函数一开始就调用了http.HandleFunc，这个函数就是告诉http包，将web服务器所有/下的请求交给handler处理。接着main函数又调用了http.ListenAndServe，目的就是指定8080端口（先不用管那个第二个参数nil），这个ListenAndServe会一直阻塞整个程序，直到程序被终止。\n\n函数handler的类型是http.HandlerFunc，它需要两个参数，http.ResponseWriter和http.Request。http.ResponseWriter变量的作用就是回应HTTP请求，向它写入一些东西即向HTTP客户端发送一些东西。而http.Request是一个代表了HTTP客户请求的数据结构。handler中的r.URL.Path是请求URL的路径部分，紧跟着的[1:]是对路径的一个切片动作，即返回r.URL.Path的第一个字符到结尾的切片，在这里，实际意味着除去/符号，只要后面的。\n\n如果你运行该程序，并访问以下地址：\n\n```\nhttp://localhost:8080/monkeys\n```\n\n这个程序就会在终端中输出：\n\n```\nHi there, I love monkeys!\n```\n\n## 将wiki和net/http包合并使用\n\n想要使用net/http包，我们必须先将它导入：\n\n```\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n```\n\n而后我们创建一个handler，叫做viewHandler，它可允许用户访问wiki的页面，它会处理前缀是/view/的URL。\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    fmt.Fprintf(w, \"<h1>%s</h1><div>%s</div>\", p.Title, p.Body)\n}\n```\n\n首先，函数先在请求URL的路径部分，即r.URL.Path中提取页面的title。路径被[len(\"/view/\"):]重新切片了一下，为的就是除掉请求URL中/view/的部分，这是因为/view/并不是page的名称。而后函数读取这个txt文件，然后将内容格式转换为的string形式的简单的HTML，继而将这个string写到w，即http.ResponseWriter。\n\n同样这里需要注意一下这个_，这里的_也是直接忽略了loadPage的error返回值，这样做仅是为了程序的简单易懂，而这样忽略通常是极其不好的习惯。我们迟点再对这里进行修改（其实，很多时候都是说迟点再改然后就忘了- -）。\n\n要使用这个handler，我们需要重写一下我们的main函数中的http初始化部分：\n\n```\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n然后我们手动创建一下txt文件（比如说test.txt，用编辑器在里面写句Hello world），然后编译一下我们的代码并运行。\n\n```\n$ go build wiki.go\n$ ./wiki\n```\n\n接着你就可以在浏览器访问http://localhost:8080/view/test看看是不是有一个Hello world，或者是你自己自定义的启动txt文件内容。\n\n## wiki的编辑页面\n\n不能编辑wiki页面的wiki不是一个好wiki。因此，我们需要额外创建两个handler，一个叫做editHandler，用来显示一个wiki的编辑页面，另一个handler叫saveHandler，用来通过提交的表单保存\n数据。\n\n首先，我们先将一下这些添加到main：\n\n```\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.HandleFunc(\"/edit/\", editHandler)\n    http.HandleFunc(\"/save/\", saveHandler)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n而后以下的函数editHandler将会载入页面（或者如果这个页面不存在的话，创建一个新的页面结构），然后在浏览器显示这个编辑的表单：\n\n```\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    fmt.Fprintf(w, \"<h1>Editing %s</h1>\"+\n        \"<form action=\\\"/save/%s\\\" method=\\\"POST\\\">\"+\n        \"<textarea name=\\\"body\\\">%s</textarea><br>\"+\n        \"<input type=\\\"submit\\\" value=\\\"Save\\\">\"+\n        \"</form>\",\n        p.Title, p.Title, p.Body)\n}\n```\n\n这样的代码是没有问题的，它能正常运行，但是，这样的硬编码HTML实在是太难看了，我们需要一种“优雅”的输出HTML的方式。\n\n## 使用html/template包优雅地输出HTML\n\nhtml/template包属于Go标准库。使用这个包，我们就可以分离HTML到一个单独的HTML文件，这样我们在修改编辑页面的布局时，就不用再Go代码里面修改了。\n\n首先，我们还是先在import列表中加入我们要导入的html/template，同时，这一次我们不再想要用fmt将内容输出到屏幕了，我们将fmt去掉：\n\n```\nimport (\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n```\n\n接下来，我们创建一个包含了HTML表单的模板 —— 新建一个名为edit.html的文件并添加以下内容：\n\n```\n<h1>Editing {{.Title}}</h1>\n\n<form action=\"/save/{{.Title}}\" method=\"POST\">\n<div><textarea name=\"body\" rows=\"20\" cols=\"80\">{{printf \"%s\" .Body}}</textarea></div>\n<div><input type=\"submit\" value=\"Save\"></div>\n</form>\n```\n\n修改editHandler，将硬编码HTML替换为使用模板：\n\n```\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    t, _ := template.ParseFiles(\"edit.html\")\n    t.Execute(w, p)\n}\n```\n\ntemplate.ParseFiles函数会读取edit.html内容，并返回一个模板的指针*template.Template。而t.Execute函数则是将内容写入模板而后生成HTML到http.ResponseWriter。模板中.Title和.Body中使用的点就是指传入的对象的对应属性，在这里指p.Title和p.Body。\n\n模板中的变量要使用双花括号套住。而模板中的指令`printf \"%s\" .Body`，则是一个以string形式而不是bytes串形式输出Body值的函数调用，这样就相当于fmt.Printf函数，只是一个是输出于浏览器页面上，另一个输出于终端上。\n\nhtml/template包可以帮我们通过模板生成安全的、正确的HTML代码。比如说，它能自动帮你转换大于号（>），就是自动地帮你替换`&gt;`，这样就保证用户数据不会对HTML表单造成干扰。\n\n既然我们已经在使用模板了，我们就继续用模板的这个套路来创建我们的view.html以及调用它的viewHandler。\n\n```\n<h1>{{.Title}}</h1>\n\n<p>[<a href=\"/edit/{{.Title}}\">edit</a>]</p>\n\n<div>{{printf \"%s\" .Body}}</div>\n```\n\n修改viewHandler：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    t, _ := template.ParseFiles(\"view.html\")\n    t.Execute(w, p)\n}\n```\n\n好，该重点细节的时候来了。你看，我们两个handler都有相同的代码来渲染HTML，一个合格的程序员看到这种情况应该要将重复的部分模块化：\n\n```\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, _ := template.ParseFiles(tmpl + \".html\")\n    t.Execute(w, p)\n}\n```\n\n然后两个handler就变成：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, _ := loadPage(title)\n    renderTemplate(w, \"view\", p)\n}\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n```\n\n不要觉得代码反而变长了就不重要，甚至嘲笑，重要的是思想:)\n\n## 处理好不存在的页面\n\n如果你去访问/view/APageThatDoesntExist这样一个不存在的页面（假设他不存在），会发生什么？如果是上述代码的Web应用，你应该会看到一个包含着HTML的页面，这是因为我们在loadPage中忽略了文件不存在时的错误处理（这事终于被提上日程了），于是这样地读文件，它只读了个空。其实，如果请求的页面不存在，这样的请求就应该被重定向到编辑页面，这样用户就可以创建一个新的文件了。\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n```\n\nhttp.Redirect函数参数包含了一个状态码http.StatusFound (302)，以及一个响应的目标地址。\n\n## 保存页面\n\n函数saveHandler将会处理好编辑页面中表单的子任务：\n\n```\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    p.save()\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n页面标题（由URL提供）以及Body都会被保存在新的Page实例中。然后save()函数的调用就是要将数据写入到一个文件中，然后客户端就被重定向到/view/中对应的页面。\n\n其中函数FormValue()的返回值是string类型，我们需要将它转换为[]byte类型，这样才能用它来生成新的Page结构体实例。我们使用`[]byte(body) `来实现这个转换。\n\n## 错误处理\n\n我们的程序有几处地方忽略了不该忽略的错误，这是一个坏习惯，尤其是程序发生了你意想不到的错误的时候，你更会后悔莫及。一个较好的处理方案就是先程序自行处理好错误，然后将错误信息发送给用户。按照这样的方案，我们的应用必然会和我们预料的一样执行，并在有问题的时候通知用户。\n\n首先，我们需要在我们刚才分离出来的renderTemplate里面添加处理信息的代码（模块化的好处开始凸显）：\n\n```\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    t, err := template.ParseFiles(tmpl + \".html\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    err = t.Execute(w, p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\n```\n\nhttp.Error函数会给用户发送一个特定的状态码（这里是Internal Server Error）和错误信息。然后我们继续以同样的方法修改saveHandler：\n\n```\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/save/\"):]\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n当p.save()执行时发生了错误，就会调用http.Error，用户就会得知此错误信息。\n\n## 模板的缓存\n\n当然这个简单的web应用还是不够高效，怎么个不够高效法呢？就是没有缓存，每次用户查看页面，Go程序都需要读取数据并重新渲染一下模板。也就是说，renderTemplate每次都调用ParseFiles。我们对其进行优化，比较好的方案是在程序初始化的时候调用ParseFiles一次，然后将所有模板都赋值到一个*Template里面，我们之后就用ExecuteTemplate来渲染特定的模板了。\n\n首先我们先用ParseFiles函数初始化一个全局变量，名为templates：\n\n```\nvar templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))\n```\n\ntemplate.Must是个封装好的函数，它会在Parse返回err不为nil时，调用panic，而其他情况下，它会照常返回Template指针。Must的引入允许我们不用显式地处理错误，而我们只关注这个业务功能而忽略它还会返回一个错误。而panic在这里也用得较为合适 —— 如果模板都不能被加载了，那么能做得好的事就只能是退出程序了。\n\nParseFiles函数的参数是任意数量的string，这些string对应着我们的模板文件。然后这些模板都会按照文件的命名加载到templates中。当然如果我们要添加更多的模板文件，我们只需要将它们的名字加到ParseFiles的参数里面。\n\n然后我们正式地对renderTemplate进行修改，改成调用templates.ExecuteTemplate的形式：\n\n```\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n    err := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\n```\n\np.s.记得加上.html哦。\n\n## 验证\n\n其实如果你足够细心，你会发现一个安全隐患问题：用户可以在服务器应用下的任意路径做读取和修改。为了尽可能避免这个安全隐患，我们写一个函数，它可以用正则表达式来验证title的合法性。\n\n首先我们先将regexp加入到import列表中，然后我们需要创建一个全局变量来存储我们需要用到的表达式：\n\n```\nvar validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")\n```\n\n在这里，我们看到了熟悉的身影Must：regexp.MustCompile，它负责转换和遍历正则表达式，然后返回一个regexp.Regexp类型的变量。类似的，MustCompile和Compile这个妖艳贱货不一样，Must在处理失败的时候会返回一个panic。\n\n然后，我们可以开始写一个函数，它专门用于验证validPath的正确性并从中提取文件的title：\n\n```\nfunc getTitle(w http.ResponseWriter, r *http.Request) (string, error) {\n    m := validPath.FindStringSubmatch(r.URL.Path)\n    if m == nil {\n        http.NotFound(w, r)\n        return \"\", errors.New(\"Invalid Page Title\")\n    }\n    return m[2], nil // The title is the second subexpression.\n}\n```\n\n如果路径合法，它会带着一个nil值返回（第二个返回值）；如果路径不合法，函数就会将“404 Not Found”写进HTTP连接，然后给handler返回一个error。当然，为了可以新建error，我们需要import一下errors包。\n\n然后我们修改所有handler，让它们在里面调用getTitle来验证合法性：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n\nfunc saveHandler(w http.ResponseWriter, r *http.Request) {\n    title, err := getTitle(w, r)\n    if err != nil {\n        return\n    }\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err = p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n## 闭包\n\n心细的你又再次发现，为了捕捉和处理各种错误，我们使用了很多代码，而且还是很多重复的代码，那么我们能不能做点什么呢？也许抽象函数能帮得到我们。\n\n首先，我们重写一下handler的函数定义（以同样的形式，整齐的参数）：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string)\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string)\n```\n\n接下来我们定义一个包装函数，它需要的参数类型是*上面我们声明的函数类型*，即`func (http.ResponseWriter, *http.Request, string)`，然后返回一个http.HandlerFunc类型的函数，这个包装函数的大致框架如下：\n\n```\nfunc makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Here we will extract the page title from the Request,\n\t\t// and call the provided handler 'fn'\n\t}\n}\n```\n\n上述函数return了一个函数自己内部定义的函数，称为闭包。在这里，变量fn（即makeHandler唯一的参数）被闭包直接用了，而fn可以是我们的view、save或者edit的handler。\n\n然后我们可以开始着手于闭包里面的实现，我们可以借用getTitle的代码：\n\n```\nfunc makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        m := validPath.FindStringSubmatch(r.URL.Path)\n        if m == nil {\n            http.NotFound(w, r)\n            return\n        }\n        fn(w, r, m[2])\n    }\n}\n```\n\nmakeHandler返回的闭包是带有http.ResponseWriter和http.Request参数的函数。而在这里，闭包在请求路径中提取了title，然后使用TitleValidator正则来检验合法性。如果不合法，它将会向ResponseWriter 用http.NotFound函数写入一个error；如果合法，函数将会用ResponseWriter、Request和title三个参数来调用fn。\n\n然后我们就可以在main函数里面包装我们的handler了：\n\n```\nfunc main() {\n    http.HandleFunc(\"/view/\", makeHandler(viewHandler))\n    http.HandleFunc(\"/edit/\", makeHandler(editHandler))\n    http.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n然后我们去掉先前的getTitle，让handler变得苗条点：\n\n```\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string) {\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n    body := r.FormValue(\"body\")\n    p := &Page{Title: title, Body: []byte(body)}\n    err := p.save()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    http.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n```\n\n## 最终再试一下\n\n重新编译运行试试？\n\n```\n$ go build wiki.go\n$ ./wiki\n```\n\n试试运行访问http://localhost:8080/view/ANewPage，看看会怎么样？它应该会给出一个新的编辑页面，然后你可以输入一些内容，你可以保存，在保存后它会将你重定向到新的wiki页面~\n\n### P.S.如果你很混乱，那么我附上最终的全部代码？\n\n```\n// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\ntype Page struct {\n\tTitle string\n\tBody  []byte\n}\n\nfunc (p *Page) save() error {\n\tfilename := p.Title + \".txt\"\n\treturn ioutil.WriteFile(filename, p.Body, 0600)\n}\n\nfunc loadPage(title string) (*Page, error) {\n\tfilename := title + \".txt\"\n\tbody, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Page{Title: title, Body: body}, nil\n}\n\nfunc viewHandler(w http.ResponseWriter, r *http.Request, title string) {\n\tp, err := loadPage(title)\n\tif err != nil {\n\t\thttp.Redirect(w, r, \"/edit/\"+title, http.StatusFound)\n\t\treturn\n\t}\n\trenderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request, title string) {\n\tp, err := loadPage(title)\n\tif err != nil {\n\t\tp = &Page{Title: title}\n\t}\n\trenderTemplate(w, \"edit\", p)\n}\n\nfunc saveHandler(w http.ResponseWriter, r *http.Request, title string) {\n\tbody := r.FormValue(\"body\")\n\tp := &Page{Title: title, Body: []byte(body)}\n\terr := p.save()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\thttp.Redirect(w, r, \"/view/\"+title, http.StatusFound)\n}\n\nvar templates = template.Must(template.ParseFiles(\"edit.html\", \"view.html\"))\n\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {\n\terr := templates.ExecuteTemplate(w, tmpl+\".html\", p)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n}\n\nvar validPath = regexp.MustCompile(\"^/(edit|save|view)/([a-zA-Z0-9]+)$\")\n\nfunc makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tm := validPath.FindStringSubmatch(r.URL.Path)\n\t\tif m == nil {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\tfn(w, r, m[2])\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/view/\", makeHandler(viewHandler))\n\thttp.HandleFunc(\"/edit/\", makeHandler(editHandler))\n\thttp.HandleFunc(\"/save/\", makeHandler(saveHandler))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n","slug":"writing-web-using-go","published":1,"updated":"2017-04-23T13:43:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtrq000huoevs130hbc8","content":"<h2 id=\"简介和要求\"><a href=\"#简介和要求\" class=\"headerlink\" title=\"简介和要求\"></a>简介和要求</h2><p>教程将涵盖以下知识：</p>\n<ul>\n<li>创建一个带有load和save方法的数据结构体</li>\n<li>使用net/http包来创建web应用</li>\n<li>使用html/template包来处理HTML模板</li>\n<li>使用regexp包来检测用户的输入</li>\n<li>使用闭包</li>\n</ul>\n<p>假设你已经有以下知识：</p>\n<ul>\n<li>编程经验</li>\n<li>明白基础的web知识（HTTP，HTML）</li>\n<li>具有些UNIX、DOS的命令行知识</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>首先，你需要有一个装了FreeBSD、Linux、MacOS甚至是Windows系统的机器来跑Go程序。然后，你需要有一个Go环境，即你需要安装Go（废话）。</p>\n<p>为了这个教程，我们先在GOPATH里创建一个文件夹，并用cd命令进入里面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir gowiki</div><div class=\"line\">$ cd gowiki</div></pre></td></tr></table></figure>\n<p>而后创建一个名为wiki.go的文件，用你最中意的编辑器打开它，并在里面加上以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>以上我们从Go的标准库中导入了fmt和ioutil包。而之后我们会用import声明来引入更多的包，如果我们要实现更多额外的功能的话。</p>\n<h2 id=\"数据结构体\"><a href=\"#数据结构体\" class=\"headerlink\" title=\"数据结构体\"></a>数据结构体</h2><p>现在我们开始定义一个结构体。想象一下，一个wiki应该有什么？它应该有一堆互有关系（互含链接）的网页Page，而后每个网页Page都起码有一个标题Title和主体Body，主体就是内容。因此我们先定义一个网页Page的结构，它有一个标题域和主体域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">type Page struct &#123;</div><div class=\"line\">    Title string</div><div class=\"line\">    Body  []byte</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中[]byte是“比特切片”的意思，不选用string而选用[]byte，是因为我们会在io库中用到[]byte类型，接下来你会看到的。</p>\n<p>Page结构体描述了网页的数据存储在内存中的形式，然而持久化存储呢？我们可以为Page创建一个save方法来实现存储：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (p *Page) save() error &#123;</div><div class=\"line\">    filename := p.Title + &quot;.txt&quot;</div><div class=\"line\">    return ioutil.WriteFile(filename, p.Body, 0600)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的声明<code>func (p *Page) save() error{}</code>表明了这个方法名为save，属于p，即Page指针类型可调用的方法，而且它不需要传入任何参数，而后返回一个error类型的值。</p>\n<p>这个方法会将网页的主体保存到一个txt文件中，而方便起见，我们选用这个网页的Title项作为这个txt文件的名字。而这个save方法返回一个error类型是因为error也是WriteFile的返回类型（WriteFile是一个用于将[]byte写入文件的标准库函数），当然这样返回error也是为了能让程序在写文件时发生错误后处理好。而大多数情况是一切安好，没有故障，这样Page.save()就会返回一个nil（nil是指针、接口或其他类型的”零值“）。</p>\n<p>如果你足够细心的话，你会发现WriteFile的第三个参数很奇怪。这个一个八进制数字0600，表明了这个txt文件只对于当前用户，是以具有可读写权限的方式打开的（p.s. 不懂为啥是600的可以看一下Unix/Linux的权限的表达方式）。</p>\n<p>有了存储save()方法，对应的也应该有读取的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">func loadPage(title string) *Page &#123;</div><div class=\"line\">    filename := title + &quot;.txt&quot;</div><div class=\"line\">    body, _ := ioutil.ReadFile(filename)</div><div class=\"line\">    return &amp;Page&#123;Title: title, Body: body&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>loadPage的思想很简单：读取与title有相应名字的txt文件，将文件的内容赋值给变量body，而后返回一个带有Title和Body的Page结构体实例的指针。</p>\n<p>首先我们得知道函数是可以返回多个返回值的。而标准库函数io.ReadFile返回了[]byte和error两个类型的值。当然这个简单的loadPage，并没有对错误进行处理 —— 上述代码使用了空标识符，即下划线_，用于抛弃这个error返回值（本质上，这样就是将变量分配到空，就是抛弃）。</p>\n<p>但是问题很严重 —— 如果有error了应该怎么办？举个例子，可能这个txt文件并不存在，总不能抛弃吧。因此我们不能坐视不理，我们应该修改一下这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func loadPage(title string) (*Page, error) &#123;</div><div class=\"line\">    filename := title + &quot;.txt&quot;</div><div class=\"line\">    body, err := ioutil.ReadFile(filename)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return nil, err</div><div class=\"line\">    &#125;</div><div class=\"line\">    return &amp;Page&#123;Title: title, Body: body&#125;, nil</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在这个方法的调用者就可以检测一下第二返回值是否为空，以此来检测是否成功读取到Page了。</p>\n<p>而在这个moment，我们已经有一些简单的数据结构和读取页面的方法了。我们可以着手于写一个main来测试一下我们写的有没有错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    p1 := &amp;Page&#123;Title: &quot;TestPage&quot;, Body: []byte(&quot;This is a sample Page.&quot;)&#125;</div><div class=\"line\">    p1.save()</div><div class=\"line\">    p2, _ := loadPage(&quot;TestPage&quot;)</div><div class=\"line\">    fmt.Println(string(p2.Body))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码编译和执行完后，一个名为TestPage.txt、包含着p1内容的文件将会被创建出来。而后这个文件会被p2这个结构体读取，而后这个p2结构体的Body内容将会被输出到屏幕上。</p>\n<p>好，现在我们可以编译和运行了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go build wiki.go</div><div class=\"line\">$ ./wiki</div><div class=\"line\">This is a sample page.</div></pre></td></tr></table></figure>\n<p>（如果你是windows上跑的，运行的时候直接打”wiki”就行，不需要“./”了。）</p>\n<h2 id=\"介绍一下net-http包\"><a href=\"#介绍一下net-http包\" class=\"headerlink\" title=\"介绍一下net/http包\"></a>介绍一下net/http包</h2><p>以下是一个简单的web服务器程序例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;net/http&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">func handler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    fmt.Fprintf(w, &quot;Hi there, I love %s!&quot;, r.URL.Path[1:])</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/&quot;, handler)</div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>main函数一开始就调用了http.HandleFunc，这个函数就是告诉http包，将web服务器所有/下的请求交给handler处理。接着main函数又调用了http.ListenAndServe，目的就是指定8080端口（先不用管那个第二个参数nil），这个ListenAndServe会一直阻塞整个程序，直到程序被终止。</p>\n<p>函数handler的类型是http.HandlerFunc，它需要两个参数，http.ResponseWriter和http.Request。http.ResponseWriter变量的作用就是回应HTTP请求，向它写入一些东西即向HTTP客户端发送一些东西。而http.Request是一个代表了HTTP客户请求的数据结构。handler中的r.URL.Path是请求URL的路径部分，紧跟着的[1:]是对路径的一个切片动作，即返回r.URL.Path的第一个字符到结尾的切片，在这里，实际意味着除去/符号，只要后面的。</p>\n<p>如果你运行该程序，并访问以下地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:8080/monkeys</div></pre></td></tr></table></figure>\n<p>这个程序就会在终端中输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi there, I love monkeys!</div></pre></td></tr></table></figure>\n<h2 id=\"将wiki和net-http包合并使用\"><a href=\"#将wiki和net-http包合并使用\" class=\"headerlink\" title=\"将wiki和net/http包合并使用\"></a>将wiki和net/http包合并使用</h2><p>想要使用net/http包，我们必须先将它导入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>而后我们创建一个handler，叫做viewHandler，它可允许用户访问wiki的页面，它会处理前缀是/view/的URL。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, _ := loadPage(title)</div><div class=\"line\">    fmt.Fprintf(w, &quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;, p.Title, p.Body)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，函数先在请求URL的路径部分，即r.URL.Path中提取页面的title。路径被[len(“/view/“):]重新切片了一下，为的就是除掉请求URL中/view/的部分，这是因为/view/并不是page的名称。而后函数读取这个txt文件，然后将内容格式转换为的string形式的简单的HTML，继而将这个string写到w，即http.ResponseWriter。</p>\n<p>同样这里需要注意一下这个<em>，这里的</em>也是直接忽略了loadPage的error返回值，这样做仅是为了程序的简单易懂，而这样忽略通常是极其不好的习惯。我们迟点再对这里进行修改（其实，很多时候都是说迟点再改然后就忘了- -）。</p>\n<p>要使用这个handler，我们需要重写一下我们的main函数中的http初始化部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/view/&quot;, viewHandler)</div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们手动创建一下txt文件（比如说test.txt，用编辑器在里面写句Hello world），然后编译一下我们的代码并运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go build wiki.go</div><div class=\"line\">$ ./wiki</div></pre></td></tr></table></figure>\n<p>接着你就可以在浏览器访问<a href=\"http://localhost:8080/view/test看看是不是有一个Hello\" target=\"_blank\" rel=\"external\">http://localhost:8080/view/test看看是不是有一个Hello</a> world，或者是你自己自定义的启动txt文件内容。</p>\n<h2 id=\"wiki的编辑页面\"><a href=\"#wiki的编辑页面\" class=\"headerlink\" title=\"wiki的编辑页面\"></a>wiki的编辑页面</h2><p>不能编辑wiki页面的wiki不是一个好wiki。因此，我们需要额外创建两个handler，一个叫做editHandler，用来显示一个wiki的编辑页面，另一个handler叫saveHandler，用来通过提交的表单保存<br>数据。</p>\n<p>首先，我们先将一下这些添加到main：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/view/&quot;, viewHandler)</div><div class=\"line\">    http.HandleFunc(&quot;/edit/&quot;, editHandler)</div><div class=\"line\">    http.HandleFunc(&quot;/save/&quot;, saveHandler)</div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而后以下的函数editHandler将会载入页面（或者如果这个页面不存在的话，创建一个新的页面结构），然后在浏览器显示这个编辑的表单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/edit/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    fmt.Fprintf(w, &quot;&lt;h1&gt;Editing %s&lt;/h1&gt;&quot;+</div><div class=\"line\">        &quot;&lt;form action=\\&quot;/save/%s\\&quot; method=\\&quot;POST\\&quot;&gt;&quot;+</div><div class=\"line\">        &quot;&lt;textarea name=\\&quot;body\\&quot;&gt;%s&lt;/textarea&gt;&lt;br&gt;&quot;+</div><div class=\"line\">        &quot;&lt;input type=\\&quot;submit\\&quot; value=\\&quot;Save\\&quot;&gt;&quot;+</div><div class=\"line\">        &quot;&lt;/form&gt;&quot;,</div><div class=\"line\">        p.Title, p.Title, p.Body)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样的代码是没有问题的，它能正常运行，但是，这样的硬编码HTML实在是太难看了，我们需要一种“优雅”的输出HTML的方式。</p>\n<h2 id=\"使用html-template包优雅地输出HTML\"><a href=\"#使用html-template包优雅地输出HTML\" class=\"headerlink\" title=\"使用html/template包优雅地输出HTML\"></a>使用html/template包优雅地输出HTML</h2><p>html/template包属于Go标准库。使用这个包，我们就可以分离HTML到一个单独的HTML文件，这样我们在修改编辑页面的布局时，就不用再Go代码里面修改了。</p>\n<p>首先，我们还是先在import列表中加入我们要导入的html/template，同时，这一次我们不再想要用fmt将内容输出到屏幕了，我们将fmt去掉：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import (</div><div class=\"line\">\t&quot;html/template&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>接下来，我们创建一个包含了HTML表单的模板 —— 新建一个名为edit.html的文件并添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;Editing &#123;&#123;.Title&#125;&#125;&lt;/h1&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;/save/&#123;&#123;.Title&#125;&#125;&quot; method=&quot;POST&quot;&gt;</div><div class=\"line\">&lt;div&gt;&lt;textarea name=&quot;body&quot; rows=&quot;20&quot; cols=&quot;80&quot;&gt;&#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;&lt;/textarea&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>修改editHandler，将硬编码HTML替换为使用模板：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/edit/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    t, _ := template.ParseFiles(&quot;edit.html&quot;)</div><div class=\"line\">    t.Execute(w, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>template.ParseFiles函数会读取edit.html内容，并返回一个模板的指针*template.Template。而t.Execute函数则是将内容写入模板而后生成HTML到http.ResponseWriter。模板中.Title和.Body中使用的点就是指传入的对象的对应属性，在这里指p.Title和p.Body。</p>\n<p>模板中的变量要使用双花括号套住。而模板中的指令<code>printf &quot;%s&quot; .Body</code>，则是一个以string形式而不是bytes串形式输出Body值的函数调用，这样就相当于fmt.Printf函数，只是一个是输出于浏览器页面上，另一个输出于终端上。</p>\n<p>html/template包可以帮我们通过模板生成安全的、正确的HTML代码。比如说，它能自动帮你转换大于号（&gt;），就是自动地帮你替换<code>&amp;gt;</code>，这样就保证用户数据不会对HTML表单造成干扰。</p>\n<p>既然我们已经在使用模板了，我们就继续用模板的这个套路来创建我们的view.html以及调用它的viewHandler。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&#123;&#123;.Title&#125;&#125;&lt;/h1&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;p&gt;[&lt;a href=&quot;/edit/&#123;&#123;.Title&#125;&#125;&quot;&gt;edit&lt;/a&gt;]&lt;/p&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;div&gt;&#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>修改viewHandler：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, _ := loadPage(title)</div><div class=\"line\">    t, _ := template.ParseFiles(&quot;view.html&quot;)</div><div class=\"line\">    t.Execute(w, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>好，该重点细节的时候来了。你看，我们两个handler都有相同的代码来渲染HTML，一个合格的程序员看到这种情况应该要将重复的部分模块化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">    t, _ := template.ParseFiles(tmpl + &quot;.html&quot;)</div><div class=\"line\">    t.Execute(w, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后两个handler就变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, _ := loadPage(title)</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/edit/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不要觉得代码反而变长了就不重要，甚至嘲笑，重要的是思想:)</p>\n<h2 id=\"处理好不存在的页面\"><a href=\"#处理好不存在的页面\" class=\"headerlink\" title=\"处理好不存在的页面\"></a>处理好不存在的页面</h2><p>如果你去访问/view/APageThatDoesntExist这样一个不存在的页面（假设他不存在），会发生什么？如果是上述代码的Web应用，你应该会看到一个包含着HTML的页面，这是因为我们在loadPage中忽略了文件不存在时的错误处理（这事终于被提上日程了），于是这样地读文件，它只读了个空。其实，如果请求的页面不存在，这样的请求就应该被重定向到编辑页面，这样用户就可以创建一个新的文件了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>http.Redirect函数参数包含了一个状态码http.StatusFound (302)，以及一个响应的目标地址。</p>\n<h2 id=\"保存页面\"><a href=\"#保存页面\" class=\"headerlink\" title=\"保存页面\"></a>保存页面</h2><p>函数saveHandler将会处理好编辑页面中表单的子任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/save/&quot;):]</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    p.save()</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>页面标题（由URL提供）以及Body都会被保存在新的Page实例中。然后save()函数的调用就是要将数据写入到一个文件中，然后客户端就被重定向到/view/中对应的页面。</p>\n<p>其中函数FormValue()的返回值是string类型，我们需要将它转换为[]byte类型，这样才能用它来生成新的Page结构体实例。我们使用<code>[]byte(body)</code>来实现这个转换。</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>我们的程序有几处地方忽略了不该忽略的错误，这是一个坏习惯，尤其是程序发生了你意想不到的错误的时候，你更会后悔莫及。一个较好的处理方案就是先程序自行处理好错误，然后将错误信息发送给用户。按照这样的方案，我们的应用必然会和我们预料的一样执行，并在有问题的时候通知用户。</p>\n<p>首先，我们需要在我们刚才分离出来的renderTemplate里面添加处理信息的代码（模块化的好处开始凸显）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">    t, err := template.ParseFiles(tmpl + &quot;.html&quot;)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    err = t.Execute(w, p)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>http.Error函数会给用户发送一个特定的状态码（这里是Internal Server Error）和错误信息。然后我们继续以同样的方法修改saveHandler：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/save/&quot;):]</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    err := p.save()</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当p.save()执行时发生了错误，就会调用http.Error，用户就会得知此错误信息。</p>\n<h2 id=\"模板的缓存\"><a href=\"#模板的缓存\" class=\"headerlink\" title=\"模板的缓存\"></a>模板的缓存</h2><p>当然这个简单的web应用还是不够高效，怎么个不够高效法呢？就是没有缓存，每次用户查看页面，Go程序都需要读取数据并重新渲染一下模板。也就是说，renderTemplate每次都调用ParseFiles。我们对其进行优化，比较好的方案是在程序初始化的时候调用ParseFiles一次，然后将所有模板都赋值到一个*Template里面，我们之后就用ExecuteTemplate来渲染特定的模板了。</p>\n<p>首先我们先用ParseFiles函数初始化一个全局变量，名为templates：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var templates = template.Must(template.ParseFiles(&quot;edit.html&quot;, &quot;view.html&quot;))</div></pre></td></tr></table></figure>\n<p>template.Must是个封装好的函数，它会在Parse返回err不为nil时，调用panic，而其他情况下，它会照常返回Template指针。Must的引入允许我们不用显式地处理错误，而我们只关注这个业务功能而忽略它还会返回一个错误。而panic在这里也用得较为合适 —— 如果模板都不能被加载了，那么能做得好的事就只能是退出程序了。</p>\n<p>ParseFiles函数的参数是任意数量的string，这些string对应着我们的模板文件。然后这些模板都会按照文件的命名加载到templates中。当然如果我们要添加更多的模板文件，我们只需要将它们的名字加到ParseFiles的参数里面。</p>\n<p>然后我们正式地对renderTemplate进行修改，改成调用templates.ExecuteTemplate的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">    err := templates.ExecuteTemplate(w, tmpl+&quot;.html&quot;, p)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>p.s.记得加上.html哦。</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>其实如果你足够细心，你会发现一个安全隐患问题：用户可以在服务器应用下的任意路径做读取和修改。为了尽可能避免这个安全隐患，我们写一个函数，它可以用正则表达式来验证title的合法性。</p>\n<p>首先我们先将regexp加入到import列表中，然后我们需要创建一个全局变量来存储我们需要用到的表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var validPath = regexp.MustCompile(&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;)</div></pre></td></tr></table></figure>\n<p>在这里，我们看到了熟悉的身影Must：regexp.MustCompile，它负责转换和遍历正则表达式，然后返回一个regexp.Regexp类型的变量。类似的，MustCompile和Compile这个妖艳贱货不一样，Must在处理失败的时候会返回一个panic。</p>\n<p>然后，我们可以开始写一个函数，它专门用于验证validPath的正确性并从中提取文件的title：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func getTitle(w http.ResponseWriter, r *http.Request) (string, error) &#123;</div><div class=\"line\">    m := validPath.FindStringSubmatch(r.URL.Path)</div><div class=\"line\">    if m == nil &#123;</div><div class=\"line\">        http.NotFound(w, r)</div><div class=\"line\">        return &quot;&quot;, errors.New(&quot;Invalid Page Title&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return m[2], nil // The title is the second subexpression.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果路径合法，它会带着一个nil值返回（第二个返回值）；如果路径不合法，函数就会将“404 Not Found”写进HTTP连接，然后给handler返回一个error。当然，为了可以新建error，我们需要import一下errors包。</p>\n<p>然后我们修改所有handler，让它们在里面调用getTitle来验证合法性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title, err := getTitle(w, r)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title, err := getTitle(w, r)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title, err := getTitle(w, r)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    err = p.save()</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>心细的你又再次发现，为了捕捉和处理各种错误，我们使用了很多代码，而且还是很多重复的代码，那么我们能不能做点什么呢？也许抽象函数能帮得到我们。</p>\n<p>首先，我们重写一下handler的函数定义（以同样的形式，整齐的参数）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request, title string)</div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request, title string)</div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request, title string)</div></pre></td></tr></table></figure>\n<p>接下来我们定义一个包装函数，它需要的参数类型是<em>上面我们声明的函数类型</em>，即<code>func (http.ResponseWriter, *http.Request, string)</code>，然后返回一个http.HandlerFunc类型的函数，这个包装函数的大致框架如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc &#123;</div><div class=\"line\">\treturn func(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">\t\t// Here we will extract the page title from the Request,</div><div class=\"line\">\t\t// and call the provided handler &apos;fn&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述函数return了一个函数自己内部定义的函数，称为闭包。在这里，变量fn（即makeHandler唯一的参数）被闭包直接用了，而fn可以是我们的view、save或者edit的handler。</p>\n<p>然后我们可以开始着手于闭包里面的实现，我们可以借用getTitle的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc &#123;</div><div class=\"line\">    return func(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">        m := validPath.FindStringSubmatch(r.URL.Path)</div><div class=\"line\">        if m == nil &#123;</div><div class=\"line\">            http.NotFound(w, r)</div><div class=\"line\">            return</div><div class=\"line\">        &#125;</div><div class=\"line\">        fn(w, r, m[2])</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>makeHandler返回的闭包是带有http.ResponseWriter和http.Request参数的函数。而在这里，闭包在请求路径中提取了title，然后使用TitleValidator正则来检验合法性。如果不合法，它将会向ResponseWriter 用http.NotFound函数写入一个error；如果合法，函数将会用ResponseWriter、Request和title三个参数来调用fn。</p>\n<p>然后我们就可以在main函数里面包装我们的handler了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/view/&quot;, makeHandler(viewHandler))</div><div class=\"line\">    http.HandleFunc(&quot;/edit/&quot;, makeHandler(editHandler))</div><div class=\"line\">    http.HandleFunc(&quot;/save/&quot;, makeHandler(saveHandler))</div><div class=\"line\"></div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们去掉先前的getTitle，让handler变得苗条点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    err := p.save()</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"最终再试一下\"><a href=\"#最终再试一下\" class=\"headerlink\" title=\"最终再试一下\"></a>最终再试一下</h2><p>重新编译运行试试？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go build wiki.go</div><div class=\"line\">$ ./wiki</div></pre></td></tr></table></figure>\n<p>试试运行访问<a href=\"http://localhost:8080/view/ANewPage，看看会怎么样？它应该会给出一个新的编辑页面，然后你可以输入一些内容，你可以保存，在保存后它会将你重定向到新的wiki页面~\" target=\"_blank\" rel=\"external\">http://localhost:8080/view/ANewPage，看看会怎么样？它应该会给出一个新的编辑页面，然后你可以输入一些内容，你可以保存，在保存后它会将你重定向到新的wiki页面~</a></p>\n<h3 id=\"P-S-如果你很混乱，那么我附上最终的全部代码？\"><a href=\"#P-S-如果你很混乱，那么我附上最终的全部代码？\" class=\"headerlink\" title=\"P.S.如果你很混乱，那么我附上最终的全部代码？\"></a>P.S.如果你很混乱，那么我附上最终的全部代码？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Copyright 2010 The Go Authors. All rights reserved.</div><div class=\"line\">// Use of this source code is governed by a BSD-style</div><div class=\"line\">// license that can be found in the LICENSE file.</div><div class=\"line\"></div><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;html/template&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">\t&quot;regexp&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Page struct &#123;</div><div class=\"line\">\tTitle string</div><div class=\"line\">\tBody  []byte</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (p *Page) save() error &#123;</div><div class=\"line\">\tfilename := p.Title + &quot;.txt&quot;</div><div class=\"line\">\treturn ioutil.WriteFile(filename, p.Body, 0600)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func loadPage(title string) (*Page, error) &#123;</div><div class=\"line\">\tfilename := title + &quot;.txt&quot;</div><div class=\"line\">\tbody, err := ioutil.ReadFile(filename)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn nil, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &amp;Page&#123;Title: title, Body: body&#125;, nil</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">\tp, err := loadPage(title)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\thttp.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">\t\treturn</div><div class=\"line\">\t&#125;</div><div class=\"line\">\trenderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">\tp, err := loadPage(title)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tp = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\trenderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">\tbody := r.FormValue(&quot;body&quot;)</div><div class=\"line\">\tp := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">\terr := p.save()</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">\t\treturn</div><div class=\"line\">\t&#125;</div><div class=\"line\">\thttp.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var templates = template.Must(template.ParseFiles(&quot;edit.html&quot;, &quot;view.html&quot;))</div><div class=\"line\"></div><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">\terr := templates.ExecuteTemplate(w, tmpl+&quot;.html&quot;, p)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var validPath = regexp.MustCompile(&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;)</div><div class=\"line\"></div><div class=\"line\">func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc &#123;</div><div class=\"line\">\treturn func(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">\t\tm := validPath.FindStringSubmatch(r.URL.Path)</div><div class=\"line\">\t\tif m == nil &#123;</div><div class=\"line\">\t\t\thttp.NotFound(w, r)</div><div class=\"line\">\t\t\treturn</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfn(w, r, m[2])</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\">\thttp.HandleFunc(&quot;/view/&quot;, makeHandler(viewHandler))</div><div class=\"line\">\thttp.HandleFunc(&quot;/edit/&quot;, makeHandler(editHandler))</div><div class=\"line\">\thttp.HandleFunc(&quot;/save/&quot;, makeHandler(saveHandler))</div><div class=\"line\"></div><div class=\"line\">\thttp.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介和要求\"><a href=\"#简介和要求\" class=\"headerlink\" title=\"简介和要求\"></a>简介和要求</h2><p>教程将涵盖以下知识：</p>\n<ul>\n<li>创建一个带有load和save方法的数据结构体</li>\n<li>使用net/http包来创建web应用</li>\n<li>使用html/template包来处理HTML模板</li>\n<li>使用regexp包来检测用户的输入</li>\n<li>使用闭包</li>\n</ul>\n<p>假设你已经有以下知识：</p>\n<ul>\n<li>编程经验</li>\n<li>明白基础的web知识（HTTP，HTML）</li>\n<li>具有些UNIX、DOS的命令行知识</li>\n</ul>","more":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>首先，你需要有一个装了FreeBSD、Linux、MacOS甚至是Windows系统的机器来跑Go程序。然后，你需要有一个Go环境，即你需要安装Go（废话）。</p>\n<p>为了这个教程，我们先在GOPATH里创建一个文件夹，并用cd命令进入里面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir gowiki</div><div class=\"line\">$ cd gowiki</div></pre></td></tr></table></figure>\n<p>而后创建一个名为wiki.go的文件，用你最中意的编辑器打开它，并在里面加上以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>以上我们从Go的标准库中导入了fmt和ioutil包。而之后我们会用import声明来引入更多的包，如果我们要实现更多额外的功能的话。</p>\n<h2 id=\"数据结构体\"><a href=\"#数据结构体\" class=\"headerlink\" title=\"数据结构体\"></a>数据结构体</h2><p>现在我们开始定义一个结构体。想象一下，一个wiki应该有什么？它应该有一堆互有关系（互含链接）的网页Page，而后每个网页Page都起码有一个标题Title和主体Body，主体就是内容。因此我们先定义一个网页Page的结构，它有一个标题域和主体域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">type Page struct &#123;</div><div class=\"line\">    Title string</div><div class=\"line\">    Body  []byte</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中[]byte是“比特切片”的意思，不选用string而选用[]byte，是因为我们会在io库中用到[]byte类型，接下来你会看到的。</p>\n<p>Page结构体描述了网页的数据存储在内存中的形式，然而持久化存储呢？我们可以为Page创建一个save方法来实现存储：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (p *Page) save() error &#123;</div><div class=\"line\">    filename := p.Title + &quot;.txt&quot;</div><div class=\"line\">    return ioutil.WriteFile(filename, p.Body, 0600)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法的声明<code>func (p *Page) save() error{}</code>表明了这个方法名为save，属于p，即Page指针类型可调用的方法，而且它不需要传入任何参数，而后返回一个error类型的值。</p>\n<p>这个方法会将网页的主体保存到一个txt文件中，而方便起见，我们选用这个网页的Title项作为这个txt文件的名字。而这个save方法返回一个error类型是因为error也是WriteFile的返回类型（WriteFile是一个用于将[]byte写入文件的标准库函数），当然这样返回error也是为了能让程序在写文件时发生错误后处理好。而大多数情况是一切安好，没有故障，这样Page.save()就会返回一个nil（nil是指针、接口或其他类型的”零值“）。</p>\n<p>如果你足够细心的话，你会发现WriteFile的第三个参数很奇怪。这个一个八进制数字0600，表明了这个txt文件只对于当前用户，是以具有可读写权限的方式打开的（p.s. 不懂为啥是600的可以看一下Unix/Linux的权限的表达方式）。</p>\n<p>有了存储save()方法，对应的也应该有读取的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">func loadPage(title string) *Page &#123;</div><div class=\"line\">    filename := title + &quot;.txt&quot;</div><div class=\"line\">    body, _ := ioutil.ReadFile(filename)</div><div class=\"line\">    return &amp;Page&#123;Title: title, Body: body&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>loadPage的思想很简单：读取与title有相应名字的txt文件，将文件的内容赋值给变量body，而后返回一个带有Title和Body的Page结构体实例的指针。</p>\n<p>首先我们得知道函数是可以返回多个返回值的。而标准库函数io.ReadFile返回了[]byte和error两个类型的值。当然这个简单的loadPage，并没有对错误进行处理 —— 上述代码使用了空标识符，即下划线_，用于抛弃这个error返回值（本质上，这样就是将变量分配到空，就是抛弃）。</p>\n<p>但是问题很严重 —— 如果有error了应该怎么办？举个例子，可能这个txt文件并不存在，总不能抛弃吧。因此我们不能坐视不理，我们应该修改一下这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func loadPage(title string) (*Page, error) &#123;</div><div class=\"line\">    filename := title + &quot;.txt&quot;</div><div class=\"line\">    body, err := ioutil.ReadFile(filename)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return nil, err</div><div class=\"line\">    &#125;</div><div class=\"line\">    return &amp;Page&#123;Title: title, Body: body&#125;, nil</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在这个方法的调用者就可以检测一下第二返回值是否为空，以此来检测是否成功读取到Page了。</p>\n<p>而在这个moment，我们已经有一些简单的数据结构和读取页面的方法了。我们可以着手于写一个main来测试一下我们写的有没有错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    p1 := &amp;Page&#123;Title: &quot;TestPage&quot;, Body: []byte(&quot;This is a sample Page.&quot;)&#125;</div><div class=\"line\">    p1.save()</div><div class=\"line\">    p2, _ := loadPage(&quot;TestPage&quot;)</div><div class=\"line\">    fmt.Println(string(p2.Body))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码编译和执行完后，一个名为TestPage.txt、包含着p1内容的文件将会被创建出来。而后这个文件会被p2这个结构体读取，而后这个p2结构体的Body内容将会被输出到屏幕上。</p>\n<p>好，现在我们可以编译和运行了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go build wiki.go</div><div class=\"line\">$ ./wiki</div><div class=\"line\">This is a sample page.</div></pre></td></tr></table></figure>\n<p>（如果你是windows上跑的，运行的时候直接打”wiki”就行，不需要“./”了。）</p>\n<h2 id=\"介绍一下net-http包\"><a href=\"#介绍一下net-http包\" class=\"headerlink\" title=\"介绍一下net/http包\"></a>介绍一下net/http包</h2><p>以下是一个简单的web服务器程序例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;net/http&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">func handler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    fmt.Fprintf(w, &quot;Hi there, I love %s!&quot;, r.URL.Path[1:])</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/&quot;, handler)</div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>main函数一开始就调用了http.HandleFunc，这个函数就是告诉http包，将web服务器所有/下的请求交给handler处理。接着main函数又调用了http.ListenAndServe，目的就是指定8080端口（先不用管那个第二个参数nil），这个ListenAndServe会一直阻塞整个程序，直到程序被终止。</p>\n<p>函数handler的类型是http.HandlerFunc，它需要两个参数，http.ResponseWriter和http.Request。http.ResponseWriter变量的作用就是回应HTTP请求，向它写入一些东西即向HTTP客户端发送一些东西。而http.Request是一个代表了HTTP客户请求的数据结构。handler中的r.URL.Path是请求URL的路径部分，紧跟着的[1:]是对路径的一个切片动作，即返回r.URL.Path的第一个字符到结尾的切片，在这里，实际意味着除去/符号，只要后面的。</p>\n<p>如果你运行该程序，并访问以下地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:8080/monkeys</div></pre></td></tr></table></figure>\n<p>这个程序就会在终端中输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi there, I love monkeys!</div></pre></td></tr></table></figure>\n<h2 id=\"将wiki和net-http包合并使用\"><a href=\"#将wiki和net-http包合并使用\" class=\"headerlink\" title=\"将wiki和net/http包合并使用\"></a>将wiki和net/http包合并使用</h2><p>想要使用net/http包，我们必须先将它导入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>而后我们创建一个handler，叫做viewHandler，它可允许用户访问wiki的页面，它会处理前缀是/view/的URL。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, _ := loadPage(title)</div><div class=\"line\">    fmt.Fprintf(w, &quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;, p.Title, p.Body)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先，函数先在请求URL的路径部分，即r.URL.Path中提取页面的title。路径被[len(“/view/“):]重新切片了一下，为的就是除掉请求URL中/view/的部分，这是因为/view/并不是page的名称。而后函数读取这个txt文件，然后将内容格式转换为的string形式的简单的HTML，继而将这个string写到w，即http.ResponseWriter。</p>\n<p>同样这里需要注意一下这个<em>，这里的</em>也是直接忽略了loadPage的error返回值，这样做仅是为了程序的简单易懂，而这样忽略通常是极其不好的习惯。我们迟点再对这里进行修改（其实，很多时候都是说迟点再改然后就忘了- -）。</p>\n<p>要使用这个handler，我们需要重写一下我们的main函数中的http初始化部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/view/&quot;, viewHandler)</div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们手动创建一下txt文件（比如说test.txt，用编辑器在里面写句Hello world），然后编译一下我们的代码并运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go build wiki.go</div><div class=\"line\">$ ./wiki</div></pre></td></tr></table></figure>\n<p>接着你就可以在浏览器访问<a href=\"http://localhost:8080/view/test看看是不是有一个Hello\">http://localhost:8080/view/test看看是不是有一个Hello</a> world，或者是你自己自定义的启动txt文件内容。</p>\n<h2 id=\"wiki的编辑页面\"><a href=\"#wiki的编辑页面\" class=\"headerlink\" title=\"wiki的编辑页面\"></a>wiki的编辑页面</h2><p>不能编辑wiki页面的wiki不是一个好wiki。因此，我们需要额外创建两个handler，一个叫做editHandler，用来显示一个wiki的编辑页面，另一个handler叫saveHandler，用来通过提交的表单保存<br>数据。</p>\n<p>首先，我们先将一下这些添加到main：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/view/&quot;, viewHandler)</div><div class=\"line\">    http.HandleFunc(&quot;/edit/&quot;, editHandler)</div><div class=\"line\">    http.HandleFunc(&quot;/save/&quot;, saveHandler)</div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而后以下的函数editHandler将会载入页面（或者如果这个页面不存在的话，创建一个新的页面结构），然后在浏览器显示这个编辑的表单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/edit/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    fmt.Fprintf(w, &quot;&lt;h1&gt;Editing %s&lt;/h1&gt;&quot;+</div><div class=\"line\">        &quot;&lt;form action=\\&quot;/save/%s\\&quot; method=\\&quot;POST\\&quot;&gt;&quot;+</div><div class=\"line\">        &quot;&lt;textarea name=\\&quot;body\\&quot;&gt;%s&lt;/textarea&gt;&lt;br&gt;&quot;+</div><div class=\"line\">        &quot;&lt;input type=\\&quot;submit\\&quot; value=\\&quot;Save\\&quot;&gt;&quot;+</div><div class=\"line\">        &quot;&lt;/form&gt;&quot;,</div><div class=\"line\">        p.Title, p.Title, p.Body)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样的代码是没有问题的，它能正常运行，但是，这样的硬编码HTML实在是太难看了，我们需要一种“优雅”的输出HTML的方式。</p>\n<h2 id=\"使用html-template包优雅地输出HTML\"><a href=\"#使用html-template包优雅地输出HTML\" class=\"headerlink\" title=\"使用html/template包优雅地输出HTML\"></a>使用html/template包优雅地输出HTML</h2><p>html/template包属于Go标准库。使用这个包，我们就可以分离HTML到一个单独的HTML文件，这样我们在修改编辑页面的布局时，就不用再Go代码里面修改了。</p>\n<p>首先，我们还是先在import列表中加入我们要导入的html/template，同时，这一次我们不再想要用fmt将内容输出到屏幕了，我们将fmt去掉：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">import (</div><div class=\"line\">\t&quot;html/template&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p>接下来，我们创建一个包含了HTML表单的模板 —— 新建一个名为edit.html的文件并添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;Editing &#123;&#123;.Title&#125;&#125;&lt;/h1&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;form action=&quot;/save/&#123;&#123;.Title&#125;&#125;&quot; method=&quot;POST&quot;&gt;</div><div class=\"line\">&lt;div&gt;&lt;textarea name=&quot;body&quot; rows=&quot;20&quot; cols=&quot;80&quot;&gt;&#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;&lt;/textarea&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p>修改editHandler，将硬编码HTML替换为使用模板：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/edit/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    t, _ := template.ParseFiles(&quot;edit.html&quot;)</div><div class=\"line\">    t.Execute(w, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>template.ParseFiles函数会读取edit.html内容，并返回一个模板的指针*template.Template。而t.Execute函数则是将内容写入模板而后生成HTML到http.ResponseWriter。模板中.Title和.Body中使用的点就是指传入的对象的对应属性，在这里指p.Title和p.Body。</p>\n<p>模板中的变量要使用双花括号套住。而模板中的指令<code>printf &quot;%s&quot; .Body</code>，则是一个以string形式而不是bytes串形式输出Body值的函数调用，这样就相当于fmt.Printf函数，只是一个是输出于浏览器页面上，另一个输出于终端上。</p>\n<p>html/template包可以帮我们通过模板生成安全的、正确的HTML代码。比如说，它能自动帮你转换大于号（&gt;），就是自动地帮你替换<code>&amp;gt;</code>，这样就保证用户数据不会对HTML表单造成干扰。</p>\n<p>既然我们已经在使用模板了，我们就继续用模板的这个套路来创建我们的view.html以及调用它的viewHandler。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;h1&gt;&#123;&#123;.Title&#125;&#125;&lt;/h1&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;p&gt;[&lt;a href=&quot;/edit/&#123;&#123;.Title&#125;&#125;&quot;&gt;edit&lt;/a&gt;]&lt;/p&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;div&gt;&#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>修改viewHandler：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, _ := loadPage(title)</div><div class=\"line\">    t, _ := template.ParseFiles(&quot;view.html&quot;)</div><div class=\"line\">    t.Execute(w, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>好，该重点细节的时候来了。你看，我们两个handler都有相同的代码来渲染HTML，一个合格的程序员看到这种情况应该要将重复的部分模块化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">    t, _ := template.ParseFiles(tmpl + &quot;.html&quot;)</div><div class=\"line\">    t.Execute(w, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后两个handler就变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, _ := loadPage(title)</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/edit/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不要觉得代码反而变长了就不重要，甚至嘲笑，重要的是思想:)</p>\n<h2 id=\"处理好不存在的页面\"><a href=\"#处理好不存在的页面\" class=\"headerlink\" title=\"处理好不存在的页面\"></a>处理好不存在的页面</h2><p>如果你去访问/view/APageThatDoesntExist这样一个不存在的页面（假设他不存在），会发生什么？如果是上述代码的Web应用，你应该会看到一个包含着HTML的页面，这是因为我们在loadPage中忽略了文件不存在时的错误处理（这事终于被提上日程了），于是这样地读文件，它只读了个空。其实，如果请求的页面不存在，这样的请求就应该被重定向到编辑页面，这样用户就可以创建一个新的文件了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/view/&quot;):]</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>http.Redirect函数参数包含了一个状态码http.StatusFound (302)，以及一个响应的目标地址。</p>\n<h2 id=\"保存页面\"><a href=\"#保存页面\" class=\"headerlink\" title=\"保存页面\"></a>保存页面</h2><p>函数saveHandler将会处理好编辑页面中表单的子任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/save/&quot;):]</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    p.save()</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>页面标题（由URL提供）以及Body都会被保存在新的Page实例中。然后save()函数的调用就是要将数据写入到一个文件中，然后客户端就被重定向到/view/中对应的页面。</p>\n<p>其中函数FormValue()的返回值是string类型，我们需要将它转换为[]byte类型，这样才能用它来生成新的Page结构体实例。我们使用<code>[]byte(body)</code>来实现这个转换。</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>我们的程序有几处地方忽略了不该忽略的错误，这是一个坏习惯，尤其是程序发生了你意想不到的错误的时候，你更会后悔莫及。一个较好的处理方案就是先程序自行处理好错误，然后将错误信息发送给用户。按照这样的方案，我们的应用必然会和我们预料的一样执行，并在有问题的时候通知用户。</p>\n<p>首先，我们需要在我们刚才分离出来的renderTemplate里面添加处理信息的代码（模块化的好处开始凸显）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">    t, err := template.ParseFiles(tmpl + &quot;.html&quot;)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    err = t.Execute(w, p)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>http.Error函数会给用户发送一个特定的状态码（这里是Internal Server Error）和错误信息。然后我们继续以同样的方法修改saveHandler：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title := r.URL.Path[len(&quot;/save/&quot;):]</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    err := p.save()</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当p.save()执行时发生了错误，就会调用http.Error，用户就会得知此错误信息。</p>\n<h2 id=\"模板的缓存\"><a href=\"#模板的缓存\" class=\"headerlink\" title=\"模板的缓存\"></a>模板的缓存</h2><p>当然这个简单的web应用还是不够高效，怎么个不够高效法呢？就是没有缓存，每次用户查看页面，Go程序都需要读取数据并重新渲染一下模板。也就是说，renderTemplate每次都调用ParseFiles。我们对其进行优化，比较好的方案是在程序初始化的时候调用ParseFiles一次，然后将所有模板都赋值到一个*Template里面，我们之后就用ExecuteTemplate来渲染特定的模板了。</p>\n<p>首先我们先用ParseFiles函数初始化一个全局变量，名为templates：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var templates = template.Must(template.ParseFiles(&quot;edit.html&quot;, &quot;view.html&quot;))</div></pre></td></tr></table></figure>\n<p>template.Must是个封装好的函数，它会在Parse返回err不为nil时，调用panic，而其他情况下，它会照常返回Template指针。Must的引入允许我们不用显式地处理错误，而我们只关注这个业务功能而忽略它还会返回一个错误。而panic在这里也用得较为合适 —— 如果模板都不能被加载了，那么能做得好的事就只能是退出程序了。</p>\n<p>ParseFiles函数的参数是任意数量的string，这些string对应着我们的模板文件。然后这些模板都会按照文件的命名加载到templates中。当然如果我们要添加更多的模板文件，我们只需要将它们的名字加到ParseFiles的参数里面。</p>\n<p>然后我们正式地对renderTemplate进行修改，改成调用templates.ExecuteTemplate的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">    err := templates.ExecuteTemplate(w, tmpl+&quot;.html&quot;, p)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>p.s.记得加上.html哦。</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>其实如果你足够细心，你会发现一个安全隐患问题：用户可以在服务器应用下的任意路径做读取和修改。为了尽可能避免这个安全隐患，我们写一个函数，它可以用正则表达式来验证title的合法性。</p>\n<p>首先我们先将regexp加入到import列表中，然后我们需要创建一个全局变量来存储我们需要用到的表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var validPath = regexp.MustCompile(&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;)</div></pre></td></tr></table></figure>\n<p>在这里，我们看到了熟悉的身影Must：regexp.MustCompile，它负责转换和遍历正则表达式，然后返回一个regexp.Regexp类型的变量。类似的，MustCompile和Compile这个妖艳贱货不一样，Must在处理失败的时候会返回一个panic。</p>\n<p>然后，我们可以开始写一个函数，它专门用于验证validPath的正确性并从中提取文件的title：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func getTitle(w http.ResponseWriter, r *http.Request) (string, error) &#123;</div><div class=\"line\">    m := validPath.FindStringSubmatch(r.URL.Path)</div><div class=\"line\">    if m == nil &#123;</div><div class=\"line\">        http.NotFound(w, r)</div><div class=\"line\">        return &quot;&quot;, errors.New(&quot;Invalid Page Title&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return m[2], nil // The title is the second subexpression.</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果路径合法，它会带着一个nil值返回（第二个返回值）；如果路径不合法，函数就会将“404 Not Found”写进HTTP连接，然后给handler返回一个error。当然，为了可以新建error，我们需要import一下errors包。</p>\n<p>然后我们修改所有handler，让它们在里面调用getTitle来验证合法性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title, err := getTitle(w, r)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title, err := getTitle(w, r)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">    title, err := getTitle(w, r)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    err = p.save()</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>心细的你又再次发现，为了捕捉和处理各种错误，我们使用了很多代码，而且还是很多重复的代码，那么我们能不能做点什么呢？也许抽象函数能帮得到我们。</p>\n<p>首先，我们重写一下handler的函数定义（以同样的形式，整齐的参数）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request, title string)</div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request, title string)</div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request, title string)</div></pre></td></tr></table></figure>\n<p>接下来我们定义一个包装函数，它需要的参数类型是<em>上面我们声明的函数类型</em>，即<code>func (http.ResponseWriter, *http.Request, string)</code>，然后返回一个http.HandlerFunc类型的函数，这个包装函数的大致框架如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func makeHandler(fn func (http.ResponseWriter, *http.Request, string)) http.HandlerFunc &#123;</div><div class=\"line\">\treturn func(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">\t\t// Here we will extract the page title from the Request,</div><div class=\"line\">\t\t// and call the provided handler &apos;fn&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述函数return了一个函数自己内部定义的函数，称为闭包。在这里，变量fn（即makeHandler唯一的参数）被闭包直接用了，而fn可以是我们的view、save或者edit的handler。</p>\n<p>然后我们可以开始着手于闭包里面的实现，我们可以借用getTitle的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc &#123;</div><div class=\"line\">    return func(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">        m := validPath.FindStringSubmatch(r.URL.Path)</div><div class=\"line\">        if m == nil &#123;</div><div class=\"line\">            http.NotFound(w, r)</div><div class=\"line\">            return</div><div class=\"line\">        &#125;</div><div class=\"line\">        fn(w, r, m[2])</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>makeHandler返回的闭包是带有http.ResponseWriter和http.Request参数的函数。而在这里，闭包在请求路径中提取了title，然后使用TitleValidator正则来检验合法性。如果不合法，它将会向ResponseWriter 用http.NotFound函数写入一个error；如果合法，函数将会用ResponseWriter、Request和title三个参数来调用fn。</p>\n<p>然后我们就可以在main函数里面包装我们的handler了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\">    http.HandleFunc(&quot;/view/&quot;, makeHandler(viewHandler))</div><div class=\"line\">    http.HandleFunc(&quot;/edit/&quot;, makeHandler(editHandler))</div><div class=\"line\">    http.HandleFunc(&quot;/save/&quot;, makeHandler(saveHandler))</div><div class=\"line\"></div><div class=\"line\">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们去掉先前的getTitle，让handler变得苗条点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">    p, err := loadPage(title)</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        p = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    renderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">    body := r.FormValue(&quot;body&quot;)</div><div class=\"line\">    p := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">    err := p.save()</div><div class=\"line\">    if err != nil &#123;</div><div class=\"line\">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">    http.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"最终再试一下\"><a href=\"#最终再试一下\" class=\"headerlink\" title=\"最终再试一下\"></a>最终再试一下</h2><p>重新编译运行试试？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ go build wiki.go</div><div class=\"line\">$ ./wiki</div></pre></td></tr></table></figure>\n<p>试试运行访问<a href=\"http://localhost:8080/view/ANewPage，看看会怎么样？它应该会给出一个新的编辑页面，然后你可以输入一些内容，你可以保存，在保存后它会将你重定向到新的wiki页面~\">http://localhost:8080/view/ANewPage，看看会怎么样？它应该会给出一个新的编辑页面，然后你可以输入一些内容，你可以保存，在保存后它会将你重定向到新的wiki页面~</a></p>\n<h3 id=\"P-S-如果你很混乱，那么我附上最终的全部代码？\"><a href=\"#P-S-如果你很混乱，那么我附上最终的全部代码？\" class=\"headerlink\" title=\"P.S.如果你很混乱，那么我附上最终的全部代码？\"></a>P.S.如果你很混乱，那么我附上最终的全部代码？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Copyright 2010 The Go Authors. All rights reserved.</div><div class=\"line\">// Use of this source code is governed by a BSD-style</div><div class=\"line\">// license that can be found in the LICENSE file.</div><div class=\"line\"></div><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;html/template&quot;</div><div class=\"line\">\t&quot;io/ioutil&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">\t&quot;regexp&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Page struct &#123;</div><div class=\"line\">\tTitle string</div><div class=\"line\">\tBody  []byte</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (p *Page) save() error &#123;</div><div class=\"line\">\tfilename := p.Title + &quot;.txt&quot;</div><div class=\"line\">\treturn ioutil.WriteFile(filename, p.Body, 0600)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func loadPage(title string) (*Page, error) &#123;</div><div class=\"line\">\tfilename := title + &quot;.txt&quot;</div><div class=\"line\">\tbody, err := ioutil.ReadFile(filename)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn nil, err</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &amp;Page&#123;Title: title, Body: body&#125;, nil</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func viewHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">\tp, err := loadPage(title)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\thttp.Redirect(w, r, &quot;/edit/&quot;+title, http.StatusFound)</div><div class=\"line\">\t\treturn</div><div class=\"line\">\t&#125;</div><div class=\"line\">\trenderTemplate(w, &quot;view&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func editHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">\tp, err := loadPage(title)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tp = &amp;Page&#123;Title: title&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\trenderTemplate(w, &quot;edit&quot;, p)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func saveHandler(w http.ResponseWriter, r *http.Request, title string) &#123;</div><div class=\"line\">\tbody := r.FormValue(&quot;body&quot;)</div><div class=\"line\">\tp := &amp;Page&#123;Title: title, Body: []byte(body)&#125;</div><div class=\"line\">\terr := p.save()</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">\t\treturn</div><div class=\"line\">\t&#125;</div><div class=\"line\">\thttp.Redirect(w, r, &quot;/view/&quot;+title, http.StatusFound)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var templates = template.Must(template.ParseFiles(&quot;edit.html&quot;, &quot;view.html&quot;))</div><div class=\"line\"></div><div class=\"line\">func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) &#123;</div><div class=\"line\">\terr := templates.ExecuteTemplate(w, tmpl+&quot;.html&quot;, p)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var validPath = regexp.MustCompile(&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;)</div><div class=\"line\"></div><div class=\"line\">func makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc &#123;</div><div class=\"line\">\treturn func(w http.ResponseWriter, r *http.Request) &#123;</div><div class=\"line\">\t\tm := validPath.FindStringSubmatch(r.URL.Path)</div><div class=\"line\">\t\tif m == nil &#123;</div><div class=\"line\">\t\t\thttp.NotFound(w, r)</div><div class=\"line\">\t\t\treturn</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfn(w, r, m[2])</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\">\thttp.HandleFunc(&quot;/view/&quot;, makeHandler(viewHandler))</div><div class=\"line\">\thttp.HandleFunc(&quot;/edit/&quot;, makeHandler(editHandler))</div><div class=\"line\">\thttp.HandleFunc(&quot;/save/&quot;, makeHandler(saveHandler))</div><div class=\"line\"></div><div class=\"line\">\thttp.ListenAndServe(&quot;:8080&quot;, nil)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"在树莓派2上Nginx并发1W到底有多难","date":"2016-05-12T23:47:00.000Z","_content":"\n\n## 道听途说后的感想\n总能得知Nginx的最大并发量能去到10W！简直吓到我，也不知道是我弱鸡还是我没弄过，反正10W的并发量我是没有弄过出来。不过嘛，说不定一台好CPU、大内存、高IO、高优化的服务器随便就可以上十万了，怎么说也是XEON的CPU然后来个几百几十G的内存是吧。那么在性能那么低的树莓派上并发量又能去到多少呢？网友总会说用树莓派当服务器还是算了吧，就这烂性能。这我也深有体会，在上面搭建的MC服务器简直没法玩啊！好吧，毕竟只是个值一两百块钱的板子而已：\n\n- CPU：4核，性能大概只相当于196MHZ的i3（网友反映的）\n- 内存：1G，简直不够用好吧！\n- 硬盘IO：十几M每秒吧，其实就是SD卡的IO\n\n你看看这性能：\n1.根本不能指望SD的IO能干嘛，换句话来说，传统数据库的读写、SWAP的换出换入等和外存有关的都不能实现（这样会拖时间而且换入换出的时候CPU根本承受不了！）\n2.因为上面的原因，几乎所有的东西都得堆在内存，1G的内存\n3.CPU很low，超频了也不过是零点几、零点零几的提升，如果还不用多线程榨干它简直大逆不道\n\n其实看到这配置估计就有很多人会说：欸，你这不是傻嘛，这么点可怜的性能怎么提升也不可能有什么效果的，还不如去用真·服务器去。其实我主要是不太想这个东西积尘了，也想折腾一下这方面的而已。\n\n<!-- more -->\n\n## 除掉Raspbian的限制\n\n### 修改最大连接数 somaxconn\necho 50000 > /proc/sys/net/core/somaxconn\n### 加快tcp连接的回收\necho 1 > /proc/sys/net/ipv4/tcp_tw_recycle\n\n### tcp重用\necho 1 > /proc/sys/net/ipv4/tcp_tw_reuse \n### 修改成不做洪水抵遇\necho 0 > /proc/sys/net/ipv4/tcp_syncookies\n\n### 修改系统的打开文件数的限制\nulimit -n 50000\n\n直接用脚本一次性写入即可（毕竟我更喜欢做个懒人）\n![](http://source.jianyujianyu.com/2016-05-13-14631237005719.jpg)\n\np.s.其实上面的那个50000是有点夸张而已，树莓派那么低的性能。。\n\n当然还有很多各种各样的参数，我也不做详细解读，例如：\nfs.file-max = 999999\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_keepalive_time = 600\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_max_tw_buckets = 5000\nnet.ipv4.ip_local_port_range = 1024    61000\nnet.ipv4.tcp_rmem = 4096 32768 262142\nnet.ipv4.tcp_wmem = 4096 32768 262142\nnet.core.netdev_max_backlog = 8096\nnet.core.rmem_default = 262144\nnet.core.wmem_default = 262144\nnet.core.rmem_max = 2097152\nnet.core.wmem_max = 2097152\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_max_syn.backlog=1024\n参数值可以忽略。\n\n\n## 修改Nginx的配置\n这一步本来是最重要的，但是由于性能的原因，也就只能尽量了。\n\n### 修改worker_processes并绑定CPU\n尽量地多线程处理请求，并且在低性能CPU中一个worker绑定一个CPU，将切换worker的资源消耗最小化：\n![](http://source.jianyujianyu.com/2016-05-13-14631243899899.jpg)\n\n\n### 修改worker_rlimit_nofile配置\n也就是修改nginx的最高打开文件数\n### 修改worker_connections\n修改Nginx的每个worker的最大连接数\n\n![](http://source.jianyujianyu.com/2016-05-13-14631242372230.jpg)\n\n### 负载均衡的上游服务器\n开8个，用Python的Tornado（如果要连Tomcat的话，要自己调好参数，不然会拒绝大部分请求的，而且还有控制好tomcat不断飙升的占用内存，树莓派的1G承受不住！）\n![](http://source.jianyujianyu.com/2016-05-13-14631246342501.jpg)\n\n\n## 后台搭建\n已经说过了用Python的Tornado做后台，直接就可以用它的demo中的blog来测试，选用blog原因如下：\n- 具有前端模板的渲染\n- 具有后台数据的提取\n- 具有登录鉴权系统\n\n这样的后台，虽然小并且简陋，但是与大部分实际应用相类似，因此选用。而且也特意不用缓存，这样子直接测它的性能。blog大概就是这个样子的：（其实挺丑的，测试数据请忽略）\n![](http://source.jianyujianyu.com/2016-05-13-14631248722938.jpg)\n\n\n## 使用ApacheBench测试\n接下来就是使用ab测试了，而且是用树莓派本身来发出请求测试，这样可以忽略网络的作用（其实是因为我手头上没有linux设备，Mac测试浮动太大- -）。\n\nab -c 8000 -n 50000  http://127.0.0.1/\n（根本不敢用1万的并发量好吧！）\n\n结果如图：\n![](http://source.jianyujianyu.com/2016-05-13-14631251132157.jpg)\n\n可以看出来：\n- 5万请求中有一千多的失败（对于这样的“服务器”已经很好了！！）\n- 用时好慢\n- 看到Processing和Waiting的时间直接人都崩溃了好吗\n\n可以看得出来树莓派不能干这事（怎么感觉只是在自己打自己脸而已），别说1万，8000或者5000都难，所以就不要用树莓派来做服务器啦~（搭建集群的土豪请忽略）\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n\n\n","source":"_posts/10k-parallel-on-raspberry2.md","raw":"title: 在树莓派2上Nginx并发1W到底有多难\ncategories: Raspberry\ntags: [后台,Raspberry,闲聊]\ndate: 2016-05-13 07:47:00\n---\n\n\n## 道听途说后的感想\n总能得知Nginx的最大并发量能去到10W！简直吓到我，也不知道是我弱鸡还是我没弄过，反正10W的并发量我是没有弄过出来。不过嘛，说不定一台好CPU、大内存、高IO、高优化的服务器随便就可以上十万了，怎么说也是XEON的CPU然后来个几百几十G的内存是吧。那么在性能那么低的树莓派上并发量又能去到多少呢？网友总会说用树莓派当服务器还是算了吧，就这烂性能。这我也深有体会，在上面搭建的MC服务器简直没法玩啊！好吧，毕竟只是个值一两百块钱的板子而已：\n\n- CPU：4核，性能大概只相当于196MHZ的i3（网友反映的）\n- 内存：1G，简直不够用好吧！\n- 硬盘IO：十几M每秒吧，其实就是SD卡的IO\n\n你看看这性能：\n1.根本不能指望SD的IO能干嘛，换句话来说，传统数据库的读写、SWAP的换出换入等和外存有关的都不能实现（这样会拖时间而且换入换出的时候CPU根本承受不了！）\n2.因为上面的原因，几乎所有的东西都得堆在内存，1G的内存\n3.CPU很low，超频了也不过是零点几、零点零几的提升，如果还不用多线程榨干它简直大逆不道\n\n其实看到这配置估计就有很多人会说：欸，你这不是傻嘛，这么点可怜的性能怎么提升也不可能有什么效果的，还不如去用真·服务器去。其实我主要是不太想这个东西积尘了，也想折腾一下这方面的而已。\n\n<!-- more -->\n\n## 除掉Raspbian的限制\n\n### 修改最大连接数 somaxconn\necho 50000 > /proc/sys/net/core/somaxconn\n### 加快tcp连接的回收\necho 1 > /proc/sys/net/ipv4/tcp_tw_recycle\n\n### tcp重用\necho 1 > /proc/sys/net/ipv4/tcp_tw_reuse \n### 修改成不做洪水抵遇\necho 0 > /proc/sys/net/ipv4/tcp_syncookies\n\n### 修改系统的打开文件数的限制\nulimit -n 50000\n\n直接用脚本一次性写入即可（毕竟我更喜欢做个懒人）\n![](http://source.jianyujianyu.com/2016-05-13-14631237005719.jpg)\n\np.s.其实上面的那个50000是有点夸张而已，树莓派那么低的性能。。\n\n当然还有很多各种各样的参数，我也不做详细解读，例如：\nfs.file-max = 999999\nnet.ipv4.tcp_tw_reuse = 1\nnet.ipv4.tcp_keepalive_time = 600\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_max_tw_buckets = 5000\nnet.ipv4.ip_local_port_range = 1024    61000\nnet.ipv4.tcp_rmem = 4096 32768 262142\nnet.ipv4.tcp_wmem = 4096 32768 262142\nnet.core.netdev_max_backlog = 8096\nnet.core.rmem_default = 262144\nnet.core.wmem_default = 262144\nnet.core.rmem_max = 2097152\nnet.core.wmem_max = 2097152\nnet.ipv4.tcp_syncookies = 1\nnet.ipv4.tcp_max_syn.backlog=1024\n参数值可以忽略。\n\n\n## 修改Nginx的配置\n这一步本来是最重要的，但是由于性能的原因，也就只能尽量了。\n\n### 修改worker_processes并绑定CPU\n尽量地多线程处理请求，并且在低性能CPU中一个worker绑定一个CPU，将切换worker的资源消耗最小化：\n![](http://source.jianyujianyu.com/2016-05-13-14631243899899.jpg)\n\n\n### 修改worker_rlimit_nofile配置\n也就是修改nginx的最高打开文件数\n### 修改worker_connections\n修改Nginx的每个worker的最大连接数\n\n![](http://source.jianyujianyu.com/2016-05-13-14631242372230.jpg)\n\n### 负载均衡的上游服务器\n开8个，用Python的Tornado（如果要连Tomcat的话，要自己调好参数，不然会拒绝大部分请求的，而且还有控制好tomcat不断飙升的占用内存，树莓派的1G承受不住！）\n![](http://source.jianyujianyu.com/2016-05-13-14631246342501.jpg)\n\n\n## 后台搭建\n已经说过了用Python的Tornado做后台，直接就可以用它的demo中的blog来测试，选用blog原因如下：\n- 具有前端模板的渲染\n- 具有后台数据的提取\n- 具有登录鉴权系统\n\n这样的后台，虽然小并且简陋，但是与大部分实际应用相类似，因此选用。而且也特意不用缓存，这样子直接测它的性能。blog大概就是这个样子的：（其实挺丑的，测试数据请忽略）\n![](http://source.jianyujianyu.com/2016-05-13-14631248722938.jpg)\n\n\n## 使用ApacheBench测试\n接下来就是使用ab测试了，而且是用树莓派本身来发出请求测试，这样可以忽略网络的作用（其实是因为我手头上没有linux设备，Mac测试浮动太大- -）。\n\nab -c 8000 -n 50000  http://127.0.0.1/\n（根本不敢用1万的并发量好吧！）\n\n结果如图：\n![](http://source.jianyujianyu.com/2016-05-13-14631251132157.jpg)\n\n可以看出来：\n- 5万请求中有一千多的失败（对于这样的“服务器”已经很好了！！）\n- 用时好慢\n- 看到Processing和Waiting的时间直接人都崩溃了好吗\n\n可以看得出来树莓派不能干这事（怎么感觉只是在自己打自己脸而已），别说1万，8000或者5000都难，所以就不要用树莓派来做服务器啦~（搭建集群的土豪请忽略）\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n\n\n\n\n\n","slug":"10k-parallel-on-raspberry2","published":1,"updated":"2017-04-23T13:42:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtrr000juoev1c2quckc","content":"<h2 id=\"道听途说后的感想\"><a href=\"#道听途说后的感想\" class=\"headerlink\" title=\"道听途说后的感想\"></a>道听途说后的感想</h2><p>总能得知Nginx的最大并发量能去到10W！简直吓到我，也不知道是我弱鸡还是我没弄过，反正10W的并发量我是没有弄过出来。不过嘛，说不定一台好CPU、大内存、高IO、高优化的服务器随便就可以上十万了，怎么说也是XEON的CPU然后来个几百几十G的内存是吧。那么在性能那么低的树莓派上并发量又能去到多少呢？网友总会说用树莓派当服务器还是算了吧，就这烂性能。这我也深有体会，在上面搭建的MC服务器简直没法玩啊！好吧，毕竟只是个值一两百块钱的板子而已：</p>\n<ul>\n<li>CPU：4核，性能大概只相当于196MHZ的i3（网友反映的）</li>\n<li>内存：1G，简直不够用好吧！</li>\n<li>硬盘IO：十几M每秒吧，其实就是SD卡的IO</li>\n</ul>\n<p>你看看这性能：<br>1.根本不能指望SD的IO能干嘛，换句话来说，传统数据库的读写、SWAP的换出换入等和外存有关的都不能实现（这样会拖时间而且换入换出的时候CPU根本承受不了！）<br>2.因为上面的原因，几乎所有的东西都得堆在内存，1G的内存<br>3.CPU很low，超频了也不过是零点几、零点零几的提升，如果还不用多线程榨干它简直大逆不道</p>\n<p>其实看到这配置估计就有很多人会说：欸，你这不是傻嘛，这么点可怜的性能怎么提升也不可能有什么效果的，还不如去用真·服务器去。其实我主要是不太想这个东西积尘了，也想折腾一下这方面的而已。</p>\n<a id=\"more\"></a>\n<h2 id=\"除掉Raspbian的限制\"><a href=\"#除掉Raspbian的限制\" class=\"headerlink\" title=\"除掉Raspbian的限制\"></a>除掉Raspbian的限制</h2><h3 id=\"修改最大连接数-somaxconn\"><a href=\"#修改最大连接数-somaxconn\" class=\"headerlink\" title=\"修改最大连接数 somaxconn\"></a>修改最大连接数 somaxconn</h3><p>echo 50000 &gt; /proc/sys/net/core/somaxconn</p>\n<h3 id=\"加快tcp连接的回收\"><a href=\"#加快tcp连接的回收\" class=\"headerlink\" title=\"加快tcp连接的回收\"></a>加快tcp连接的回收</h3><p>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</p>\n<h3 id=\"tcp重用\"><a href=\"#tcp重用\" class=\"headerlink\" title=\"tcp重用\"></a>tcp重用</h3><p>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse </p>\n<h3 id=\"修改成不做洪水抵遇\"><a href=\"#修改成不做洪水抵遇\" class=\"headerlink\" title=\"修改成不做洪水抵遇\"></a>修改成不做洪水抵遇</h3><p>echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies</p>\n<h3 id=\"修改系统的打开文件数的限制\"><a href=\"#修改系统的打开文件数的限制\" class=\"headerlink\" title=\"修改系统的打开文件数的限制\"></a>修改系统的打开文件数的限制</h3><p>ulimit -n 50000</p>\n<p>直接用脚本一次性写入即可（毕竟我更喜欢做个懒人）<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631237005719.jpg\" alt=\"\"></p>\n<p>p.s.其实上面的那个50000是有点夸张而已，树莓派那么低的性能。。</p>\n<p>当然还有很多各种各样的参数，我也不做详细解读，例如：<br>fs.file-max = 999999<br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_keepalive_time = 600<br>net.ipv4.tcp_fin_timeout = 30<br>net.ipv4.tcp_max_tw_buckets = 5000<br>net.ipv4.ip_local_port_range = 1024    61000<br>net.ipv4.tcp_rmem = 4096 32768 262142<br>net.ipv4.tcp_wmem = 4096 32768 262142<br>net.core.netdev_max_backlog = 8096<br>net.core.rmem_default = 262144<br>net.core.wmem_default = 262144<br>net.core.rmem_max = 2097152<br>net.core.wmem_max = 2097152<br>net.ipv4.tcp_syncookies = 1<br>net.ipv4.tcp_max_syn.backlog=1024<br>参数值可以忽略。</p>\n<h2 id=\"修改Nginx的配置\"><a href=\"#修改Nginx的配置\" class=\"headerlink\" title=\"修改Nginx的配置\"></a>修改Nginx的配置</h2><p>这一步本来是最重要的，但是由于性能的原因，也就只能尽量了。</p>\n<h3 id=\"修改worker-processes并绑定CPU\"><a href=\"#修改worker-processes并绑定CPU\" class=\"headerlink\" title=\"修改worker_processes并绑定CPU\"></a>修改worker_processes并绑定CPU</h3><p>尽量地多线程处理请求，并且在低性能CPU中一个worker绑定一个CPU，将切换worker的资源消耗最小化：<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631243899899.jpg\" alt=\"\"></p>\n<h3 id=\"修改worker-rlimit-nofile配置\"><a href=\"#修改worker-rlimit-nofile配置\" class=\"headerlink\" title=\"修改worker_rlimit_nofile配置\"></a>修改worker_rlimit_nofile配置</h3><p>也就是修改nginx的最高打开文件数</p>\n<h3 id=\"修改worker-connections\"><a href=\"#修改worker-connections\" class=\"headerlink\" title=\"修改worker_connections\"></a>修改worker_connections</h3><p>修改Nginx的每个worker的最大连接数</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-13-14631242372230.jpg\" alt=\"\"></p>\n<h3 id=\"负载均衡的上游服务器\"><a href=\"#负载均衡的上游服务器\" class=\"headerlink\" title=\"负载均衡的上游服务器\"></a>负载均衡的上游服务器</h3><p>开8个，用Python的Tornado（如果要连Tomcat的话，要自己调好参数，不然会拒绝大部分请求的，而且还有控制好tomcat不断飙升的占用内存，树莓派的1G承受不住！）<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631246342501.jpg\" alt=\"\"></p>\n<h2 id=\"后台搭建\"><a href=\"#后台搭建\" class=\"headerlink\" title=\"后台搭建\"></a>后台搭建</h2><p>已经说过了用Python的Tornado做后台，直接就可以用它的demo中的blog来测试，选用blog原因如下：</p>\n<ul>\n<li>具有前端模板的渲染</li>\n<li>具有后台数据的提取</li>\n<li>具有登录鉴权系统</li>\n</ul>\n<p>这样的后台，虽然小并且简陋，但是与大部分实际应用相类似，因此选用。而且也特意不用缓存，这样子直接测它的性能。blog大概就是这个样子的：（其实挺丑的，测试数据请忽略）<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631248722938.jpg\" alt=\"\"></p>\n<h2 id=\"使用ApacheBench测试\"><a href=\"#使用ApacheBench测试\" class=\"headerlink\" title=\"使用ApacheBench测试\"></a>使用ApacheBench测试</h2><p>接下来就是使用ab测试了，而且是用树莓派本身来发出请求测试，这样可以忽略网络的作用（其实是因为我手头上没有linux设备，Mac测试浮动太大- -）。</p>\n<p>ab -c 8000 -n 50000  <a href=\"http://127.0.0.1/\" target=\"_blank\" rel=\"external\">http://127.0.0.1/</a><br>（根本不敢用1万的并发量好吧！）</p>\n<p>结果如图：<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631251132157.jpg\" alt=\"\"></p>\n<p>可以看出来：</p>\n<ul>\n<li>5万请求中有一千多的失败（对于这样的“服务器”已经很好了！！）</li>\n<li>用时好慢</li>\n<li>看到Processing和Waiting的时间直接人都崩溃了好吗</li>\n</ul>\n<p>可以看得出来树莓派不能干这事（怎么感觉只是在自己打自己脸而已），别说1万，8000或者5000都难，所以就不要用树莓派来做服务器啦~（搭建集群的土豪请忽略）</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"道听途说后的感想\"><a href=\"#道听途说后的感想\" class=\"headerlink\" title=\"道听途说后的感想\"></a>道听途说后的感想</h2><p>总能得知Nginx的最大并发量能去到10W！简直吓到我，也不知道是我弱鸡还是我没弄过，反正10W的并发量我是没有弄过出来。不过嘛，说不定一台好CPU、大内存、高IO、高优化的服务器随便就可以上十万了，怎么说也是XEON的CPU然后来个几百几十G的内存是吧。那么在性能那么低的树莓派上并发量又能去到多少呢？网友总会说用树莓派当服务器还是算了吧，就这烂性能。这我也深有体会，在上面搭建的MC服务器简直没法玩啊！好吧，毕竟只是个值一两百块钱的板子而已：</p>\n<ul>\n<li>CPU：4核，性能大概只相当于196MHZ的i3（网友反映的）</li>\n<li>内存：1G，简直不够用好吧！</li>\n<li>硬盘IO：十几M每秒吧，其实就是SD卡的IO</li>\n</ul>\n<p>你看看这性能：<br>1.根本不能指望SD的IO能干嘛，换句话来说，传统数据库的读写、SWAP的换出换入等和外存有关的都不能实现（这样会拖时间而且换入换出的时候CPU根本承受不了！）<br>2.因为上面的原因，几乎所有的东西都得堆在内存，1G的内存<br>3.CPU很low，超频了也不过是零点几、零点零几的提升，如果还不用多线程榨干它简直大逆不道</p>\n<p>其实看到这配置估计就有很多人会说：欸，你这不是傻嘛，这么点可怜的性能怎么提升也不可能有什么效果的，还不如去用真·服务器去。其实我主要是不太想这个东西积尘了，也想折腾一下这方面的而已。</p>","more":"<h2 id=\"除掉Raspbian的限制\"><a href=\"#除掉Raspbian的限制\" class=\"headerlink\" title=\"除掉Raspbian的限制\"></a>除掉Raspbian的限制</h2><h3 id=\"修改最大连接数-somaxconn\"><a href=\"#修改最大连接数-somaxconn\" class=\"headerlink\" title=\"修改最大连接数 somaxconn\"></a>修改最大连接数 somaxconn</h3><p>echo 50000 &gt; /proc/sys/net/core/somaxconn</p>\n<h3 id=\"加快tcp连接的回收\"><a href=\"#加快tcp连接的回收\" class=\"headerlink\" title=\"加快tcp连接的回收\"></a>加快tcp连接的回收</h3><p>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</p>\n<h3 id=\"tcp重用\"><a href=\"#tcp重用\" class=\"headerlink\" title=\"tcp重用\"></a>tcp重用</h3><p>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse </p>\n<h3 id=\"修改成不做洪水抵遇\"><a href=\"#修改成不做洪水抵遇\" class=\"headerlink\" title=\"修改成不做洪水抵遇\"></a>修改成不做洪水抵遇</h3><p>echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies</p>\n<h3 id=\"修改系统的打开文件数的限制\"><a href=\"#修改系统的打开文件数的限制\" class=\"headerlink\" title=\"修改系统的打开文件数的限制\"></a>修改系统的打开文件数的限制</h3><p>ulimit -n 50000</p>\n<p>直接用脚本一次性写入即可（毕竟我更喜欢做个懒人）<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631237005719.jpg\" alt=\"\"></p>\n<p>p.s.其实上面的那个50000是有点夸张而已，树莓派那么低的性能。。</p>\n<p>当然还有很多各种各样的参数，我也不做详细解读，例如：<br>fs.file-max = 999999<br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_keepalive_time = 600<br>net.ipv4.tcp_fin_timeout = 30<br>net.ipv4.tcp_max_tw_buckets = 5000<br>net.ipv4.ip_local_port_range = 1024    61000<br>net.ipv4.tcp_rmem = 4096 32768 262142<br>net.ipv4.tcp_wmem = 4096 32768 262142<br>net.core.netdev_max_backlog = 8096<br>net.core.rmem_default = 262144<br>net.core.wmem_default = 262144<br>net.core.rmem_max = 2097152<br>net.core.wmem_max = 2097152<br>net.ipv4.tcp_syncookies = 1<br>net.ipv4.tcp_max_syn.backlog=1024<br>参数值可以忽略。</p>\n<h2 id=\"修改Nginx的配置\"><a href=\"#修改Nginx的配置\" class=\"headerlink\" title=\"修改Nginx的配置\"></a>修改Nginx的配置</h2><p>这一步本来是最重要的，但是由于性能的原因，也就只能尽量了。</p>\n<h3 id=\"修改worker-processes并绑定CPU\"><a href=\"#修改worker-processes并绑定CPU\" class=\"headerlink\" title=\"修改worker_processes并绑定CPU\"></a>修改worker_processes并绑定CPU</h3><p>尽量地多线程处理请求，并且在低性能CPU中一个worker绑定一个CPU，将切换worker的资源消耗最小化：<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631243899899.jpg\" alt=\"\"></p>\n<h3 id=\"修改worker-rlimit-nofile配置\"><a href=\"#修改worker-rlimit-nofile配置\" class=\"headerlink\" title=\"修改worker_rlimit_nofile配置\"></a>修改worker_rlimit_nofile配置</h3><p>也就是修改nginx的最高打开文件数</p>\n<h3 id=\"修改worker-connections\"><a href=\"#修改worker-connections\" class=\"headerlink\" title=\"修改worker_connections\"></a>修改worker_connections</h3><p>修改Nginx的每个worker的最大连接数</p>\n<p><img src=\"http://source.jianyujianyu.com/2016-05-13-14631242372230.jpg\" alt=\"\"></p>\n<h3 id=\"负载均衡的上游服务器\"><a href=\"#负载均衡的上游服务器\" class=\"headerlink\" title=\"负载均衡的上游服务器\"></a>负载均衡的上游服务器</h3><p>开8个，用Python的Tornado（如果要连Tomcat的话，要自己调好参数，不然会拒绝大部分请求的，而且还有控制好tomcat不断飙升的占用内存，树莓派的1G承受不住！）<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631246342501.jpg\" alt=\"\"></p>\n<h2 id=\"后台搭建\"><a href=\"#后台搭建\" class=\"headerlink\" title=\"后台搭建\"></a>后台搭建</h2><p>已经说过了用Python的Tornado做后台，直接就可以用它的demo中的blog来测试，选用blog原因如下：</p>\n<ul>\n<li>具有前端模板的渲染</li>\n<li>具有后台数据的提取</li>\n<li>具有登录鉴权系统</li>\n</ul>\n<p>这样的后台，虽然小并且简陋，但是与大部分实际应用相类似，因此选用。而且也特意不用缓存，这样子直接测它的性能。blog大概就是这个样子的：（其实挺丑的，测试数据请忽略）<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631248722938.jpg\" alt=\"\"></p>\n<h2 id=\"使用ApacheBench测试\"><a href=\"#使用ApacheBench测试\" class=\"headerlink\" title=\"使用ApacheBench测试\"></a>使用ApacheBench测试</h2><p>接下来就是使用ab测试了，而且是用树莓派本身来发出请求测试，这样可以忽略网络的作用（其实是因为我手头上没有linux设备，Mac测试浮动太大- -）。</p>\n<p>ab -c 8000 -n 50000  <a href=\"http://127.0.0.1/\">http://127.0.0.1/</a><br>（根本不敢用1万的并发量好吧！）</p>\n<p>结果如图：<br><img src=\"http://source.jianyujianyu.com/2016-05-13-14631251132157.jpg\" alt=\"\"></p>\n<p>可以看出来：</p>\n<ul>\n<li>5万请求中有一千多的失败（对于这样的“服务器”已经很好了！！）</li>\n<li>用时好慢</li>\n<li>看到Processing和Waiting的时间直接人都崩溃了好吗</li>\n</ul>\n<p>可以看得出来树莓派不能干这事（怎么感觉只是在自己打自己脸而已），别说1万，8000或者5000都难，所以就不要用树莓派来做服务器啦~（搭建集群的土豪请忽略）</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"Python 2.x 的中文编码问题","date":"2017-03-05T18:21:00.000Z","_content":"\nPython 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。因此，在Python 2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。\n\n<!-- more -->\n\n\n## 常见异常以及分析\n### SyntaxError: Non-ASCII character\n\nPython源码文件中有非ASCII字符，而且同时没有声明源码编码格式\n\n### UnicodeDecodeError\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = '中文'\ns.decode('gb2312') \n# UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence\nprint s\n```\n以上的s已经是声明了的utf8，但在转换为Unicode的时候传的不是utf8而是gb2312\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = '中文'\ns.encode('gb2312') \n# UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)\nprint s\n```\n与前一种情况一样，都是当前字符编码和de/encode的参数编码冲突\n\n### UnicodeEncodeError\n\n如将Unicode编码的字符decode，或者将utf8编码的字符encode的时候\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = u'中文'\ns.decode('utf-8') \n# UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\nprint s\n```\n\n## 如何避免\n\n1. 在文件头声明编码，即PEP0263\n2. 用u'string'替代'string'\n3. 使用sys.setdefaultencoding('utf-8')来reset编码\n4. 原则：decode early, unicode everywhere, encode late\n5. 升级Python 3\n\n\n## 顺便一提Python 3的Unicode\n\n1. 默认编码即为Unicode\n2. 所有Python的内置模块都支持Unicode\n3. 不再支持u'string'的格式\n\n\n[原文链接][1]\n若有错误之处请指出，更多地关注[煎鱼][2]。\n\n\n  [1]: https://segmentfault.com/a/1190000002412924\n  [2]: https://www.jianyujianyu.com\n","source":"_posts/chinese-unicode-in-python2.x.md","raw":"title: Python 2.x 的中文编码问题\ncategories: python\ntags: [python,unicode]\ndate: 2017-03-06 02:21:00\n---\n\nPython 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。因此，在Python 2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。\n\n<!-- more -->\n\n\n## 常见异常以及分析\n### SyntaxError: Non-ASCII character\n\nPython源码文件中有非ASCII字符，而且同时没有声明源码编码格式\n\n### UnicodeDecodeError\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = '中文'\ns.decode('gb2312') \n# UnicodeDecodeError: 'gb2312' codec can't decode bytes in position 2-3: illegal multibyte sequence\nprint s\n```\n以上的s已经是声明了的utf8，但在转换为Unicode的时候传的不是utf8而是gb2312\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = '中文'\ns.encode('gb2312') \n# UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128)\nprint s\n```\n与前一种情况一样，都是当前字符编码和de/encode的参数编码冲突\n\n### UnicodeEncodeError\n\n如将Unicode编码的字符decode，或者将utf8编码的字符encode的时候\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\ns = u'中文'\ns.decode('utf-8') \n# UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\nprint s\n```\n\n## 如何避免\n\n1. 在文件头声明编码，即PEP0263\n2. 用u'string'替代'string'\n3. 使用sys.setdefaultencoding('utf-8')来reset编码\n4. 原则：decode early, unicode everywhere, encode late\n5. 升级Python 3\n\n\n## 顺便一提Python 3的Unicode\n\n1. 默认编码即为Unicode\n2. 所有Python的内置模块都支持Unicode\n3. 不再支持u'string'的格式\n\n\n[原文链接][1]\n若有错误之处请指出，更多地关注[煎鱼][2]。\n\n\n  [1]: https://segmentfault.com/a/1190000002412924\n  [2]: https://www.jianyujianyu.com\n","slug":"chinese-unicode-in-python2.x","published":1,"updated":"2017-04-23T13:42:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj1utjtrv000ouoevbs5ks1g8","content":"<p>Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。因此，在Python 2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。</p>\n<a id=\"more\"></a>\n<h2 id=\"常见异常以及分析\"><a href=\"#常见异常以及分析\" class=\"headerlink\" title=\"常见异常以及分析\"></a>常见异常以及分析</h2><h3 id=\"SyntaxError-Non-ASCII-character\"><a href=\"#SyntaxError-Non-ASCII-character\" class=\"headerlink\" title=\"SyntaxError: Non-ASCII character\"></a>SyntaxError: Non-ASCII character</h3><p>Python源码文件中有非ASCII字符，而且同时没有声明源码编码格式</p>\n<h3 id=\"UnicodeDecodeError\"><a href=\"#UnicodeDecodeError\" class=\"headerlink\" title=\"UnicodeDecodeError\"></a>UnicodeDecodeError</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">s = &apos;中文&apos;</div><div class=\"line\">s.decode(&apos;gb2312&apos;) </div><div class=\"line\"># UnicodeDecodeError: &apos;gb2312&apos; codec can&apos;t decode bytes in position 2-3: illegal multibyte sequence</div><div class=\"line\">print s</div></pre></td></tr></table></figure>\n<p>以上的s已经是声明了的utf8，但在转换为Unicode的时候传的不是utf8而是gb2312</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">s = &apos;中文&apos;</div><div class=\"line\">s.encode(&apos;gb2312&apos;) </div><div class=\"line\"># UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128)</div><div class=\"line\">print s</div></pre></td></tr></table></figure>\n<p>与前一种情况一样，都是当前字符编码和de/encode的参数编码冲突</p>\n<h3 id=\"UnicodeEncodeError\"><a href=\"#UnicodeEncodeError\" class=\"headerlink\" title=\"UnicodeEncodeError\"></a>UnicodeEncodeError</h3><p>如将Unicode编码的字符decode，或者将utf8编码的字符encode的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">s = u&apos;中文&apos;</div><div class=\"line\">s.decode(&apos;utf-8&apos;) </div><div class=\"line\"># UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</div><div class=\"line\">print s</div></pre></td></tr></table></figure>\n<h2 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h2><ol>\n<li>在文件头声明编码，即PEP0263</li>\n<li>用u’string’替代’string’</li>\n<li>使用sys.setdefaultencoding(‘utf-8’)来reset编码</li>\n<li>原则：decode early, unicode everywhere, encode late</li>\n<li>升级Python 3</li>\n</ol>\n<h2 id=\"顺便一提Python-3的Unicode\"><a href=\"#顺便一提Python-3的Unicode\" class=\"headerlink\" title=\"顺便一提Python 3的Unicode\"></a>顺便一提Python 3的Unicode</h2><ol>\n<li>默认编码即为Unicode</li>\n<li>所有Python的内置模块都支持Unicode</li>\n<li>不再支持u’string’的格式</li>\n</ol>\n<p><a href=\"https://segmentfault.com/a/1190000002412924\" target=\"_blank\" rel=\"external\">原文链接</a><br>若有错误之处请指出，更多地关注<a href=\"https://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p>Python 2.x的默认编码格式是ASCII，就是说，在没有指定Python源码编码格式的情况下，源码中的所有字符都会被默认为ASCII码。因此，在Python 2.x中经常会遇到UnicodeDecodeError或者UnicodeEncodeError的异常。</p>","more":"<h2 id=\"常见异常以及分析\"><a href=\"#常见异常以及分析\" class=\"headerlink\" title=\"常见异常以及分析\"></a>常见异常以及分析</h2><h3 id=\"SyntaxError-Non-ASCII-character\"><a href=\"#SyntaxError-Non-ASCII-character\" class=\"headerlink\" title=\"SyntaxError: Non-ASCII character\"></a>SyntaxError: Non-ASCII character</h3><p>Python源码文件中有非ASCII字符，而且同时没有声明源码编码格式</p>\n<h3 id=\"UnicodeDecodeError\"><a href=\"#UnicodeDecodeError\" class=\"headerlink\" title=\"UnicodeDecodeError\"></a>UnicodeDecodeError</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">s = &apos;中文&apos;</div><div class=\"line\">s.decode(&apos;gb2312&apos;) </div><div class=\"line\"># UnicodeDecodeError: &apos;gb2312&apos; codec can&apos;t decode bytes in position 2-3: illegal multibyte sequence</div><div class=\"line\">print s</div></pre></td></tr></table></figure>\n<p>以上的s已经是声明了的utf8，但在转换为Unicode的时候传的不是utf8而是gb2312</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">s = &apos;中文&apos;</div><div class=\"line\">s.encode(&apos;gb2312&apos;) </div><div class=\"line\"># UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128)</div><div class=\"line\">print s</div></pre></td></tr></table></figure>\n<p>与前一种情况一样，都是当前字符编码和de/encode的参数编码冲突</p>\n<h3 id=\"UnicodeEncodeError\"><a href=\"#UnicodeEncodeError\" class=\"headerlink\" title=\"UnicodeEncodeError\"></a>UnicodeEncodeError</h3><p>如将Unicode编码的字符decode，或者将utf8编码的字符encode的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/python</div><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">s = u&apos;中文&apos;</div><div class=\"line\">s.decode(&apos;utf-8&apos;) </div><div class=\"line\"># UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</div><div class=\"line\">print s</div></pre></td></tr></table></figure>\n<h2 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h2><ol>\n<li>在文件头声明编码，即PEP0263</li>\n<li>用u’string’替代’string’</li>\n<li>使用sys.setdefaultencoding(‘utf-8’)来reset编码</li>\n<li>原则：decode early, unicode everywhere, encode late</li>\n<li>升级Python 3</li>\n</ol>\n<h2 id=\"顺便一提Python-3的Unicode\"><a href=\"#顺便一提Python-3的Unicode\" class=\"headerlink\" title=\"顺便一提Python 3的Unicode\"></a>顺便一提Python 3的Unicode</h2><ol>\n<li>默认编码即为Unicode</li>\n<li>所有Python的内置模块都支持Unicode</li>\n<li>不再支持u’string’的格式</li>\n</ol>\n<p><a href=\"https://segmentfault.com/a/1190000002412924\">原文链接</a><br>若有错误之处请指出，更多地关注<a href=\"https://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"[小题大做] Github + Jenkins 实现自动化部署 hexo 博客静态文件","date":"2017-04-27T01:49:38.000Z","_content":"\n*使用jenkins来部署hexo简直就是小题大做，但是偶尔这样小题大做还真有折腾的乐趣*\n\n\n\n## 背景\n\n[jianyujianyu.com](https://www.jianyujianyu.com)之前是使用typecho做博客的。\n\n原因很简单，wordpress太重，hexo很轻没错，可是这个没有后台管理（听说可以折腾成有后台管理的），每次写完博客都要deploy一下的hexo，我真心要不起。\n\n而现在[jianyujianyu.com](https://www.jianyujianyu.com)是hexo了，经过也很简单，就是因为CA证书过期了，换证书的时候弄砸了，本着顺便过滤一波辣鸡博客的心思，重新弄，这次选择了hexo，不为什么，人生的选择就是这么奇妙。\n\n那怎么不自己手写一个？说得好！不过我才不要。\n\n用hexo不是不行，是要考虑deploy的事，或者，我换台电脑写博客，我没有这个hexo的node环境，我也不想登录服务器用着vim来写，比如我现在就安静在公司电脑上写博客。在这样的情况下，怎么deploy呢？在从前，wordpress和typecho有着后台管理，这个问题根本是不存在的。\n\n想着想着，一拍脑袋，就直接用jenkins了，然后把代码放在github，包括hexo的整个文件夹。至于为啥用github而不用coding甚至是github pages，never mind。\n\n设计的deploy过程很简单：\n\n- 我先clone了github上的hexo文件夹，添加了md文章，然后push\n- github整理好代码就通知jenkins：我这里资源更新了，大爷快来玩啊\n- jenkins收到消息，兽性大发地下了github上的代码\n- 拥有hexo环境的jenkins直接执行hexo g，产生了分泌物，也就是静态文件，在这里就是[jianyujianyu.com](https://www.jianyujianyu.com)的html网页内容（hexo/public）\n- 待定的nginx直接将用户请求拉向[jianyujianyu.com](https://www.jianyujianyu.com)的hexo/public文件夹即可\n\n简单地设计完，便是动手开始。\n\n<!-- more -->\n\n\n\n## 环境准备\n\n*所有操作都是在Ubuntu的root用户下进行的，其他环境自行处理或转换*\n\n### Java、Tomcat和Jenkins\n\njenkins是java的美好产物，为了后面调试起来简单，使用tomcat容器来装着这产物，而不是直接用apt下载。\n\n（如果为了快捷，也可以只下载java和jenkins，然后通过`java -jar jenkins.war`来运行。不推荐。）\n\n因此我们首先安装J8。\n\n```\nadd-apt-repository ppa:webupd8team/java\napt update\napt install oracle-java8-installer\n```\n\n之后是安装tomcat。对应着J8，选tomcat8。先去[tomcat官网](http://tomcat.apache.org/)下载包，然后解压。\n\n```\nwget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.0.43/bin/apache-tomcat-8.0.43.tar.gz\ntar zxvf apache-tomcat-8.0.43.tar.gz\n```\n\n接着是上[jenkins官网](https://jenkins.io)下载jenkins的war包。\n\n```\nwget http://ftp-chi.osuosl.org/pub/jenkins/war-stable/2.46.1/jenkins.war\n```\n\nwar包就放在tomcat文件夹的webapps下即可。\n\n然后启动tomcat，进入tomcat文件夹的bin下，启动：\n\n```\n./startup.sh\n```\n\n接下来就可以尝试通过网页登录tomcat以及jenkins了。在浏览器中打开[http://服务器的ip:8080](#)，\n\n![tomcat主页](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-25_19-45-36.png)\n\n然后打开[http://服务器的ip:8080/jenkins](#)，根据知识安装jenkins环境，安装推荐环境即可，不需要自己选择，因为推荐环境已经包含了我们需要的插件。***如果要nginx反向代理tomcat，推荐先做完后面nginx的反向代理再安装jenkins***。\n\n按照提示输入password，然后选择推荐安装：\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-23-43.png)\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-19.png)\n\n正在安装，要等一下\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-30.png)\n\n账号密码以及权限的事自行考虑\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_12-20-38.png)\n\n\n\n### Nodejs、NPM和hexo\n\nhexo是nodejs的产物，因此搭建nodejs环境是必须的。而安装nodejs推荐在[官网](https://nodejs.org/en/)上下载源码编译，不然apt得到的都是旧的，没办法，node这两年发展得太快了。\n\n```\nwget https://nodejs.org/dist/v6.10.2/node-v6.10.2.tar.gz\ntar zxvf node-v6.10.2.tar.gz\ncd node-v6.10.2\n./configure\nmake\nmake install\n```\n\nmake可自行通过参数-j来加速编译。\n\n安装好了node，npm也接着来了，如果在安装过程中觉得npm下载太慢可以是用[淘宝镜像](http://npm.taobao.org/)，使用方法自行查询。\n\n然后照着[hexo官方文档](https://hexo.io/docs/)的方法安装hexo已经相关环境\n\n```\nnpm install hexo-cli -g\nhexo init hexo\ncd hexo\nnpm install\n```\n\nhexo的命令很简单，有了hexo的环境之后可以通过命令生成静态文件或者启动临时服务器：\n\n```\nhexo g # generate static file\nhexo s # start a server\n```\n\n在生成静态文件后，将nginx配置到hexo/public下面，请求即可到达；在启动hexo临时服务器后，即可访问http://服务器的ip:4000/jenkins。\n\n至此，hexo环境已经是完成了。\n\n如果说还有什么需要在这一步做的话， 那应该就是将代码push到git上，这个事我就不多说了。\n\n\n\n### Nginx\n\n安装nginx十分简单，但是在这次的实验中，nginx地位也不算低，80或者443端口要配置到hexo/public下，最好还要给tomcat配置反向代理。在以后的安全和优化方面，nginx需要配置的也不少。\n\n安装nginx也就一句\n\n```\napt install nginx\n```\n\n然后便是对配置的修改（我直接改default配置文件，别的方法自行实施）\n\n```\nvim /etc/nginx/sites-available/default\n```\n\n在开放80或者443的端口的server里面配置好root，例：\n\n```\nroot /var/www/hexo/public;\n```\n\n推荐给tomcat上个反向代理，\n\n```\nupstream tomcat  {\n        server  127.0.0.1:8080;\n}\n\nserver {\n        listen 11111;\n        listen [::]:11111;\n\n        location / {\n                #try_files $uri $uri/ =404;\n                proxy_pass   http://tomcat;\n                proxy_redirect  off;\n                proxy_set_header Host $host:$server_port;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header Request-Url $request_uri;\n        }\n}\n```\n\n以上需要注意的是proxy_set_header需要配置好，不然后面可能无法跳转到对的路径。\n\n\n\n## 配置Github和Jenkins\n\n### 创建job\n\n![创建job](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.43.29%20PM.png)\n\n点击create new jobs，选择freestyle，填好job名字。\n\n![选择freestyle](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.44.11%20PM.png)\n\n创建了job以后，jenkins紧接着就是让你配置jenkins，如果这次不配置也没什么，因为创建的job已经保存好了。\n\n\n\n### 配置密钥\n\n如果我在github上的代码库是私密的而不是公开的，那么jenkins想要拉取到我的代码必须要有相应的私钥。至于哪一台机上的公钥私钥没什么所谓，重要的是github上有一台机的公钥，而jenkins上应该也有这台机的私钥。当然前提是github上的代码库是私密的，公开的无所谓。\n\n先在Jenkins添加私钥。\n\n![创建一个证书](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.36%20PM.png)\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.56%20PM.png)\n\n![填入git平台的公钥对应的私钥](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.52.30%20PM.png)\n\n查出private key往上填就行，为了保密我就不填真实username了。至于怎么生成key，自行查找ssh-keygen命令，或者参考类似[Github的文档](https://help.github.com/articles/connecting-to-github-with-ssh/)。\n\n\n\n### 配置WebHook\n\n配置webhook是在github上完成的。webhook的存在意义就是github上发生了特定事件，然后会告诉请求jenkins，以便让jenkins去拉代码进行下一步操作。\n\n例如，现在要配置的，就是每次将代码push上去后，就触发jenkins的操作。\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-29-15.png)\n\n打码处理。\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-33-0.png)\n\n\n\n### 配置job\n\n之前的环境都搭建好了，配置刚才创建的job就是关键的一步了。\n\n首先是要配置github project\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.16%20PM.png)\n\n而在源码管理里面，必须要填一个可行的、同时有权限的配置，失败则如下图，必须做到没有错误提醒\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.25%20PM.png)\n\nbrowser也顺便一填\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.34%20PM.png)\n\n而在Build Triggers里面必须要选Github hook trigger，勾选了jenkins才会接受github发来的请求\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.53%20PM.png)\n\n最后在Build，也就是构建的这部分，也填上，推荐使用shell，毕竟现在玩这些都是linux了\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.51.15%20PM.png)\n\n选择shell后，可以在文本框里面填自己部署要用到的命令，如下面的例子，cd、删除、拷贝等命令都可以。\n\n需要注意的是，某些命令没有，这个可以通过不断的测试来检验。\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.52.21%20PM.png)\n\n至此已经配置好了jenkins上的job，接下来就是调试了。\n\n\n\n## 调试\n\n调试很简单。先把代码clone下来本地，然后稍稍改动一个无关文件，再push，之后便是感受是否这套环境是否能自动化部署。\n\n### Push代码\n\n各种push方式任君选择\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.11.57%20AM.png)\n\n\n\n### 查看日志\n\npush成功后，github hook会通知所填写的jenkins，如果jenkins没有调起job，则有可能是hook或者配置job里面的Github hook trigger没有填写正确。\n\n如果是成功调起，在jenkins的hexo的job页面，左下角会看到有类似`#1`的\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.20%20AM.png)\n\n想要查看错误日志，点击左上角的Github Hook Log或者Console Output，即可根据这些日志对配置进行调整。\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.57%20AM.png)\n\nOutput大致都如下：\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-25-53.png)\n\n\n\n### 访问网站\n\n不是红灯一般都是成功的，访问网站体验一下，[jianyujianyu.com](https://www.jianyujianyu.com/) ：\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-28-45.png)\n\n没毛病。\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n","source":"_posts/using-github-and-jenkins-deploy-hexo.md","raw":"title: \"[小题大做] Github + Jenkins 实现自动化部署 hexo 博客静态文件\"\ncategories: CI\ntags: [jenkins,hexo,blog]\ndate: 2017-04-27 09:49:38\n---\n\n*使用jenkins来部署hexo简直就是小题大做，但是偶尔这样小题大做还真有折腾的乐趣*\n\n\n\n## 背景\n\n[jianyujianyu.com](https://www.jianyujianyu.com)之前是使用typecho做博客的。\n\n原因很简单，wordpress太重，hexo很轻没错，可是这个没有后台管理（听说可以折腾成有后台管理的），每次写完博客都要deploy一下的hexo，我真心要不起。\n\n而现在[jianyujianyu.com](https://www.jianyujianyu.com)是hexo了，经过也很简单，就是因为CA证书过期了，换证书的时候弄砸了，本着顺便过滤一波辣鸡博客的心思，重新弄，这次选择了hexo，不为什么，人生的选择就是这么奇妙。\n\n那怎么不自己手写一个？说得好！不过我才不要。\n\n用hexo不是不行，是要考虑deploy的事，或者，我换台电脑写博客，我没有这个hexo的node环境，我也不想登录服务器用着vim来写，比如我现在就安静在公司电脑上写博客。在这样的情况下，怎么deploy呢？在从前，wordpress和typecho有着后台管理，这个问题根本是不存在的。\n\n想着想着，一拍脑袋，就直接用jenkins了，然后把代码放在github，包括hexo的整个文件夹。至于为啥用github而不用coding甚至是github pages，never mind。\n\n设计的deploy过程很简单：\n\n- 我先clone了github上的hexo文件夹，添加了md文章，然后push\n- github整理好代码就通知jenkins：我这里资源更新了，大爷快来玩啊\n- jenkins收到消息，兽性大发地下了github上的代码\n- 拥有hexo环境的jenkins直接执行hexo g，产生了分泌物，也就是静态文件，在这里就是[jianyujianyu.com](https://www.jianyujianyu.com)的html网页内容（hexo/public）\n- 待定的nginx直接将用户请求拉向[jianyujianyu.com](https://www.jianyujianyu.com)的hexo/public文件夹即可\n\n简单地设计完，便是动手开始。\n\n<!-- more -->\n\n\n\n## 环境准备\n\n*所有操作都是在Ubuntu的root用户下进行的，其他环境自行处理或转换*\n\n### Java、Tomcat和Jenkins\n\njenkins是java的美好产物，为了后面调试起来简单，使用tomcat容器来装着这产物，而不是直接用apt下载。\n\n（如果为了快捷，也可以只下载java和jenkins，然后通过`java -jar jenkins.war`来运行。不推荐。）\n\n因此我们首先安装J8。\n\n```\nadd-apt-repository ppa:webupd8team/java\napt update\napt install oracle-java8-installer\n```\n\n之后是安装tomcat。对应着J8，选tomcat8。先去[tomcat官网](http://tomcat.apache.org/)下载包，然后解压。\n\n```\nwget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.0.43/bin/apache-tomcat-8.0.43.tar.gz\ntar zxvf apache-tomcat-8.0.43.tar.gz\n```\n\n接着是上[jenkins官网](https://jenkins.io)下载jenkins的war包。\n\n```\nwget http://ftp-chi.osuosl.org/pub/jenkins/war-stable/2.46.1/jenkins.war\n```\n\nwar包就放在tomcat文件夹的webapps下即可。\n\n然后启动tomcat，进入tomcat文件夹的bin下，启动：\n\n```\n./startup.sh\n```\n\n接下来就可以尝试通过网页登录tomcat以及jenkins了。在浏览器中打开[http://服务器的ip:8080](#)，\n\n![tomcat主页](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-25_19-45-36.png)\n\n然后打开[http://服务器的ip:8080/jenkins](#)，根据知识安装jenkins环境，安装推荐环境即可，不需要自己选择，因为推荐环境已经包含了我们需要的插件。***如果要nginx反向代理tomcat，推荐先做完后面nginx的反向代理再安装jenkins***。\n\n按照提示输入password，然后选择推荐安装：\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-23-43.png)\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-19.png)\n\n正在安装，要等一下\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-30.png)\n\n账号密码以及权限的事自行考虑\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_12-20-38.png)\n\n\n\n### Nodejs、NPM和hexo\n\nhexo是nodejs的产物，因此搭建nodejs环境是必须的。而安装nodejs推荐在[官网](https://nodejs.org/en/)上下载源码编译，不然apt得到的都是旧的，没办法，node这两年发展得太快了。\n\n```\nwget https://nodejs.org/dist/v6.10.2/node-v6.10.2.tar.gz\ntar zxvf node-v6.10.2.tar.gz\ncd node-v6.10.2\n./configure\nmake\nmake install\n```\n\nmake可自行通过参数-j来加速编译。\n\n安装好了node，npm也接着来了，如果在安装过程中觉得npm下载太慢可以是用[淘宝镜像](http://npm.taobao.org/)，使用方法自行查询。\n\n然后照着[hexo官方文档](https://hexo.io/docs/)的方法安装hexo已经相关环境\n\n```\nnpm install hexo-cli -g\nhexo init hexo\ncd hexo\nnpm install\n```\n\nhexo的命令很简单，有了hexo的环境之后可以通过命令生成静态文件或者启动临时服务器：\n\n```\nhexo g # generate static file\nhexo s # start a server\n```\n\n在生成静态文件后，将nginx配置到hexo/public下面，请求即可到达；在启动hexo临时服务器后，即可访问http://服务器的ip:4000/jenkins。\n\n至此，hexo环境已经是完成了。\n\n如果说还有什么需要在这一步做的话， 那应该就是将代码push到git上，这个事我就不多说了。\n\n\n\n### Nginx\n\n安装nginx十分简单，但是在这次的实验中，nginx地位也不算低，80或者443端口要配置到hexo/public下，最好还要给tomcat配置反向代理。在以后的安全和优化方面，nginx需要配置的也不少。\n\n安装nginx也就一句\n\n```\napt install nginx\n```\n\n然后便是对配置的修改（我直接改default配置文件，别的方法自行实施）\n\n```\nvim /etc/nginx/sites-available/default\n```\n\n在开放80或者443的端口的server里面配置好root，例：\n\n```\nroot /var/www/hexo/public;\n```\n\n推荐给tomcat上个反向代理，\n\n```\nupstream tomcat  {\n        server  127.0.0.1:8080;\n}\n\nserver {\n        listen 11111;\n        listen [::]:11111;\n\n        location / {\n                #try_files $uri $uri/ =404;\n                proxy_pass   http://tomcat;\n                proxy_redirect  off;\n                proxy_set_header Host $host:$server_port;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                proxy_set_header Request-Url $request_uri;\n        }\n}\n```\n\n以上需要注意的是proxy_set_header需要配置好，不然后面可能无法跳转到对的路径。\n\n\n\n## 配置Github和Jenkins\n\n### 创建job\n\n![创建job](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.43.29%20PM.png)\n\n点击create new jobs，选择freestyle，填好job名字。\n\n![选择freestyle](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.44.11%20PM.png)\n\n创建了job以后，jenkins紧接着就是让你配置jenkins，如果这次不配置也没什么，因为创建的job已经保存好了。\n\n\n\n### 配置密钥\n\n如果我在github上的代码库是私密的而不是公开的，那么jenkins想要拉取到我的代码必须要有相应的私钥。至于哪一台机上的公钥私钥没什么所谓，重要的是github上有一台机的公钥，而jenkins上应该也有这台机的私钥。当然前提是github上的代码库是私密的，公开的无所谓。\n\n先在Jenkins添加私钥。\n\n![创建一个证书](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.36%20PM.png)\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.56%20PM.png)\n\n![填入git平台的公钥对应的私钥](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.52.30%20PM.png)\n\n查出private key往上填就行，为了保密我就不填真实username了。至于怎么生成key，自行查找ssh-keygen命令，或者参考类似[Github的文档](https://help.github.com/articles/connecting-to-github-with-ssh/)。\n\n\n\n### 配置WebHook\n\n配置webhook是在github上完成的。webhook的存在意义就是github上发生了特定事件，然后会告诉请求jenkins，以便让jenkins去拉代码进行下一步操作。\n\n例如，现在要配置的，就是每次将代码push上去后，就触发jenkins的操作。\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-29-15.png)\n\n打码处理。\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-33-0.png)\n\n\n\n### 配置job\n\n之前的环境都搭建好了，配置刚才创建的job就是关键的一步了。\n\n首先是要配置github project\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.16%20PM.png)\n\n而在源码管理里面，必须要填一个可行的、同时有权限的配置，失败则如下图，必须做到没有错误提醒\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.25%20PM.png)\n\nbrowser也顺便一填\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.34%20PM.png)\n\n而在Build Triggers里面必须要选Github hook trigger，勾选了jenkins才会接受github发来的请求\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.53%20PM.png)\n\n最后在Build，也就是构建的这部分，也填上，推荐使用shell，毕竟现在玩这些都是linux了\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.51.15%20PM.png)\n\n选择shell后，可以在文本框里面填自己部署要用到的命令，如下面的例子，cd、删除、拷贝等命令都可以。\n\n需要注意的是，某些命令没有，这个可以通过不断的测试来检验。\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.52.21%20PM.png)\n\n至此已经配置好了jenkins上的job，接下来就是调试了。\n\n\n\n## 调试\n\n调试很简单。先把代码clone下来本地，然后稍稍改动一个无关文件，再push，之后便是感受是否这套环境是否能自动化部署。\n\n### Push代码\n\n各种push方式任君选择\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.11.57%20AM.png)\n\n\n\n### 查看日志\n\npush成功后，github hook会通知所填写的jenkins，如果jenkins没有调起job，则有可能是hook或者配置job里面的Github hook trigger没有填写正确。\n\n如果是成功调起，在jenkins的hexo的job页面，左下角会看到有类似`#1`的\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.20%20AM.png)\n\n想要查看错误日志，点击左上角的Github Hook Log或者Console Output，即可根据这些日志对配置进行调整。\n\n![](https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.57%20AM.png)\n\nOutput大致都如下：\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-25-53.png)\n\n\n\n### 访问网站\n\n不是红灯一般都是成功的，访问网站体验一下，[jianyujianyu.com](https://www.jianyujianyu.com/) ：\n\n![](https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-28-45.png)\n\n没毛病。\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n","slug":"using-github-and-jenkins-deploy-hexo","published":1,"updated":"2017-05-10T05:37:39.000Z","_id":"cj22nsvtm000039evhhrpeowc","comments":1,"layout":"post","photos":[],"link":"","content":"<p><em>使用jenkins来部署hexo简直就是小题大做，但是偶尔这样小题大做还真有折腾的乐趣</em></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>之前是使用typecho做博客的。</p>\n<p>原因很简单，wordpress太重，hexo很轻没错，可是这个没有后台管理（听说可以折腾成有后台管理的），每次写完博客都要deploy一下的hexo，我真心要不起。</p>\n<p>而现在<a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>是hexo了，经过也很简单，就是因为CA证书过期了，换证书的时候弄砸了，本着顺便过滤一波辣鸡博客的心思，重新弄，这次选择了hexo，不为什么，人生的选择就是这么奇妙。</p>\n<p>那怎么不自己手写一个？说得好！不过我才不要。</p>\n<p>用hexo不是不行，是要考虑deploy的事，或者，我换台电脑写博客，我没有这个hexo的node环境，我也不想登录服务器用着vim来写，比如我现在就安静在公司电脑上写博客。在这样的情况下，怎么deploy呢？在从前，wordpress和typecho有着后台管理，这个问题根本是不存在的。</p>\n<p>想着想着，一拍脑袋，就直接用jenkins了，然后把代码放在github，包括hexo的整个文件夹。至于为啥用github而不用coding甚至是github pages，never mind。</p>\n<p>设计的deploy过程很简单：</p>\n<ul>\n<li>我先clone了github上的hexo文件夹，添加了md文章，然后push</li>\n<li>github整理好代码就通知jenkins：我这里资源更新了，大爷快来玩啊</li>\n<li>jenkins收到消息，兽性大发地下了github上的代码</li>\n<li>拥有hexo环境的jenkins直接执行hexo g，产生了分泌物，也就是静态文件，在这里就是<a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>的html网页内容（hexo/public）</li>\n<li>待定的nginx直接将用户请求拉向<a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>的hexo/public文件夹即可</li>\n</ul>\n<p>简单地设计完，便是动手开始。</p>\n<a id=\"more\"></a>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p><em>所有操作都是在Ubuntu的root用户下进行的，其他环境自行处理或转换</em></p>\n<h3 id=\"Java、Tomcat和Jenkins\"><a href=\"#Java、Tomcat和Jenkins\" class=\"headerlink\" title=\"Java、Tomcat和Jenkins\"></a>Java、Tomcat和Jenkins</h3><p>jenkins是java的美好产物，为了后面调试起来简单，使用tomcat容器来装着这产物，而不是直接用apt下载。</p>\n<p>（如果为了快捷，也可以只下载java和jenkins，然后通过<code>java -jar jenkins.war</code>来运行。不推荐。）</p>\n<p>因此我们首先安装J8。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">add-apt-repository ppa:webupd8team/java</div><div class=\"line\">apt update</div><div class=\"line\">apt install oracle-java8-installer</div></pre></td></tr></table></figure>\n<p>之后是安装tomcat。对应着J8，选tomcat8。先去<a href=\"http://tomcat.apache.org/\" target=\"_blank\" rel=\"external\">tomcat官网</a>下载包，然后解压。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.0.43/bin/apache-tomcat-8.0.43.tar.gz</div><div class=\"line\">tar zxvf apache-tomcat-8.0.43.tar.gz</div></pre></td></tr></table></figure>\n<p>接着是上<a href=\"https://jenkins.io\" target=\"_blank\" rel=\"external\">jenkins官网</a>下载jenkins的war包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://ftp-chi.osuosl.org/pub/jenkins/war-stable/2.46.1/jenkins.war</div></pre></td></tr></table></figure>\n<p>war包就放在tomcat文件夹的webapps下即可。</p>\n<p>然后启动tomcat，进入tomcat文件夹的bin下，启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./startup.sh</div></pre></td></tr></table></figure>\n<p>接下来就可以尝试通过网页登录tomcat以及jenkins了。在浏览器中打开<a href=\"#\">http://服务器的ip:8080</a>，</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-25_19-45-36.png\" alt=\"tomcat主页\"></p>\n<p>然后打开<a href=\"#\">http://服务器的ip:8080/jenkins</a>，根据知识安装jenkins环境，安装推荐环境即可，不需要自己选择，因为推荐环境已经包含了我们需要的插件。<strong><em>如果要nginx反向代理tomcat，推荐先做完后面nginx的反向代理再安装jenkins</em></strong>。</p>\n<p>按照提示输入password，然后选择推荐安装：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-23-43.png\" alt=\"\"></p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-19.png\" alt=\"\"></p>\n<p>正在安装，要等一下</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-30.png\" alt=\"\"></p>\n<p>账号密码以及权限的事自行考虑</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_12-20-38.png\" alt=\"\"></p>\n<h3 id=\"Nodejs、NPM和hexo\"><a href=\"#Nodejs、NPM和hexo\" class=\"headerlink\" title=\"Nodejs、NPM和hexo\"></a>Nodejs、NPM和hexo</h3><p>hexo是nodejs的产物，因此搭建nodejs环境是必须的。而安装nodejs推荐在<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">官网</a>上下载源码编译，不然apt得到的都是旧的，没办法，node这两年发展得太快了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://nodejs.org/dist/v6.10.2/node-v6.10.2.tar.gz</div><div class=\"line\">tar zxvf node-v6.10.2.tar.gz</div><div class=\"line\">cd node-v6.10.2</div><div class=\"line\">./configure</div><div class=\"line\">make</div><div class=\"line\">make install</div></pre></td></tr></table></figure>\n<p>make可自行通过参数-j来加速编译。</p>\n<p>安装好了node，npm也接着来了，如果在安装过程中觉得npm下载太慢可以是用<a href=\"http://npm.taobao.org/\" target=\"_blank\" rel=\"external\">淘宝镜像</a>，使用方法自行查询。</p>\n<p>然后照着<a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">hexo官方文档</a>的方法安装hexo已经相关环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div><div class=\"line\">hexo init hexo</div><div class=\"line\">cd hexo</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>hexo的命令很简单，有了hexo的环境之后可以通过命令生成静态文件或者启动临时服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g # generate static file</div><div class=\"line\">hexo s # start a server</div></pre></td></tr></table></figure>\n<p>在生成静态文件后，将nginx配置到hexo/public下面，请求即可到达；在启动hexo临时服务器后，即可访问<a href=\"http://服务器的ip:4000/jenkins。\" target=\"_blank\" rel=\"external\">http://服务器的ip:4000/jenkins。</a></p>\n<p>至此，hexo环境已经是完成了。</p>\n<p>如果说还有什么需要在这一步做的话， 那应该就是将代码push到git上，这个事我就不多说了。</p>\n<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><p>安装nginx十分简单，但是在这次的实验中，nginx地位也不算低，80或者443端口要配置到hexo/public下，最好还要给tomcat配置反向代理。在以后的安全和优化方面，nginx需要配置的也不少。</p>\n<p>安装nginx也就一句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt install nginx</div></pre></td></tr></table></figure>\n<p>然后便是对配置的修改（我直接改default配置文件，别的方法自行实施）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim /etc/nginx/sites-available/default</div></pre></td></tr></table></figure>\n<p>在开放80或者443的端口的server里面配置好root，例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">root /var/www/hexo/public;</div></pre></td></tr></table></figure>\n<p>推荐给tomcat上个反向代理，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream tomcat  &#123;</div><div class=\"line\">        server  127.0.0.1:8080;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">server &#123;</div><div class=\"line\">        listen 11111;</div><div class=\"line\">        listen [::]:11111;</div><div class=\"line\"></div><div class=\"line\">        location / &#123;</div><div class=\"line\">                #try_files $uri $uri/ =404;</div><div class=\"line\">                proxy_pass   http://tomcat;</div><div class=\"line\">                proxy_redirect  off;</div><div class=\"line\">                proxy_set_header Host $host:$server_port;</div><div class=\"line\">                proxy_set_header X-Real-IP $remote_addr;</div><div class=\"line\">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class=\"line\">                proxy_set_header Request-Url $request_uri;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上需要注意的是proxy_set_header需要配置好，不然后面可能无法跳转到对的路径。</p>\n<h2 id=\"配置Github和Jenkins\"><a href=\"#配置Github和Jenkins\" class=\"headerlink\" title=\"配置Github和Jenkins\"></a>配置Github和Jenkins</h2><h3 id=\"创建job\"><a href=\"#创建job\" class=\"headerlink\" title=\"创建job\"></a>创建job</h3><p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.43.29%20PM.png\" alt=\"创建job\"></p>\n<p>点击create new jobs，选择freestyle，填好job名字。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.44.11%20PM.png\" alt=\"选择freestyle\"></p>\n<p>创建了job以后，jenkins紧接着就是让你配置jenkins，如果这次不配置也没什么，因为创建的job已经保存好了。</p>\n<h3 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h3><p>如果我在github上的代码库是私密的而不是公开的，那么jenkins想要拉取到我的代码必须要有相应的私钥。至于哪一台机上的公钥私钥没什么所谓，重要的是github上有一台机的公钥，而jenkins上应该也有这台机的私钥。当然前提是github上的代码库是私密的，公开的无所谓。</p>\n<p>先在Jenkins添加私钥。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.36%20PM.png\" alt=\"创建一个证书\"></p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.56%20PM.png\" alt=\"\"></p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.52.30%20PM.png\" alt=\"填入git平台的公钥对应的私钥\"></p>\n<p>查出private key往上填就行，为了保密我就不填真实username了。至于怎么生成key，自行查找ssh-keygen命令，或者参考类似<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"external\">Github的文档</a>。</p>\n<h3 id=\"配置WebHook\"><a href=\"#配置WebHook\" class=\"headerlink\" title=\"配置WebHook\"></a>配置WebHook</h3><p>配置webhook是在github上完成的。webhook的存在意义就是github上发生了特定事件，然后会告诉请求jenkins，以便让jenkins去拉代码进行下一步操作。</p>\n<p>例如，现在要配置的，就是每次将代码push上去后，就触发jenkins的操作。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-29-15.png\" alt=\"\"></p>\n<p>打码处理。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-33-0.png\" alt=\"\"></p>\n<h3 id=\"配置job\"><a href=\"#配置job\" class=\"headerlink\" title=\"配置job\"></a>配置job</h3><p>之前的环境都搭建好了，配置刚才创建的job就是关键的一步了。</p>\n<p>首先是要配置github project</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.16%20PM.png\" alt=\"\"></p>\n<p>而在源码管理里面，必须要填一个可行的、同时有权限的配置，失败则如下图，必须做到没有错误提醒</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.25%20PM.png\" alt=\"\"></p>\n<p>browser也顺便一填</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.34%20PM.png\" alt=\"\"></p>\n<p>而在Build Triggers里面必须要选Github hook trigger，勾选了jenkins才会接受github发来的请求</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.53%20PM.png\" alt=\"\"></p>\n<p>最后在Build，也就是构建的这部分，也填上，推荐使用shell，毕竟现在玩这些都是linux了</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.51.15%20PM.png\" alt=\"\"></p>\n<p>选择shell后，可以在文本框里面填自己部署要用到的命令，如下面的例子，cd、删除、拷贝等命令都可以。</p>\n<p>需要注意的是，某些命令没有，这个可以通过不断的测试来检验。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.52.21%20PM.png\" alt=\"\"></p>\n<p>至此已经配置好了jenkins上的job，接下来就是调试了。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>调试很简单。先把代码clone下来本地，然后稍稍改动一个无关文件，再push，之后便是感受是否这套环境是否能自动化部署。</p>\n<h3 id=\"Push代码\"><a href=\"#Push代码\" class=\"headerlink\" title=\"Push代码\"></a>Push代码</h3><p>各种push方式任君选择</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.11.57%20AM.png\" alt=\"\"></p>\n<h3 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h3><p>push成功后，github hook会通知所填写的jenkins，如果jenkins没有调起job，则有可能是hook或者配置job里面的Github hook trigger没有填写正确。</p>\n<p>如果是成功调起，在jenkins的hexo的job页面，左下角会看到有类似<code>#1</code>的</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.20%20AM.png\" alt=\"\"></p>\n<p>想要查看错误日志，点击左上角的Github Hook Log或者Console Output，即可根据这些日志对配置进行调整。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.57%20AM.png\" alt=\"\"></p>\n<p>Output大致都如下：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-25-53.png\" alt=\"\"></p>\n<h3 id=\"访问网站\"><a href=\"#访问网站\" class=\"headerlink\" title=\"访问网站\"></a>访问网站</h3><p>不是红灯一般都是成功的，访问网站体验一下，<a href=\"https://www.jianyujianyu.com/\">jianyujianyu.com</a> ：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-28-45.png\" alt=\"\"></p>\n<p>没毛病。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><em>使用jenkins来部署hexo简直就是小题大做，但是偶尔这样小题大做还真有折腾的乐趣</em></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>之前是使用typecho做博客的。</p>\n<p>原因很简单，wordpress太重，hexo很轻没错，可是这个没有后台管理（听说可以折腾成有后台管理的），每次写完博客都要deploy一下的hexo，我真心要不起。</p>\n<p>而现在<a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>是hexo了，经过也很简单，就是因为CA证书过期了，换证书的时候弄砸了，本着顺便过滤一波辣鸡博客的心思，重新弄，这次选择了hexo，不为什么，人生的选择就是这么奇妙。</p>\n<p>那怎么不自己手写一个？说得好！不过我才不要。</p>\n<p>用hexo不是不行，是要考虑deploy的事，或者，我换台电脑写博客，我没有这个hexo的node环境，我也不想登录服务器用着vim来写，比如我现在就安静在公司电脑上写博客。在这样的情况下，怎么deploy呢？在从前，wordpress和typecho有着后台管理，这个问题根本是不存在的。</p>\n<p>想着想着，一拍脑袋，就直接用jenkins了，然后把代码放在github，包括hexo的整个文件夹。至于为啥用github而不用coding甚至是github pages，never mind。</p>\n<p>设计的deploy过程很简单：</p>\n<ul>\n<li>我先clone了github上的hexo文件夹，添加了md文章，然后push</li>\n<li>github整理好代码就通知jenkins：我这里资源更新了，大爷快来玩啊</li>\n<li>jenkins收到消息，兽性大发地下了github上的代码</li>\n<li>拥有hexo环境的jenkins直接执行hexo g，产生了分泌物，也就是静态文件，在这里就是<a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>的html网页内容（hexo/public）</li>\n<li>待定的nginx直接将用户请求拉向<a href=\"https://www.jianyujianyu.com\">jianyujianyu.com</a>的hexo/public文件夹即可</li>\n</ul>\n<p>简单地设计完，便是动手开始。</p>","more":"<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p><em>所有操作都是在Ubuntu的root用户下进行的，其他环境自行处理或转换</em></p>\n<h3 id=\"Java、Tomcat和Jenkins\"><a href=\"#Java、Tomcat和Jenkins\" class=\"headerlink\" title=\"Java、Tomcat和Jenkins\"></a>Java、Tomcat和Jenkins</h3><p>jenkins是java的美好产物，为了后面调试起来简单，使用tomcat容器来装着这产物，而不是直接用apt下载。</p>\n<p>（如果为了快捷，也可以只下载java和jenkins，然后通过<code>java -jar jenkins.war</code>来运行。不推荐。）</p>\n<p>因此我们首先安装J8。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">add-apt-repository ppa:webupd8team/java</div><div class=\"line\">apt update</div><div class=\"line\">apt install oracle-java8-installer</div></pre></td></tr></table></figure>\n<p>之后是安装tomcat。对应着J8，选tomcat8。先去<a href=\"http://tomcat.apache.org/\">tomcat官网</a>下载包，然后解压。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.0.43/bin/apache-tomcat-8.0.43.tar.gz</div><div class=\"line\">tar zxvf apache-tomcat-8.0.43.tar.gz</div></pre></td></tr></table></figure>\n<p>接着是上<a href=\"https://jenkins.io\">jenkins官网</a>下载jenkins的war包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://ftp-chi.osuosl.org/pub/jenkins/war-stable/2.46.1/jenkins.war</div></pre></td></tr></table></figure>\n<p>war包就放在tomcat文件夹的webapps下即可。</p>\n<p>然后启动tomcat，进入tomcat文件夹的bin下，启动：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./startup.sh</div></pre></td></tr></table></figure>\n<p>接下来就可以尝试通过网页登录tomcat以及jenkins了。在浏览器中打开<a href=\"#\">http://服务器的ip:8080</a>，</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-25_19-45-36.png\" alt=\"tomcat主页\"></p>\n<p>然后打开<a href=\"#\">http://服务器的ip:8080/jenkins</a>，根据知识安装jenkins环境，安装推荐环境即可，不需要自己选择，因为推荐环境已经包含了我们需要的插件。<strong><em>如果要nginx反向代理tomcat，推荐先做完后面nginx的反向代理再安装jenkins</em></strong>。</p>\n<p>按照提示输入password，然后选择推荐安装：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-23-43.png\" alt=\"\"></p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-19.png\" alt=\"\"></p>\n<p>正在安装，要等一下</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_11-28-30.png\" alt=\"\"></p>\n<p>账号密码以及权限的事自行考虑</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_12-20-38.png\" alt=\"\"></p>\n<h3 id=\"Nodejs、NPM和hexo\"><a href=\"#Nodejs、NPM和hexo\" class=\"headerlink\" title=\"Nodejs、NPM和hexo\"></a>Nodejs、NPM和hexo</h3><p>hexo是nodejs的产物，因此搭建nodejs环境是必须的。而安装nodejs推荐在<a href=\"https://nodejs.org/en/\">官网</a>上下载源码编译，不然apt得到的都是旧的，没办法，node这两年发展得太快了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://nodejs.org/dist/v6.10.2/node-v6.10.2.tar.gz</div><div class=\"line\">tar zxvf node-v6.10.2.tar.gz</div><div class=\"line\">cd node-v6.10.2</div><div class=\"line\">./configure</div><div class=\"line\">make</div><div class=\"line\">make install</div></pre></td></tr></table></figure>\n<p>make可自行通过参数-j来加速编译。</p>\n<p>安装好了node，npm也接着来了，如果在安装过程中觉得npm下载太慢可以是用<a href=\"http://npm.taobao.org/\">淘宝镜像</a>，使用方法自行查询。</p>\n<p>然后照着<a href=\"https://hexo.io/docs/\">hexo官方文档</a>的方法安装hexo已经相关环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div><div class=\"line\">hexo init hexo</div><div class=\"line\">cd hexo</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>hexo的命令很简单，有了hexo的环境之后可以通过命令生成静态文件或者启动临时服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g # generate static file</div><div class=\"line\">hexo s # start a server</div></pre></td></tr></table></figure>\n<p>在生成静态文件后，将nginx配置到hexo/public下面，请求即可到达；在启动hexo临时服务器后，即可访问<a href=\"http://服务器的ip:4000/jenkins。\">http://服务器的ip:4000/jenkins。</a></p>\n<p>至此，hexo环境已经是完成了。</p>\n<p>如果说还有什么需要在这一步做的话， 那应该就是将代码push到git上，这个事我就不多说了。</p>\n<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><p>安装nginx十分简单，但是在这次的实验中，nginx地位也不算低，80或者443端口要配置到hexo/public下，最好还要给tomcat配置反向代理。在以后的安全和优化方面，nginx需要配置的也不少。</p>\n<p>安装nginx也就一句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt install nginx</div></pre></td></tr></table></figure>\n<p>然后便是对配置的修改（我直接改default配置文件，别的方法自行实施）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim /etc/nginx/sites-available/default</div></pre></td></tr></table></figure>\n<p>在开放80或者443的端口的server里面配置好root，例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">root /var/www/hexo/public;</div></pre></td></tr></table></figure>\n<p>推荐给tomcat上个反向代理，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream tomcat  &#123;</div><div class=\"line\">        server  127.0.0.1:8080;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">server &#123;</div><div class=\"line\">        listen 11111;</div><div class=\"line\">        listen [::]:11111;</div><div class=\"line\"></div><div class=\"line\">        location / &#123;</div><div class=\"line\">                #try_files $uri $uri/ =404;</div><div class=\"line\">                proxy_pass   http://tomcat;</div><div class=\"line\">                proxy_redirect  off;</div><div class=\"line\">                proxy_set_header Host $host:$server_port;</div><div class=\"line\">                proxy_set_header X-Real-IP $remote_addr;</div><div class=\"line\">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class=\"line\">                proxy_set_header Request-Url $request_uri;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上需要注意的是proxy_set_header需要配置好，不然后面可能无法跳转到对的路径。</p>\n<h2 id=\"配置Github和Jenkins\"><a href=\"#配置Github和Jenkins\" class=\"headerlink\" title=\"配置Github和Jenkins\"></a>配置Github和Jenkins</h2><h3 id=\"创建job\"><a href=\"#创建job\" class=\"headerlink\" title=\"创建job\"></a>创建job</h3><p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.43.29%20PM.png\" alt=\"创建job\"></p>\n<p>点击create new jobs，选择freestyle，填好job名字。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.44.11%20PM.png\" alt=\"选择freestyle\"></p>\n<p>创建了job以后，jenkins紧接着就是让你配置jenkins，如果这次不配置也没什么，因为创建的job已经保存好了。</p>\n<h3 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h3><p>如果我在github上的代码库是私密的而不是公开的，那么jenkins想要拉取到我的代码必须要有相应的私钥。至于哪一台机上的公钥私钥没什么所谓，重要的是github上有一台机的公钥，而jenkins上应该也有这台机的私钥。当然前提是github上的代码库是私密的，公开的无所谓。</p>\n<p>先在Jenkins添加私钥。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.36%20PM.png\" alt=\"创建一个证书\"></p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.48.56%20PM.png\" alt=\"\"></p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-25%20at%2010.52.30%20PM.png\" alt=\"填入git平台的公钥对应的私钥\"></p>\n<p>查出private key往上填就行，为了保密我就不填真实username了。至于怎么生成key，自行查找ssh-keygen命令，或者参考类似<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\">Github的文档</a>。</p>\n<h3 id=\"配置WebHook\"><a href=\"#配置WebHook\" class=\"headerlink\" title=\"配置WebHook\"></a>配置WebHook</h3><p>配置webhook是在github上完成的。webhook的存在意义就是github上发生了特定事件，然后会告诉请求jenkins，以便让jenkins去拉代码进行下一步操作。</p>\n<p>例如，现在要配置的，就是每次将代码push上去后，就触发jenkins的操作。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-29-15.png\" alt=\"\"></p>\n<p>打码处理。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-26_10-33-0.png\" alt=\"\"></p>\n<h3 id=\"配置job\"><a href=\"#配置job\" class=\"headerlink\" title=\"配置job\"></a>配置job</h3><p>之前的环境都搭建好了，配置刚才创建的job就是关键的一步了。</p>\n<p>首先是要配置github project</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.16%20PM.png\" alt=\"\"></p>\n<p>而在源码管理里面，必须要填一个可行的、同时有权限的配置，失败则如下图，必须做到没有错误提醒</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.25%20PM.png\" alt=\"\"></p>\n<p>browser也顺便一填</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.53.34%20PM.png\" alt=\"\"></p>\n<p>而在Build Triggers里面必须要选Github hook trigger，勾选了jenkins才会接受github发来的请求</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.49.53%20PM.png\" alt=\"\"></p>\n<p>最后在Build，也就是构建的这部分，也填上，推荐使用shell，毕竟现在玩这些都是linux了</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.51.15%20PM.png\" alt=\"\"></p>\n<p>选择shell后，可以在文本框里面填自己部署要用到的命令，如下面的例子，cd、删除、拷贝等命令都可以。</p>\n<p>需要注意的是，某些命令没有，这个可以通过不断的测试来检验。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-26%20at%2011.52.21%20PM.png\" alt=\"\"></p>\n<p>至此已经配置好了jenkins上的job，接下来就是调试了。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>调试很简单。先把代码clone下来本地，然后稍稍改动一个无关文件，再push，之后便是感受是否这套环境是否能自动化部署。</p>\n<h3 id=\"Push代码\"><a href=\"#Push代码\" class=\"headerlink\" title=\"Push代码\"></a>Push代码</h3><p>各种push方式任君选择</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.11.57%20AM.png\" alt=\"\"></p>\n<h3 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h3><p>push成功后，github hook会通知所填写的jenkins，如果jenkins没有调起job，则有可能是hook或者配置job里面的Github hook trigger没有填写正确。</p>\n<p>如果是成功调起，在jenkins的hexo的job页面，左下角会看到有类似<code>#1</code>的</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.20%20AM.png\" alt=\"\"></p>\n<p>想要查看错误日志，点击左上角的Github Hook Log或者Console Output，即可根据这些日志对配置进行调整。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/Screen%20Shot%202017-04-27%20at%2012.12.57%20AM.png\" alt=\"\"></p>\n<p>Output大致都如下：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-25-53.png\" alt=\"\"></p>\n<h3 id=\"访问网站\"><a href=\"#访问网站\" class=\"headerlink\" title=\"访问网站\"></a>访问网站</h3><p>不是红灯一般都是成功的，访问网站体验一下，<a href=\"https://www.jianyujianyu.com/\">jianyujianyu.com</a> ：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/BaiduHi_2017-4-28_10-28-45.png\" alt=\"\"></p>\n<p>没毛病。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"},{"title":"在 Ubuntu16.04 上搭建 Hadoop-2.8.0 伪分布式环境","date":"2017-05-04T14:53:39.000Z","_content":"\n***学校有几门课程的作业需要我们来写个教程，好吧。***\n\n\n\n## 环境准备\n\n### 软件安装\n\n由于该系统是英文系统，有可能对中文字符支持不友好，因此要安装中文的UTF-8字符集。同时因为Hadoop是Java的杰出产物因此需要安装Java，为了方便，在这里选用OpenJdk，版本Java8。而需要用到的vim、ssh等命令已内置在Ubuntu16.04中，因此无需重复安装。\n<!-- more -->\n\n```\nsudo su\napt install -y language-pack-zh-hant language-pack-zh-hans\napt install -y openjdk-8-jre openjdk-8-jdk\n```\n\n\n\n### 创建用户以及权限配置\n\n本次实验中我们创建一个hadoop用户，而对hadoop的使用操作都通过hadoop用户实现。同时为了方便hadoop操作中的ssh登录，我们配置无密码ssh登录。\n\n```\nuseradd -m hadoop -s /bin/bash\npasswd hadoop\nadduser hadoop sudo\nsu hadoop\n```\n\n此后，hadoop用户便是运行hadoop程序的用户，以下的操作便是以hadoop用户的身份运行的。接下来生成密钥用于无密码登录：\n\n```\nssh-keygen -t rsa \ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n![Screen Shot 2017-05-03 at 10.30.57 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.30.57 PM.png)\n\n\n\n\n配置完后即可通过`ssh localhost`命令无密码登录，需要注意的是要按提示输入yes\n\n![Screen Shot 2017-05-03 at 10.31.13 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.31.13 PM.png)\n\n\n\n### 下载hadoop并放置到约定俗成的位置\n\n这次实验的hadoop版本是2.8.0，下载使用wget命令，软件源为了快速选用国内的清华源，同时将hadoop文件夹移到约定俗成的`/usr/local`目录下。\n\n```\nwget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.8.0/hadoop-2.8.0.tar.gz\ntar zxvf hadoop-2.8.0.tar.gz\n```\n\n![Screen Shot 2017-05-03 at 10.32.49 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.32.49 PM.png)\n\n```\nmv hadoop-2.8.0 hadoop\nsudo mv hadoop /usr/local/\nsudo chown -R hadoop /usr/local/hadoop\ncd /usr/local/hadoop/\n```\n\n此后，`/usr/local/hadoop`这个目录便是hadoop目录，下面的操作都是在目录下操作的。\n\n\n\n### 配置Java和Hadoop的环境变量\n\n需要在`/etc/profile`和`./etc/hadoop/hadoop-env.sh`（目前在hadoop目录下）这两个文件的末尾加入以下变量：\n\n```\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\nCLASSPATH=$CLASSPATH.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin\nexport HADOOP_HOME=/usr/local/hadoop\nexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native\n```\n\n修改第一个文件就是修改当前的环境变量，修改第二个文件就是修改ssh后的环境变量。\n\n这些就是Java和Hadoop的环境变量，加载了这些环境变量即可在命令行运行特定命令，现在重新加载这配置文件：\n\n```\n. /etc/profile\n```\n\n\n\n## 配置伪分布式环境\n\n### 初始化hdfs\n\n编辑./etc/hadoop/core-site.xml和./etc/hadoop/hdfs-site.xml两个文件\n\n```\nvim ./etc/hadoop/core-site.xml\n```\n\n修改里面配置，感兴趣的可以查一下含义，主要是每一个property的name和value：\n\n```\n<configuration>\n        <property>\n             <name>hadoop.tmp.dir</name>\n             <value>file:/usr/local/hadoop/tmp</value>\n             <description>Abase for other temporary directories.</description>\n        </property>\n        <property>\n             <name>fs.defaultFS</name>\n             <value>hdfs://localhost:9000</value>\n        </property>\n</configuration>\n```\n\n\n\n```\nvim ./etc/hadoop/hdfs-site.xml\n```\n\n修改里面配置，指名name、data文件夹在这个服务器上的路径（因为是伪分布式，所以都在这个服务器上）：\n\n```\n<configuration>\n        <property>\n             <name>dfs.replication</name>\n             <value>1</value>\n        </property>\n        <property>\n             <name>dfs.namenode.name.dir</name>\n             <value>file:/usr/local/hadoop/tmp/dfs/name</value>\n        </property>\n        <property>\n             <name>dfs.datanode.data.dir</name>\n             <value>file:/usr/local/hadoop/tmp/dfs/data</value>\n        </property>\n</configuration>\n```\n\n以上就完成了伪分布式的配置，接下来就是格式化这些存储节点\n\n```\n./bin/hdfs namenode -format\n```\n\n![Screen Shot 2017-05-03 at 11.20.51 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.20.51 PM.png)\n\n中间太多了略过直接看末尾：\n\n![Screen Shot 2017-05-03 at 11.21.37 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.21.37 PM.png)\n\n在此看到Exiting status为0，结合大多数程序和系统脚本，结束状态码为0即为正常运行结束。\n\n\n\n\n### 开启 NameNode 和 DataNode 守护进程\n\n运行`./sbin/start-dfs.sh`命令即可启动\n\n![Screen Shot 2017-05-03 at 11.23.40 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.23.40 PM.png)\n\n\n\n注意本次运行以及以后的运行程序有可能出现以下WARN：\n\n```\nWARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable\n```\n\n该 WARN 提示可以忽略，并不会影响正常使用（该 WARN 可以通过编译 Hadoop 源码解决）。\n\n\n\n而后即可通过 http://机器ip:50070 来访问 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。\n\n![Screen Shot 2017-05-03 at 10.44.18 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.44.18 PM.png)\n\n\n在命令界面也可以通过`jps`来查看 NameNode 和 Datanode 信息是否在运行。\n\n\n\n## 运行例子\n\n### 命令查看\n\n可以通过`./bin/hdfs dfs -help`命令来查看使用方法：\n\n![Screen Shot 2017-05-03 at 11.24.41 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.24.41 PM.png)\n\n\n例如查看hadoop版本的命令：\n\n![Screen Shot 2017-05-03 at 11.19.25 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.19.25 PM.png)\n\n\n\n### 在 HDFS 中创建用户目录\n\n先通过`./bin/hdfs dfs -mkdir -p /user/hadoop`命令创建一个用户目录\n\n\n\n### 例子一 解析配置文件\n\n本次实验可以就地取材，选择hadoop的配置文件为材料，使用伪分布式hadoop平台来解析。先用put命令把配置文件都放入hdfs的一个新建文件夹input：\n\n```\n./bin/hdfs dfs -mkdir /user/hadoop/input\n./bin/hdfs dfs -put ./etc/hadoop/*.xml /user/hadoop/input/\n./bin/hdfs dfs -ls input\n```\n\n![Screen Shot 2017-05-03 at 11.08.16 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.08.16 PM.png)\n\n然后运行例子，解析input里面的配置文件，并将解析结果放入output文件夹：\n\n```\n./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /user/hadoop/input/* /user/hadoop/output 'dfs[a-z.]+'\n```\n\n![Screen Shot 2017-05-03 at 11.09.22 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.22 PM.png)\n\n\n把output里面的解析结果通过cat命令输出：\n\n```\n./bin/hdfs dfs -cat /user/hadoop/output/*\n```\n\n![Screen Shot 2017-05-03 at 11.09.52 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.52 PM.png)\n\n\n把output里面的解析结果从hdfs中取出（这个操作是常用的，尽管在伪分布式里面没什么意义，但是在真实环境下特别有用）：\n\n```\n./bin/hdfs dfs -get /user/hadoop/output ./output\n```\n\n\n\n### 例子二 WordCount\n\nwordcount是一个hadoop内置的范例程序，用于统计单词数量。\n\n首先，要删除例子一留下的实验痕迹：\n\n```\n./bin/hdfs dfs -rm -r -f /user/hadoop/output /user/hadoop/input\n```\n\n![Screen Shot 2017-05-03 at 11.15.36 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.15.36 PM.png)\n\n\n然后和实验一一样，创建hadoop的输入文件夹，同时就地取材一个可读文件：\n\n```\n./bin/hdfs dfs -mkdir /user/hadoop/input\n./bin/hdfs dfs  -put LICENSE.txt  /user/hadoop/input/LICENSE.txt\n./bin/hdfs dfs  -ls /user/hadoop/input\n```\n\n运行例子，结果放置在output文件夹：\n\n```\n./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.0.jar wordcount /user/hadoop/input /user/hadoop/output\n./bin/hdfs dfs -cat /user/hadoop/output/*\n```\n\n![Screen Shot 2017-05-03 at 11.16.23 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.16.23 PM.png)\n\n\n可以看到，屏幕是被刷了好几遍，因为输出太多了，我们可以统计一下输出了有多少行：\n\n```\n./bin/hdfs dfs -cat /user/hadoop/output/* | wc -l\n```\n\n![Screen Shot 2017-05-03 at 11.17.34 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.17.34 PM.png)\n\n噢，原来有2000多行的输出呢！\n\n\n\n\n## 结论\n\nhadoop的思想已经融入了我们很多分布式系统里面，熟悉hadoop的思想和操作有助于我们更宏观地观察这个现代化网络世界。\n\n\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n","source":"_posts/ubuntu16.04-hadoop2.8.0.md","raw":"title: 在 Ubuntu16.04 上搭建 Hadoop-2.8.0 伪分布式环境\ncategories: distributed\ntags: [hadoop,distributed]\ndate: 2017-05-04 22:53:39\n---\n\n***学校有几门课程的作业需要我们来写个教程，好吧。***\n\n\n\n## 环境准备\n\n### 软件安装\n\n由于该系统是英文系统，有可能对中文字符支持不友好，因此要安装中文的UTF-8字符集。同时因为Hadoop是Java的杰出产物因此需要安装Java，为了方便，在这里选用OpenJdk，版本Java8。而需要用到的vim、ssh等命令已内置在Ubuntu16.04中，因此无需重复安装。\n<!-- more -->\n\n```\nsudo su\napt install -y language-pack-zh-hant language-pack-zh-hans\napt install -y openjdk-8-jre openjdk-8-jdk\n```\n\n\n\n### 创建用户以及权限配置\n\n本次实验中我们创建一个hadoop用户，而对hadoop的使用操作都通过hadoop用户实现。同时为了方便hadoop操作中的ssh登录，我们配置无密码ssh登录。\n\n```\nuseradd -m hadoop -s /bin/bash\npasswd hadoop\nadduser hadoop sudo\nsu hadoop\n```\n\n此后，hadoop用户便是运行hadoop程序的用户，以下的操作便是以hadoop用户的身份运行的。接下来生成密钥用于无密码登录：\n\n```\nssh-keygen -t rsa \ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n![Screen Shot 2017-05-03 at 10.30.57 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.30.57 PM.png)\n\n\n\n\n配置完后即可通过`ssh localhost`命令无密码登录，需要注意的是要按提示输入yes\n\n![Screen Shot 2017-05-03 at 10.31.13 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.31.13 PM.png)\n\n\n\n### 下载hadoop并放置到约定俗成的位置\n\n这次实验的hadoop版本是2.8.0，下载使用wget命令，软件源为了快速选用国内的清华源，同时将hadoop文件夹移到约定俗成的`/usr/local`目录下。\n\n```\nwget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.8.0/hadoop-2.8.0.tar.gz\ntar zxvf hadoop-2.8.0.tar.gz\n```\n\n![Screen Shot 2017-05-03 at 10.32.49 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.32.49 PM.png)\n\n```\nmv hadoop-2.8.0 hadoop\nsudo mv hadoop /usr/local/\nsudo chown -R hadoop /usr/local/hadoop\ncd /usr/local/hadoop/\n```\n\n此后，`/usr/local/hadoop`这个目录便是hadoop目录，下面的操作都是在目录下操作的。\n\n\n\n### 配置Java和Hadoop的环境变量\n\n需要在`/etc/profile`和`./etc/hadoop/hadoop-env.sh`（目前在hadoop目录下）这两个文件的末尾加入以下变量：\n\n```\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\nCLASSPATH=$CLASSPATH.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin\nexport HADOOP_HOME=/usr/local/hadoop\nexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native\n```\n\n修改第一个文件就是修改当前的环境变量，修改第二个文件就是修改ssh后的环境变量。\n\n这些就是Java和Hadoop的环境变量，加载了这些环境变量即可在命令行运行特定命令，现在重新加载这配置文件：\n\n```\n. /etc/profile\n```\n\n\n\n## 配置伪分布式环境\n\n### 初始化hdfs\n\n编辑./etc/hadoop/core-site.xml和./etc/hadoop/hdfs-site.xml两个文件\n\n```\nvim ./etc/hadoop/core-site.xml\n```\n\n修改里面配置，感兴趣的可以查一下含义，主要是每一个property的name和value：\n\n```\n<configuration>\n        <property>\n             <name>hadoop.tmp.dir</name>\n             <value>file:/usr/local/hadoop/tmp</value>\n             <description>Abase for other temporary directories.</description>\n        </property>\n        <property>\n             <name>fs.defaultFS</name>\n             <value>hdfs://localhost:9000</value>\n        </property>\n</configuration>\n```\n\n\n\n```\nvim ./etc/hadoop/hdfs-site.xml\n```\n\n修改里面配置，指名name、data文件夹在这个服务器上的路径（因为是伪分布式，所以都在这个服务器上）：\n\n```\n<configuration>\n        <property>\n             <name>dfs.replication</name>\n             <value>1</value>\n        </property>\n        <property>\n             <name>dfs.namenode.name.dir</name>\n             <value>file:/usr/local/hadoop/tmp/dfs/name</value>\n        </property>\n        <property>\n             <name>dfs.datanode.data.dir</name>\n             <value>file:/usr/local/hadoop/tmp/dfs/data</value>\n        </property>\n</configuration>\n```\n\n以上就完成了伪分布式的配置，接下来就是格式化这些存储节点\n\n```\n./bin/hdfs namenode -format\n```\n\n![Screen Shot 2017-05-03 at 11.20.51 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.20.51 PM.png)\n\n中间太多了略过直接看末尾：\n\n![Screen Shot 2017-05-03 at 11.21.37 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.21.37 PM.png)\n\n在此看到Exiting status为0，结合大多数程序和系统脚本，结束状态码为0即为正常运行结束。\n\n\n\n\n### 开启 NameNode 和 DataNode 守护进程\n\n运行`./sbin/start-dfs.sh`命令即可启动\n\n![Screen Shot 2017-05-03 at 11.23.40 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.23.40 PM.png)\n\n\n\n注意本次运行以及以后的运行程序有可能出现以下WARN：\n\n```\nWARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable\n```\n\n该 WARN 提示可以忽略，并不会影响正常使用（该 WARN 可以通过编译 Hadoop 源码解决）。\n\n\n\n而后即可通过 http://机器ip:50070 来访问 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。\n\n![Screen Shot 2017-05-03 at 10.44.18 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.44.18 PM.png)\n\n\n在命令界面也可以通过`jps`来查看 NameNode 和 Datanode 信息是否在运行。\n\n\n\n## 运行例子\n\n### 命令查看\n\n可以通过`./bin/hdfs dfs -help`命令来查看使用方法：\n\n![Screen Shot 2017-05-03 at 11.24.41 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.24.41 PM.png)\n\n\n例如查看hadoop版本的命令：\n\n![Screen Shot 2017-05-03 at 11.19.25 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.19.25 PM.png)\n\n\n\n### 在 HDFS 中创建用户目录\n\n先通过`./bin/hdfs dfs -mkdir -p /user/hadoop`命令创建一个用户目录\n\n\n\n### 例子一 解析配置文件\n\n本次实验可以就地取材，选择hadoop的配置文件为材料，使用伪分布式hadoop平台来解析。先用put命令把配置文件都放入hdfs的一个新建文件夹input：\n\n```\n./bin/hdfs dfs -mkdir /user/hadoop/input\n./bin/hdfs dfs -put ./etc/hadoop/*.xml /user/hadoop/input/\n./bin/hdfs dfs -ls input\n```\n\n![Screen Shot 2017-05-03 at 11.08.16 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.08.16 PM.png)\n\n然后运行例子，解析input里面的配置文件，并将解析结果放入output文件夹：\n\n```\n./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /user/hadoop/input/* /user/hadoop/output 'dfs[a-z.]+'\n```\n\n![Screen Shot 2017-05-03 at 11.09.22 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.22 PM.png)\n\n\n把output里面的解析结果通过cat命令输出：\n\n```\n./bin/hdfs dfs -cat /user/hadoop/output/*\n```\n\n![Screen Shot 2017-05-03 at 11.09.52 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.52 PM.png)\n\n\n把output里面的解析结果从hdfs中取出（这个操作是常用的，尽管在伪分布式里面没什么意义，但是在真实环境下特别有用）：\n\n```\n./bin/hdfs dfs -get /user/hadoop/output ./output\n```\n\n\n\n### 例子二 WordCount\n\nwordcount是一个hadoop内置的范例程序，用于统计单词数量。\n\n首先，要删除例子一留下的实验痕迹：\n\n```\n./bin/hdfs dfs -rm -r -f /user/hadoop/output /user/hadoop/input\n```\n\n![Screen Shot 2017-05-03 at 11.15.36 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.15.36 PM.png)\n\n\n然后和实验一一样，创建hadoop的输入文件夹，同时就地取材一个可读文件：\n\n```\n./bin/hdfs dfs -mkdir /user/hadoop/input\n./bin/hdfs dfs  -put LICENSE.txt  /user/hadoop/input/LICENSE.txt\n./bin/hdfs dfs  -ls /user/hadoop/input\n```\n\n运行例子，结果放置在output文件夹：\n\n```\n./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.0.jar wordcount /user/hadoop/input /user/hadoop/output\n./bin/hdfs dfs -cat /user/hadoop/output/*\n```\n\n![Screen Shot 2017-05-03 at 11.16.23 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.16.23 PM.png)\n\n\n可以看到，屏幕是被刷了好几遍，因为输出太多了，我们可以统计一下输出了有多少行：\n\n```\n./bin/hdfs dfs -cat /user/hadoop/output/* | wc -l\n```\n\n![Screen Shot 2017-05-03 at 11.17.34 P](https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.17.34 PM.png)\n\n噢，原来有2000多行的输出呢！\n\n\n\n\n## 结论\n\nhadoop的思想已经融入了我们很多分布式系统里面，熟悉hadoop的思想和操作有助于我们更宏观地观察这个现代化网络世界。\n\n\n\n\n\n若有错误之处请指出，更多地关注[煎鱼](http://www.jianyujianyu.com)。\n","slug":"ubuntu16.04-hadoop2.8.0","published":1,"updated":"2017-05-04T15:16:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2eoxsii00002cevcwjfousx","content":"<p><strong><em>学校有几门课程的作业需要我们来写个教程，好吧。</em></strong></p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><p>由于该系统是英文系统，有可能对中文字符支持不友好，因此要安装中文的UTF-8字符集。同时因为Hadoop是Java的杰出产物因此需要安装Java，为了方便，在这里选用OpenJdk，版本Java8。而需要用到的vim、ssh等命令已内置在Ubuntu16.04中，因此无需重复安装。<br><a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo su</div><div class=\"line\">apt install -y language-pack-zh-hant language-pack-zh-hans</div><div class=\"line\">apt install -y openjdk-8-jre openjdk-8-jdk</div></pre></td></tr></table></figure>\n<h3 id=\"创建用户以及权限配置\"><a href=\"#创建用户以及权限配置\" class=\"headerlink\" title=\"创建用户以及权限配置\"></a>创建用户以及权限配置</h3><p>本次实验中我们创建一个hadoop用户，而对hadoop的使用操作都通过hadoop用户实现。同时为了方便hadoop操作中的ssh登录，我们配置无密码ssh登录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd -m hadoop -s /bin/bash</div><div class=\"line\">passwd hadoop</div><div class=\"line\">adduser hadoop sudo</div><div class=\"line\">su hadoop</div></pre></td></tr></table></figure>\n<p>此后，hadoop用户便是运行hadoop程序的用户，以下的操作便是以hadoop用户的身份运行的。接下来生成密钥用于无密码登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa </div><div class=\"line\">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.30.57 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.30.57 P\"></p>\n<p>配置完后即可通过<code>ssh localhost</code>命令无密码登录，需要注意的是要按提示输入yes</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.31.13 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.31.13 P\"></p>\n<h3 id=\"下载hadoop并放置到约定俗成的位置\"><a href=\"#下载hadoop并放置到约定俗成的位置\" class=\"headerlink\" title=\"下载hadoop并放置到约定俗成的位置\"></a>下载hadoop并放置到约定俗成的位置</h3><p>这次实验的hadoop版本是2.8.0，下载使用wget命令，软件源为了快速选用国内的清华源，同时将hadoop文件夹移到约定俗成的<code>/usr/local</code>目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.8.0/hadoop-2.8.0.tar.gz</div><div class=\"line\">tar zxvf hadoop-2.8.0.tar.gz</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.32.49 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.32.49 P\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">mv hadoop-2.8.0 hadoop</div><div class=\"line\">sudo mv hadoop /usr/local/</div><div class=\"line\">sudo chown -R hadoop /usr/local/hadoop</div><div class=\"line\">cd /usr/local/hadoop/</div></pre></td></tr></table></figure>\n<p>此后，<code>/usr/local/hadoop</code>这个目录便是hadoop目录，下面的操作都是在目录下操作的。</p>\n<h3 id=\"配置Java和Hadoop的环境变量\"><a href=\"#配置Java和Hadoop的环境变量\" class=\"headerlink\" title=\"配置Java和Hadoop的环境变量\"></a>配置Java和Hadoop的环境变量</h3><p>需要在<code>/etc/profile</code>和<code>./etc/hadoop/hadoop-env.sh</code>（目前在hadoop目录下）这两个文件的末尾加入以下变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</div><div class=\"line\">CLASSPATH=$CLASSPATH.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</div><div class=\"line\">export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin</div><div class=\"line\">export HADOOP_HOME=/usr/local/hadoop</div><div class=\"line\">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</div></pre></td></tr></table></figure>\n<p>修改第一个文件就是修改当前的环境变量，修改第二个文件就是修改ssh后的环境变量。</p>\n<p>这些就是Java和Hadoop的环境变量，加载了这些环境变量即可在命令行运行特定命令，现在重新加载这配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">. /etc/profile</div></pre></td></tr></table></figure>\n<h2 id=\"配置伪分布式环境\"><a href=\"#配置伪分布式环境\" class=\"headerlink\" title=\"配置伪分布式环境\"></a>配置伪分布式环境</h2><h3 id=\"初始化hdfs\"><a href=\"#初始化hdfs\" class=\"headerlink\" title=\"初始化hdfs\"></a>初始化hdfs</h3><p>编辑./etc/hadoop/core-site.xml和./etc/hadoop/hdfs-site.xml两个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim ./etc/hadoop/core-site.xml</div></pre></td></tr></table></figure>\n<p>修改里面配置，感兴趣的可以查一下含义，主要是每一个property的name和value：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</div><div class=\"line\">             &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim ./etc/hadoop/hdfs-site.xml</div></pre></td></tr></table></figure>\n<p>修改里面配置，指名name、data文件夹在这个服务器上的路径（因为是伪分布式，所以都在这个服务器上）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;1&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<p>以上就完成了伪分布式的配置，接下来就是格式化这些存储节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs namenode -format</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.20.51 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.20.51 P\"></p>\n<p>中间太多了略过直接看末尾：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.21.37 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.21.37 P\"></p>\n<p>在此看到Exiting status为0，结合大多数程序和系统脚本，结束状态码为0即为正常运行结束。</p>\n<h3 id=\"开启-NameNode-和-DataNode-守护进程\"><a href=\"#开启-NameNode-和-DataNode-守护进程\" class=\"headerlink\" title=\"开启 NameNode 和 DataNode 守护进程\"></a>开启 NameNode 和 DataNode 守护进程</h3><p>运行<code>./sbin/start-dfs.sh</code>命令即可启动</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.23.40 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.23.40 P\"></p>\n<p>注意本次运行以及以后的运行程序有可能出现以下WARN：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable</div></pre></td></tr></table></figure>\n<p>该 WARN 提示可以忽略，并不会影响正常使用（该 WARN 可以通过编译 Hadoop 源码解决）。</p>\n<p>而后即可通过 <a href=\"http://机器ip:50070\" target=\"_blank\" rel=\"external\">http://机器ip:50070</a> 来访问 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.44.18 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.44.18 P\"></p>\n<p>在命令界面也可以通过<code>jps</code>来查看 NameNode 和 Datanode 信息是否在运行。</p>\n<h2 id=\"运行例子\"><a href=\"#运行例子\" class=\"headerlink\" title=\"运行例子\"></a>运行例子</h2><h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><p>可以通过<code>./bin/hdfs dfs -help</code>命令来查看使用方法：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.24.41 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.24.41 P\"></p>\n<p>例如查看hadoop版本的命令：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.19.25 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.19.25 P\"></p>\n<h3 id=\"在-HDFS-中创建用户目录\"><a href=\"#在-HDFS-中创建用户目录\" class=\"headerlink\" title=\"在 HDFS 中创建用户目录\"></a>在 HDFS 中创建用户目录</h3><p>先通过<code>./bin/hdfs dfs -mkdir -p /user/hadoop</code>命令创建一个用户目录</p>\n<h3 id=\"例子一-解析配置文件\"><a href=\"#例子一-解析配置文件\" class=\"headerlink\" title=\"例子一 解析配置文件\"></a>例子一 解析配置文件</h3><p>本次实验可以就地取材，选择hadoop的配置文件为材料，使用伪分布式hadoop平台来解析。先用put命令把配置文件都放入hdfs的一个新建文件夹input：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -mkdir /user/hadoop/input</div><div class=\"line\">./bin/hdfs dfs -put ./etc/hadoop/*.xml /user/hadoop/input/</div><div class=\"line\">./bin/hdfs dfs -ls input</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.08.16 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.08.16 P\"></p>\n<p>然后运行例子，解析input里面的配置文件，并将解析结果放入output文件夹：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /user/hadoop/input/* /user/hadoop/output &apos;dfs[a-z.]+&apos;</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.22 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.09.22 P\"></p>\n<p>把output里面的解析结果通过cat命令输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -cat /user/hadoop/output/*</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.52 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.09.52 P\"></p>\n<p>把output里面的解析结果从hdfs中取出（这个操作是常用的，尽管在伪分布式里面没什么意义，但是在真实环境下特别有用）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -get /user/hadoop/output ./output</div></pre></td></tr></table></figure>\n<h3 id=\"例子二-WordCount\"><a href=\"#例子二-WordCount\" class=\"headerlink\" title=\"例子二 WordCount\"></a>例子二 WordCount</h3><p>wordcount是一个hadoop内置的范例程序，用于统计单词数量。</p>\n<p>首先，要删除例子一留下的实验痕迹：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -rm -r -f /user/hadoop/output /user/hadoop/input</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.15.36 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.15.36 P\"></p>\n<p>然后和实验一一样，创建hadoop的输入文件夹，同时就地取材一个可读文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -mkdir /user/hadoop/input</div><div class=\"line\">./bin/hdfs dfs  -put LICENSE.txt  /user/hadoop/input/LICENSE.txt</div><div class=\"line\">./bin/hdfs dfs  -ls /user/hadoop/input</div></pre></td></tr></table></figure>\n<p>运行例子，结果放置在output文件夹：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.0.jar wordcount /user/hadoop/input /user/hadoop/output</div><div class=\"line\">./bin/hdfs dfs -cat /user/hadoop/output/*</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.16.23 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.16.23 P\"></p>\n<p>可以看到，屏幕是被刷了好几遍，因为输出太多了，我们可以统计一下输出了有多少行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -cat /user/hadoop/output/* | wc -l</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.17.34 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.17.34 P\"></p>\n<p>噢，原来有2000多行的输出呢！</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>hadoop的思想已经融入了我们很多分布式系统里面，熟悉hadoop的思想和操作有助于我们更宏观地观察这个现代化网络世界。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>\n","site":{"data":{}},"excerpt":"<p><strong><em>学校有几门课程的作业需要我们来写个教程，好吧。</em></strong></p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><p>由于该系统是英文系统，有可能对中文字符支持不友好，因此要安装中文的UTF-8字符集。同时因为Hadoop是Java的杰出产物因此需要安装Java，为了方便，在这里选用OpenJdk，版本Java8。而需要用到的vim、ssh等命令已内置在Ubuntu16.04中，因此无需重复安装。<br>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo su</div><div class=\"line\">apt install -y language-pack-zh-hant language-pack-zh-hans</div><div class=\"line\">apt install -y openjdk-8-jre openjdk-8-jdk</div></pre></td></tr></table></figure>\n<h3 id=\"创建用户以及权限配置\"><a href=\"#创建用户以及权限配置\" class=\"headerlink\" title=\"创建用户以及权限配置\"></a>创建用户以及权限配置</h3><p>本次实验中我们创建一个hadoop用户，而对hadoop的使用操作都通过hadoop用户实现。同时为了方便hadoop操作中的ssh登录，我们配置无密码ssh登录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">useradd -m hadoop -s /bin/bash</div><div class=\"line\">passwd hadoop</div><div class=\"line\">adduser hadoop sudo</div><div class=\"line\">su hadoop</div></pre></td></tr></table></figure>\n<p>此后，hadoop用户便是运行hadoop程序的用户，以下的操作便是以hadoop用户的身份运行的。接下来生成密钥用于无密码登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-keygen -t rsa </div><div class=\"line\">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.30.57 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.30.57 P\"></p>\n<p>配置完后即可通过<code>ssh localhost</code>命令无密码登录，需要注意的是要按提示输入yes</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.31.13 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.31.13 P\"></p>\n<h3 id=\"下载hadoop并放置到约定俗成的位置\"><a href=\"#下载hadoop并放置到约定俗成的位置\" class=\"headerlink\" title=\"下载hadoop并放置到约定俗成的位置\"></a>下载hadoop并放置到约定俗成的位置</h3><p>这次实验的hadoop版本是2.8.0，下载使用wget命令，软件源为了快速选用国内的清华源，同时将hadoop文件夹移到约定俗成的<code>/usr/local</code>目录下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.8.0/hadoop-2.8.0.tar.gz</div><div class=\"line\">tar zxvf hadoop-2.8.0.tar.gz</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.32.49 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.32.49 P\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">mv hadoop-2.8.0 hadoop</div><div class=\"line\">sudo mv hadoop /usr/local/</div><div class=\"line\">sudo chown -R hadoop /usr/local/hadoop</div><div class=\"line\">cd /usr/local/hadoop/</div></pre></td></tr></table></figure>\n<p>此后，<code>/usr/local/hadoop</code>这个目录便是hadoop目录，下面的操作都是在目录下操作的。</p>\n<h3 id=\"配置Java和Hadoop的环境变量\"><a href=\"#配置Java和Hadoop的环境变量\" class=\"headerlink\" title=\"配置Java和Hadoop的环境变量\"></a>配置Java和Hadoop的环境变量</h3><p>需要在<code>/etc/profile</code>和<code>./etc/hadoop/hadoop-env.sh</code>（目前在hadoop目录下）这两个文件的末尾加入以下变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</div><div class=\"line\">CLASSPATH=$CLASSPATH.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</div><div class=\"line\">export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin</div><div class=\"line\">export HADOOP_HOME=/usr/local/hadoop</div><div class=\"line\">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</div></pre></td></tr></table></figure>\n<p>修改第一个文件就是修改当前的环境变量，修改第二个文件就是修改ssh后的环境变量。</p>\n<p>这些就是Java和Hadoop的环境变量，加载了这些环境变量即可在命令行运行特定命令，现在重新加载这配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">. /etc/profile</div></pre></td></tr></table></figure>\n<h2 id=\"配置伪分布式环境\"><a href=\"#配置伪分布式环境\" class=\"headerlink\" title=\"配置伪分布式环境\"></a>配置伪分布式环境</h2><h3 id=\"初始化hdfs\"><a href=\"#初始化hdfs\" class=\"headerlink\" title=\"初始化hdfs\"></a>初始化hdfs</h3><p>编辑./etc/hadoop/core-site.xml和./etc/hadoop/hdfs-site.xml两个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim ./etc/hadoop/core-site.xml</div></pre></td></tr></table></figure>\n<p>修改里面配置，感兴趣的可以查一下含义，主要是每一个property的name和value：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</div><div class=\"line\">             &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim ./etc/hadoop/hdfs-site.xml</div></pre></td></tr></table></figure>\n<p>修改里面配置，指名name、data文件夹在这个服务器上的路径（因为是伪分布式，所以都在这个服务器上）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;1&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">             &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</div><div class=\"line\">             &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<p>以上就完成了伪分布式的配置，接下来就是格式化这些存储节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs namenode -format</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.20.51 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.20.51 P\"></p>\n<p>中间太多了略过直接看末尾：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.21.37 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.21.37 P\"></p>\n<p>在此看到Exiting status为0，结合大多数程序和系统脚本，结束状态码为0即为正常运行结束。</p>\n<h3 id=\"开启-NameNode-和-DataNode-守护进程\"><a href=\"#开启-NameNode-和-DataNode-守护进程\" class=\"headerlink\" title=\"开启 NameNode 和 DataNode 守护进程\"></a>开启 NameNode 和 DataNode 守护进程</h3><p>运行<code>./sbin/start-dfs.sh</code>命令即可启动</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.23.40 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.23.40 P\"></p>\n<p>注意本次运行以及以后的运行程序有可能出现以下WARN：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable</div></pre></td></tr></table></figure>\n<p>该 WARN 提示可以忽略，并不会影响正常使用（该 WARN 可以通过编译 Hadoop 源码解决）。</p>\n<p>而后即可通过 <a href=\"http://机器ip:50070\">http://机器ip:50070</a> 来访问 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 10.44.18 PM.png\" alt=\"Screen Shot 2017-05-03 at 10.44.18 P\"></p>\n<p>在命令界面也可以通过<code>jps</code>来查看 NameNode 和 Datanode 信息是否在运行。</p>\n<h2 id=\"运行例子\"><a href=\"#运行例子\" class=\"headerlink\" title=\"运行例子\"></a>运行例子</h2><h3 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h3><p>可以通过<code>./bin/hdfs dfs -help</code>命令来查看使用方法：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.24.41 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.24.41 P\"></p>\n<p>例如查看hadoop版本的命令：</p>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.19.25 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.19.25 P\"></p>\n<h3 id=\"在-HDFS-中创建用户目录\"><a href=\"#在-HDFS-中创建用户目录\" class=\"headerlink\" title=\"在 HDFS 中创建用户目录\"></a>在 HDFS 中创建用户目录</h3><p>先通过<code>./bin/hdfs dfs -mkdir -p /user/hadoop</code>命令创建一个用户目录</p>\n<h3 id=\"例子一-解析配置文件\"><a href=\"#例子一-解析配置文件\" class=\"headerlink\" title=\"例子一 解析配置文件\"></a>例子一 解析配置文件</h3><p>本次实验可以就地取材，选择hadoop的配置文件为材料，使用伪分布式hadoop平台来解析。先用put命令把配置文件都放入hdfs的一个新建文件夹input：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -mkdir /user/hadoop/input</div><div class=\"line\">./bin/hdfs dfs -put ./etc/hadoop/*.xml /user/hadoop/input/</div><div class=\"line\">./bin/hdfs dfs -ls input</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.08.16 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.08.16 P\"></p>\n<p>然后运行例子，解析input里面的配置文件，并将解析结果放入output文件夹：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /user/hadoop/input/* /user/hadoop/output &apos;dfs[a-z.]+&apos;</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.22 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.09.22 P\"></p>\n<p>把output里面的解析结果通过cat命令输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -cat /user/hadoop/output/*</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.09.52 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.09.52 P\"></p>\n<p>把output里面的解析结果从hdfs中取出（这个操作是常用的，尽管在伪分布式里面没什么意义，但是在真实环境下特别有用）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -get /user/hadoop/output ./output</div></pre></td></tr></table></figure>\n<h3 id=\"例子二-WordCount\"><a href=\"#例子二-WordCount\" class=\"headerlink\" title=\"例子二 WordCount\"></a>例子二 WordCount</h3><p>wordcount是一个hadoop内置的范例程序，用于统计单词数量。</p>\n<p>首先，要删除例子一留下的实验痕迹：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -rm -r -f /user/hadoop/output /user/hadoop/input</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.15.36 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.15.36 P\"></p>\n<p>然后和实验一一样，创建hadoop的输入文件夹，同时就地取材一个可读文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -mkdir /user/hadoop/input</div><div class=\"line\">./bin/hdfs dfs  -put LICENSE.txt  /user/hadoop/input/LICENSE.txt</div><div class=\"line\">./bin/hdfs dfs  -ls /user/hadoop/input</div></pre></td></tr></table></figure>\n<p>运行例子，结果放置在output文件夹：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.0.jar wordcount /user/hadoop/input /user/hadoop/output</div><div class=\"line\">./bin/hdfs dfs -cat /user/hadoop/output/*</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.16.23 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.16.23 P\"></p>\n<p>可以看到，屏幕是被刷了好几遍，因为输出太多了，我们可以统计一下输出了有多少行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./bin/hdfs dfs -cat /user/hadoop/output/* | wc -l</div></pre></td></tr></table></figure>\n<p><img src=\"https://oda3wj69k.qnssl.com/2017-05-04-Screen Shot 2017-05-03 at 11.17.34 PM.png\" alt=\"Screen Shot 2017-05-03 at 11.17.34 P\"></p>\n<p>噢，原来有2000多行的输出呢！</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>hadoop的思想已经融入了我们很多分布式系统里面，熟悉hadoop的思想和操作有助于我们更宏观地观察这个现代化网络世界。</p>\n<p>若有错误之处请指出，更多地关注<a href=\"http://www.jianyujianyu.com\">煎鱼</a>。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj1utjtrg0007uoevcvpl4lv8","category_id":"cj1utjtrc0004uoev6isa8gnz","_id":"cj1utjtrn000cuoev3a9429wz"},{"post_id":"cj1utjtqz0001uoevjhelys3q","category_id":"cj1utjtrc0004uoev6isa8gnz","_id":"cj1utjtrp000guoevgj9ti4nz"},{"post_id":"cj1utjtr90003uoevzckp7mqj","category_id":"cj1utjtrk0009uoevjgslhywj","_id":"cj1utjtrs000kuoevm7sy0smc"},{"post_id":"cj1utjtrn000duoevjzutihqp","category_id":"cj1utjtrk0009uoevjgslhywj","_id":"cj1utjtry000puoevdudroq77"},{"post_id":"cj1utjtrf0006uoevovenrbk0","category_id":"cj1utjtro000euoevxjnax8g0","_id":"cj1utjtrz000quoevg8jlcb0d"},{"post_id":"cj1utjtri0008uoevhuw4s33z","category_id":"cj1utjtru000muoevsmz80yxy","_id":"cj1utjts1000uuoevr8f8hur7"},{"post_id":"cj1utjtrm000buoev5963iyb5","category_id":"cj1utjtrz000ruoev9shareb3","_id":"cj1utjts1000zuoevm1xx6cyu"},{"post_id":"cj1utjtrq000huoevs130hbc8","category_id":"cj1utjts1000wuoev8z9tj5q3","_id":"cj1utjts20012uoev3utoix4w"},{"post_id":"cj1utjtrr000juoev1c2quckc","category_id":"cj1utjts20010uoevglq7fflr","_id":"cj1utjts20016uoevrcmxci2b"},{"post_id":"cj1utjtrv000ouoevbs5ks1g8","category_id":"cj1utjts20013uoevujy1db84","_id":"cj1utjts50019uoevjz5btfqb"},{"post_id":"cj22nsvtm000039evhhrpeowc","category_id":"cj22nsvtz000139ev3yub9wa2","_id":"cj22nsvuc000439ev6dfjn29n"},{"post_id":"cj2eoxsii00002cevcwjfousx","category_id":"cj2eoxsio00012cevjng66scq","_id":"cj2eoxsix00042cevxpjdt310"}],"PostTag":[{"post_id":"cj1utjtqz0001uoevjhelys3q","tag_id":"cj1utjtre0005uoevhiek7m1w","_id":"cj1utjtrq000iuoev57ea4q2l"},{"post_id":"cj1utjtqz0001uoevjhelys3q","tag_id":"cj1utjtrk000auoevqpzg5iz3","_id":"cj1utjtrt000luoev9gbeh5ve"},{"post_id":"cj1utjtr90003uoevzckp7mqj","tag_id":"cj1utjtrp000fuoev1pinv4kq","_id":"cj1utjts0000tuoevwy929dlf"},{"post_id":"cj1utjtr90003uoevzckp7mqj","tag_id":"cj1utjtru000nuoevck0wbzo3","_id":"cj1utjts1000vuoev0zccro7m"},{"post_id":"cj1utjtrf0006uoevovenrbk0","tag_id":"cj1utjts0000suoevhetrk5z4","_id":"cj1utjts1000yuoev1jq7ck1e"},{"post_id":"cj1utjtrg0007uoevcvpl4lv8","tag_id":"cj1utjts1000xuoevadig9f59","_id":"cj1utjts20015uoevacur6ax1"},{"post_id":"cj1utjtrg0007uoevcvpl4lv8","tag_id":"cj1utjts20011uoevicxhro73","_id":"cj1utjts30017uoevaqgpetn0"},{"post_id":"cj1utjtri0008uoevhuw4s33z","tag_id":"cj1utjts20014uoev49uxi551","_id":"cj1utjts6001buoevkfk242gy"},{"post_id":"cj1utjtri0008uoevhuw4s33z","tag_id":"cj1utjts30018uoev33z1tikk","_id":"cj1utjts6001cuoevnxu6uyls"},{"post_id":"cj1utjtrm000buoev5963iyb5","tag_id":"cj1utjts5001auoev2exrmun2","_id":"cj1utjts7001euoevy6enmrb3"},{"post_id":"cj1utjtrn000duoevjzutihqp","tag_id":"cj1utjts6001duoevjl95p3ql","_id":"cj1utjts8001huoevfrnrf7kg"},{"post_id":"cj1utjtrn000duoevjzutihqp","tag_id":"cj1utjts7001fuoevbd531qfh","_id":"cj1utjts8001iuoevt18mdcdb"},{"post_id":"cj1utjtrq000huoevs130hbc8","tag_id":"cj1utjts8001guoevcpaysm5k","_id":"cj1utjts9001luoevgy4ewxso"},{"post_id":"cj1utjtrq000huoevs130hbc8","tag_id":"cj1utjts8001juoev2aqhwu1w","_id":"cj1utjts9001muoevwp2ffg7v"},{"post_id":"cj1utjtrr000juoev1c2quckc","tag_id":"cj1utjts9001kuoevivei4v2i","_id":"cj1utjtsa001quoev2lin39k6"},{"post_id":"cj1utjtrr000juoev1c2quckc","tag_id":"cj1utjts9001nuoev5tdcrqz6","_id":"cj1utjtsa001ruoevb4oq5dtq"},{"post_id":"cj1utjtrr000juoev1c2quckc","tag_id":"cj1utjtsa001ouoevsw6xb88n","_id":"cj1utjtsb001tuoevuskwlc5v"},{"post_id":"cj1utjtrv000ouoevbs5ks1g8","tag_id":"cj1utjtsa001puoevv6q18szi","_id":"cj1utjtsb001uuoevu8kb72r5"},{"post_id":"cj1utjtrv000ouoevbs5ks1g8","tag_id":"cj1utjtsa001suoevhvnhik9d","_id":"cj1utjtsb001vuoev9wd5n6dd"},{"post_id":"cj22nsvtm000039evhhrpeowc","tag_id":"cj22nsvu9000239evipdo1s1i","_id":"cj22nsvuf000639evcxgqku7w"},{"post_id":"cj22nsvtm000039evhhrpeowc","tag_id":"cj22nsvub000339evyv3w2nlo","_id":"cj22nsvuf000739ev68igjtvk"},{"post_id":"cj22nsvtm000039evhhrpeowc","tag_id":"cj22nsvud000539evimm0mtem","_id":"cj22nsvug000839evgiswtbke"},{"post_id":"cj2eoxsii00002cevcwjfousx","tag_id":"cj2eoxsiv00022cevhe2ao8el","_id":"cj2eoxsix00052cevjpnu17vm"},{"post_id":"cj2eoxsii00002cevcwjfousx","tag_id":"cj2eoxsiw00032cevvgey5ff8","_id":"cj2eoxsix00062cevcvt3ay3a"}],"Tag":[{"name":"RPi","_id":"cj1utjtre0005uoevhiek7m1w"},{"name":"TF","_id":"cj1utjtrk000auoevqpzg5iz3"},{"name":"java","_id":"cj1utjtrp000fuoev1pinv4kq"},{"name":"niosocket","_id":"cj1utjtru000nuoevck0wbzo3"},{"name":"机器学习","_id":"cj1utjts0000suoevhetrk5z4"},{"name":"NLP","_id":"cj1utjts1000xuoevadig9f59"},{"name":"AI","_id":"cj1utjts20011uoevicxhro73"},{"name":"CNN","_id":"cj1utjts20014uoev49uxi551"},{"name":"卷积神经网络","_id":"cj1utjts30018uoev33z1tikk"},{"name":"caffe","_id":"cj1utjts5001auoev2exrmun2"},{"name":"jdbc","_id":"cj1utjts6001duoevjl95p3ql"},{"name":"mybatis","_id":"cj1utjts7001fuoevbd531qfh"},{"name":"go","_id":"cj1utjts8001guoevcpaysm5k"},{"name":"web","_id":"cj1utjts8001juoev2aqhwu1w"},{"name":"后台","_id":"cj1utjts9001kuoevivei4v2i"},{"name":"Raspberry","_id":"cj1utjts9001nuoev5tdcrqz6"},{"name":"闲聊","_id":"cj1utjtsa001ouoevsw6xb88n"},{"name":"python","_id":"cj1utjtsa001puoevv6q18szi"},{"name":"unicode","_id":"cj1utjtsa001suoevhvnhik9d"},{"name":"jenkins","_id":"cj22nsvu9000239evipdo1s1i"},{"name":"hexo","_id":"cj22nsvub000339evyv3w2nlo"},{"name":"blog","_id":"cj22nsvud000539evimm0mtem"},{"name":"hadoop","_id":"cj2eoxsiv00022cevhe2ao8el"},{"name":"distributed","_id":"cj2eoxsiw00032cevvgey5ff8"}]}}